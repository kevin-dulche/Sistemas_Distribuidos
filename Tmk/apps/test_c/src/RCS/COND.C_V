head	1.5;
access;
symbols;
locks; strict;
comment	@ * @;


1.5
date	97.05.26.04.32.09;	author alc;	state Exp;
branches;
next	1.4;

1.4
date	97.05.26.04.17.48;	author alc;	state Exp;
branches;
next	1.3;

1.3
date	97.04.12.08.54.26;	author alc;	state Exp;
branches;
next	1.2;

1.2
date	97.04.12.08.51.40;	author alc;	state Exp;
branches;
next	1.1;

1.1
date	97.04.12.08.50.05;	author alc;	state Exp;
branches;
next	;


desc
@Test condition variables.
@


1.5
log
@Updated to match the current interface.
@
text
@/*
 * Condition variable test program
 *
 * Created by Rob Fowler
 *
 * $Id: cond.c,v 1.4 1997/05/26 04:17:48 alc Exp alc $
 */
#include <sys/time.h>
#include <stdio.h>

#include "Tmk.h"

unsigned        monlock;
int             pshift;

extern char    *optarg;

int             debug = 0;
int             mysignals;
int             mywaits;
int             iterations = 5;

struct phonyq {
	int             count;
	int             value;
	int             visits[TMK_NPROCS];
	int             waits[TMK_NPROCS];
	int             signals[TMK_NPROCS];
	int             padding[2000];
};

struct phonyq  *mq;

main(argc, argv)
	int             argc;
	char           *argv[];
{
	struct timeval  start, end;
	int             mycount = 0;
	char            c;

	pshift = monlock = 0;

	while ((c = getopt(argc, argv, "di:l:s:")) != -1)
		switch (c) {
		case 'd':
			debug++;
			printf("Debugging on.\n");
			break;
		case 'i':
			iterations = atoi(optarg);
			Tmk_err("Run for %d iterations \n", iterations);
			break;
		case 'l':
			monlock = atoi(optarg);
			Tmk_err("Using lock %d\n", monlock);
			break;
		case 's':
			pshift = atoi(optarg);
			break;
		}

	Tmk_startup(argc, argv);

	if (Tmk_nprocs < 2) {
		Tmk_errexit("Producer/consumer test.\n"
			    "Must be run with at least two procs.\n");
	}

	Tmk_err("Producer =  %d\n", pshift);
	Tmk_err("Consumer =  %d\n", (pshift + 1) % Tmk_nprocs);

	if (Tmk_proc_id == 0) {

		int             i;

		if ((mq = (struct phonyq *) Tmk_malloc(sizeof(struct phonyq))) == NULL)
			Tmk_errexit("Tmk_malloc error");

		mq->value = 2000;
		mq->count = 0;
		for (i = 0; i < 2000; i++)
			mq->padding[i] = i;

		Tmk_distribute((char *)&mq, sizeof(mq));
	}
	Tmk_barrier(0);

	/*
	 * mq->value == 2000 means the buffer is empty.  == 3000 means full
	 * condition 1 is used to signal full. condition 0 is used to signal
	 * empty.
	 */

	gettimeofday(&start, NULL);

	if (Tmk_proc_id == pshift) {

		if (debug)
			Tmk_err("Producer (node %d) ready to start\n", Tmk_proc_id);

		mywaits = mysignals = 0;

		while (mycount < iterations) {

			Tmk_lock_acquire(monlock);

			if (debug)
				Tmk_err("... got lock ...");

			mq->visits[Tmk_proc_id]++;

			if (mq->value == 2000) {

				mq->value = 3000;
				mycount = mq->count += 1;

				mq->signals[Tmk_proc_id] = mysignals += 1;

				Tmk_lock_cond_signal(monlock, 1);
			}
			else if (mq->value == 3000) {

				mq->waits[Tmk_proc_id] = mywaits += 1;

				Tmk_lock_cond_wait(monlock, 0);

				if (debug)
					fprintf(stderr, "after %d awakenings\n", mywaits);
			}
			else {
				Tmk_err("Something really wrong\n");
			}
			Tmk_lock_release(monlock);
		}
	}
	else if (Tmk_proc_id == (pshift + 1) % Tmk_nprocs) {

		if (debug)
			Tmk_err("Consumer %d ready to start\n", Tmk_proc_id);

		mywaits = mysignals = 0;

		while (mycount < iterations) {

			Tmk_lock_acquire(monlock);

			if (debug)
				Tmk_err("... got lock ...");

			mq->count++;
			mq->visits[Tmk_proc_id]++;

			if (mq->value == 3000) {
				int             i;

				mycount = mq->count;
				mq->value = 2000;
				mq->signals[Tmk_proc_id] = mysignals += 1;

				Tmk_lock_cond_signal(monlock, 0);
			}
			else if (mq->value == 2000) {

				mq->waits[Tmk_proc_id] = mywaits += 1;

				Tmk_lock_cond_wait(monlock, 1);

				if (debug)
					fprintf(stderr, "consumer after %d iterations\n", mywaits);
			}
			else {
				Tmk_err("Something really wrong\n");
			}
			Tmk_lock_release(monlock);
		}
	}
	else {
		if (debug)
			Tmk_err("Manager (?)  %d ready to start\n", Tmk_proc_id);
	}
	Tmk_barrier(0);

	gettimeofday(&end, NULL);

	fprintf(stderr, "Elapsed time: %.3f milliseconds\n",
		(((end.tv_sec * 1000000.0 + end.tv_usec) -
		  (start.tv_sec * 1000000.0 + start.tv_usec)) / 1000.0));

	Tmk_exit(0);
}
@


1.4
log
@Reformatted.
@
text
@d2 5
a6 1
 * $Id: cond.c,v 1.3 1997/04/12 08:54:26 alc Exp alc $
a33 1

d52 1
a52 1
			Tmk_err("Run for  %d iterations \n", iterations);
a60 1

d77 1
a77 2
		mq = (struct phonyq *) Tmk_malloc(sizeof(struct phonyq));
		if (mq == NULL)
d79 1
a114 2
				int             i;

d120 1
a120 1
				Tmk_condition_signal(1, monlock);
d123 1
d125 2
a126 1
				Tmk_condition_wait(0, monlock);
d153 1
d156 1
d160 2
a161 1
				Tmk_condition_signal(0, monlock);
d164 1
d166 3
a168 1
				Tmk_condition_wait(1, monlock);
a188 4

	if (debug)
		while (1)
			pause();
@


1.3
log
@Added the explicit lock parameter to the condition signal calls.
@
text
@d2 1
a2 1
 * $Id: cond.c,v 1.2 1997/04/12 08:51:40 alc Exp alc $
d9 2
a10 2
unsigned monlock;
int pshift;
d12 1
a12 1
extern char *optarg;
d14 4
a17 4
int debug = 0;
int mysignals;
int mywaits;
int iterations = 5;
d20 7
a26 7
    int	 count;
    int	 value;
    int  visits[TMK_NPROCS];
    int  waits[TMK_NPROCS];
    int  signals[TMK_NPROCS];
    int  padding[2000];
};  
d28 1
a28 1
struct phonyq *mq;
d32 2
a33 2
	int		argc;
	char	       *argv[];
d35 4
a38 3
	struct timeval	start, end;
	int mycount = 0;
	char c;
d40 1
d43 1
a43 1
		case 'd': 
d59 1
a59 2
		};

d63 4
a66 2
	if (Tmk_nprocs <2)
		{Tmk_errexit("Producer/consumer test.\nMust be run with at least two procs.\n");}
d69 1
a69 1
	Tmk_err("Consumer =  %d\n", (pshift +1) % Tmk_nprocs);
d71 1
a71 7
	if (Tmk_proc_id == 0)
	    { int i;
		mq = (struct phonyq *) Tmk_malloc( sizeof(struct phonyq));
		if (mq == NULL) Tmk_errexit("Tmk_malloc error");
		mq->value = 2000;
		mq->count =0;
		for (i=0;i<2000;i++) mq->padding[i] = i;
d73 1
a73 1
		Tmk_distribute((char *) &mq, sizeof(mq));
d75 7
a81 5
	    };
/*  	    else  { 
	    freopen("err1","w", stderr); 
	    }; 
*/	
d83 2
d87 5
a91 4
/*    mq->value == 2000 means the buffer is empty.  == 3000 means full 
	condition 1 is used to signal full.
	condition 0 is used to signal empty.
*/
d95 8
a102 1
	if(Tmk_proc_id == pshift) { 
d104 1
a104 1
	if (debug)  Tmk_err("Producer (node %d) ready to start\n",Tmk_proc_id);
d106 2
a107 2
	mywaits= mysignals= 0;
	while (mycount < iterations) {
d109 1
a109 7
	    Tmk_lock_acquire(monlock);
		if (debug) Tmk_err("... got lock ...");
	    mq->visits[Tmk_proc_id]++;
	    if(mq->value == 2000) {
	        int i; 	
		mq->value = 3000;
	        mycount = mq->count += 1;
d111 3
a113 12
		mq->signals[Tmk_proc_id] = mysignals += 1;
		Tmk_condition_signal(1, monlock);
		}
		else if (mq->value == 3000) {
		    mq->waits[Tmk_proc_id] = mywaits += 1;
		    Tmk_condition_wait(0, monlock);
		   if (debug) fprintf(stderr, "after %d awakenings\n",mywaits);
	     } else { Tmk_err("Something really wrong\n");
	     };
	    Tmk_lock_release(monlock);
	};
	}
d115 2
a116 2
	else if ( Tmk_proc_id == (pshift +1) % Tmk_nprocs) { 
	    if (debug) Tmk_err("Consumer %d ready to start\n",Tmk_proc_id);
d118 1
a118 1
	mywaits= mysignals= 0;
d120 5
a124 1
	while (mycount< iterations) {
d126 7
a132 10
	    Tmk_lock_acquire(monlock);
		if (debug) Tmk_err("... got lock ...");
	    mq->count++;
	    mq->visits[Tmk_proc_id]++;
	    if(mq->value == 3000) {
	        int i; 	
		mycount = mq->count;
		mq->value = 2000;
		mq->signals[Tmk_proc_id] = mysignals += 1;
		Tmk_condition_signal(0, monlock);
d134 2
a135 7
		else if (mq->value == 2000) {
		    mq->waits[Tmk_proc_id] = mywaits += 1;
		    Tmk_condition_wait(1, monlock);
		   if (debug) fprintf(stderr, "consumer after %d iterations\n",mywaits);
	     } else { 
	        Tmk_err("Something really wrong\n");
	        };
d137 2
a138 1
	    Tmk_lock_release(monlock);
d140 1
a140 4
	    };
	}
	else { if (debug) Tmk_err("Manager (?)  %d ready to start\n",Tmk_proc_id);
	};
d142 1
d144 30
d175 1
a175 1
	
d179 2
a180 2
		(  ((end.tv_sec*1000000.0 + end.tv_usec) -
		   (start.tv_sec*1000000.0 + start.tv_usec)) /1000.0));
d182 3
a184 1
	if(debug) while(1) pause();
@


1.2
log
@Modified code format.
@
text
@d2 1
a2 1
 * $Id: cond.c,v 1.1 1997/04/12 08:50:05 alc Exp alc $
d109 1
a109 1
		Tmk_condition_signal(1);
d137 1
a137 1
		Tmk_condition_signal(0);
@


1.1
log
@Initial revision
@
text
@d2 1
a2 1
 * $Id$
d19 8
a26 8
	struct phonyq {
	    int	 count;
	    int	 value;
	    int  visits[TMK_NPROCS];
	    int  waits[TMK_NPROCS];
	    int  signals[TMK_NPROCS];
	    int  padding[2000];
	};  
a166 1

@
