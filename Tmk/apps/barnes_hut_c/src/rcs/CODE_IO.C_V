head	10.3;
access;
symbols
	Tmk-1_0_1R:10.3;
locks; strict;
comment	@ * @;


10.3
date	97.12.21.00.54.29;	author alc;	state Exp;
branches;
next	10.2;

10.2
date	97.06.02.07.56.00;	author alc;	state Exp;
branches;
next	1.1;

1.1
date	97.06.02.07.43.15;	author alc;	state Exp;
branches;
next	;


desc
@Barnes-Hut galaxy simulation
@


10.3
log
@<stdio.h> is already included by "code.h" -> "defs.h" -> "stdinc.h".
@
text
@/* This code was derived from the original barnes code.c. output() has been
   changed as follows:

        1. The computation done inside the critical section Global->CountLock
	   has been changed. Each processor places *its* values into global
	   space.
	2. The output of info by proc0 has been postponed to until after the
	   next barrier (Global->Barpos) in code.c. 
	
    output() hence has no synchronization.

    						-ram (rrk@@rice.edu)
*/

#include <Tmk.h>

#define global extern
    
#include "code.h"

local void diagnostics();
local void in_int(stream str, int *iptr);
local void in_real(stream str, real *rptr);
local void in_vector(stream str, vector vec);

    /*
     * INPUTDATA: read initial conditions from input file.
     */
    
void inputdata()
{
    stream instr;
    permanent char headbuf[128];
    int ndim,counter=0;
    /*    char *malloc(); */
    bodyptr p;
    
    fprintf(stderr,"reading input file : %s\n",infile);
    fflush(stderr);
    instr = fopen(infile, "r");                  /* open input stream        */
    if (instr == NULL)
        barnes_error("inputdata: cannot find file %s\n", infile);
    sprintf(headbuf, "Hack code: input file %s\n", infile);
    headline = headbuf;
    in_int(instr, &nbody);
    if (nbody < 1)
        barnes_error("inputdata: nbody = %d is absurd\n", nbody);
    in_int(instr, &ndim);
    if (ndim != NDIM)
        barnes_error("inputdata: NDIM = %d ndim = %d is absurd\n", NDIM,ndim);
    in_real(instr, &tnow);
    bodytab = (bodyptr) Tmk_malloc(nbody * sizeof(body));
    if (bodytab == NULL)
      barnes_error("inputdata: not enuf memory\n");
    else
      Tmk_distribute((char *)&bodytab, sizeof(bodytab));
    for (p = bodytab; p < bodytab+nbody; p++) { /* loop over new bodies     */
      Type(p) = BODY;                         /*   init body type         */
      Cost(p) = 1;                            /*   init cost              */
      Phi(p) = 0.0;
      CLRV(Acc(p));
    } 
    for (p = bodytab; p < bodytab+nbody; p++)
        in_real(instr, &Mass(p));
    for (p = bodytab; p < bodytab+nbody; p++)
        in_vector(instr, Pos(p));
    for (p = bodytab; p < bodytab+nbody; p++)
        in_vector(instr, Vel(p));
    fclose(instr);                               /* close input stream      */
}

/*
 * INITOUTPUT: initialize output routines.
 */

FILE *outstr;                             /* output stream pointer   */

void initoutput()
{
    printf("\n\t\t%s\n\n", headline);
    printf("%10s%10s%10s%10s%10s%10s%10s%10s\n",
           "nbody", "dtime", "eps", "tol", "dtout", "tstop","fcells","NPROC");
    printf("%10d%10.5f%10.4f%10.3f%10.3f%10.3f%10.3f%10d\n\n",
           nbody, dtime, eps, tol, dtout, tstop, fcells, Tmk_nprocs);
#ifdef TRACK
    printf("\n%-38s%-38s\n\n","As a percent of Min","As a percent of Avg:");
    printf("%6s%8s%8s%8s%8s%6s%8s%8s%8s%8s\n","Step","Work","Work","Bod","Bod"," ","Work","Work","Bod","Bod");
    printf("%6s%8s%8s%8s%8s%6s%8s%8s%8s%8s\n"," ","Rng","Dev","Rng","Dev"," ","Rng","Dev","Rng","Dev");
    fflush(stdout);
#endif
    outstr = fopen("sample.out", "w");
}

/*
 * STOPOUTPUT: finish up after a run.
 */

void stopoutput()
{
    if (outstr != NULL)
        fclose(outstr);
}

/*
 * Counters and accumulators for output routines.
 */

local real mymtot;                   /* total mass of N-body system        */
local real myetot[3];                /* binding, kinetic, potential energy */
local matrix myketen;                /* kinetic energy tensor              */
local matrix mypeten;                /* potential energy tensor            */
local vector mycmphase[2];           /* center of mass coordinates         */
local vector myamvec;                /* angular momentum vector            */

/*
 * OUTPUT: compute diagnostics and output data.
 */

void output()
{
    int nttot, nbavg, ncavg,k;
    double cputime();
    bodyptr p, *pp;
    vector tempv1,tempv2;
    
    if ((tout - 0.01 * dtime) <= tnow) {        /*  time for next output?   */
#ifdef OUTPUT  
    if (Tmk_proc_id == 0) {
        /*   write particle data    */
      fprintf(outstr, "Out\n");
      fprintf(outstr, "%d %d %10.3f\n", nbody, NDIM, tnow);
      for (p = bodytab; p < bodytab+nbody; p++)
	out_real(outstr, Mass(p));
      for (p = bodytab; p < bodytab+nbody; p++){
	out_vector(outstr, Pos(p));
      }
      for (p = bodytab; p < bodytab+nbody; p++)
	out_vector(outstr, Vel(p));
    }
#endif
        tout += dtout;                          /*  schedule next data out  */
    }

    diagnostics();                              /* compute std diagnostics  */
    
    if (mymtot!=0) {               /* sum partial counters into global ones */
	/* Lock removed by not accumulating into the global values. -rrk */

        /* Tmk_lock_acquire(Global->CountLock); */
            
        privGlobal[Tmk_proc_id]->n2bcalc += myn2bcalc;
        privGlobal[Tmk_proc_id]->nbccalc += mynbccalc;
        privGlobal[Tmk_proc_id]->selfint += myselfint;
        ADDM(privGlobal[Tmk_proc_id]->keten, privGlobal[Tmk_proc_id]-> keten,
		myketen);
        ADDM(privGlobal[Tmk_proc_id]->peten, privGlobal[Tmk_proc_id]-> peten,
		mypeten);
        for (k=0;k<3;k++) privGlobal[Tmk_proc_id]->etot[k] +=  myetot[k];
        ADDV(privGlobal[Tmk_proc_id]->amvec, privGlobal[Tmk_proc_id]-> amvec,
		myamvec);

        MULVS(privGlobal[Tmk_proc_id]->cmphase[0], mycmphase[0], mymtot);
        MULVS(privGlobal[Tmk_proc_id]->cmphase[1], mycmphase[1], mymtot);
        privGlobal[Tmk_proc_id]->mtot = mymtot;

        /* Tmk_lock_release(Global->CountLock); */
    }

#if 0    	/* Postponed to until after Global->Barpos -rrk */
    Tmk_barrier(ALL_PROCS); /* Global->Baraccel); */
    
    if (Tmk_proc_id==0) {
        nttot = Global->n2bcalc + Global->nbccalc;
        nbavg = (int) ((real) Global->n2bcalc / (real) nbody);
        ncavg = (int) ((real) Global->nbccalc / (real) nbody);


        fprintf(outstr,"\n%9s%9s%9s%9s%9s%9s\n", "tnow", "T",
               "U", "nttot", "nbavg", "ncavg");
        fprintf(outstr,"%.9f%.9f%.9f%9d%9d%9d\n",
               tnow, Global->etot[1],
               Global->etot[2], nttot, nbavg, ncavg);


        PRTV("cm pos", Global->cmphase[0]);
        PRTV("cm vel", Global->cmphase[1]);
        PRTV("am vec", Global->amvec);
        fflush(stdout);
	fflush(stderr);
        /*end minor output */
    }
#endif
}



/*
 * DIAGNOSTICS: compute set of dynamical diagnostics.
 */

local void diagnostics()
{
    register bodyptr p,*pp;
    real velsq;
    vector tmpv;
    matrix tmpt;
  
    mymtot = 0.0;                               /* zero total mass          */
    myetot[1] = myetot[2] = 0.0;                /* zero total KE and PE     */
    CLRM(myketen);                              /* zero ke tensor           */
    CLRM(mypeten);                              /* zero pe tensor           */
    CLRV(mycmphase[0]);                         /* zero c. of m. position   */
    CLRV(mycmphase[1]);                         /* zero c. of m. velocity   */
    CLRV(myamvec);                              /* zero am vector           */
    for (pp = mybodytab+mynbody -1; pp >= mybodytab; pp--) { 
        /* loop over my particles   */
        p= *pp;
        mymtot += Mass(p);                      /*   sum particle masses    */
        DOTVP(velsq, Vel(p), Vel(p));           /*   square vel vector      */
        myetot[1] += 0.5 * Mass(p) * velsq;     /*   sum current KE         */
        myetot[2] += 0.5 * Mass(p) * Phi(p);    /*   and current PE         */
        MULVS(tmpv, Vel(p), 0.5 * Mass(p));     /*   sum 0.5 m v_i v_j      */
        OUTVP(tmpt, tmpv, Vel(p));
        ADDM(myketen, myketen, tmpt);
        MULVS(tmpv, Pos(p), Mass(p));           /*   sum m r_i a_j          */
        OUTVP(tmpt, tmpv, Acc(p));
        ADDM(mypeten, mypeten, tmpt);
        MULVS(tmpv, Pos(p), Mass(p));           /*   sum cm position        */
        ADDV(mycmphase[0], mycmphase[0], tmpv);
        MULVS(tmpv, Vel(p), Mass(p));           /*   sum cm momentum        */
        ADDV(mycmphase[1], mycmphase[1], tmpv);
        CROSSVP(tmpv, Pos(p), Vel(p));          /*   sum angular momentum   */
        MULVS(tmpv, tmpv, Mass(p));
        ADDV(myamvec, myamvec, tmpv);
    }
    myetot[0] = myetot[1] + myetot[2];        /* sum KE and PE            */
    if (mymtot!=0){
        DIVVS(mycmphase[0], mycmphase[0], mymtot); /* normalize cm coords      */
        DIVVS(mycmphase[1], mycmphase[1], mymtot);
    }
}



/*
 * Low-level input and output operations.
 */

local void in_int(str, iptr)
  stream str;
  int *iptr;
{
    if (fscanf(str, "%d", iptr) != 1)
        barnes_error("in_int: input conversion barnes_error\n");
}

local void in_real(str, rptr)
  stream str;
  real *rptr;
{
    double tmp;
    
    if (fscanf(str, "%lf", &tmp) != 1)
        barnes_error("in_real: input conversion barnes_error\n");
    *rptr = tmp;
}

local void in_vector(str, vec)
  stream str;
  vector vec;
{
    double tmpx, tmpy, tmpz;
    
#ifdef THREEDIM
    if (fscanf(str, "%lf%lf%lf", &tmpx, &tmpy, &tmpz) != 3)
        barnes_error("in_vector: input conversion barnes_error\n");
    vec[0] = tmpx;    vec[1] = tmpy;    vec[2] = tmpz;
#else
    if (fscanf(str, "%lf%lf", &tmpx, &tmpy) != 2)
        barnes_error("in_vector: input conversion barnes_error\n");
    vec[0] = tmpx;    vec[1] = tmpy;
#endif
}

local void out_int(str, ival)
  stream str;
  int ival;
{
    fprintf(str, "  %d\n", ival);
}

local void out_real(str, rval)
  stream str;
  real rval;
{
    fprintf(str, " %21.14E\n", rval);
}

local void out_vector(str, vec)
  stream str;
  vector vec;
{
    fprintf(str, " %21.14E %21.14E", vec[0], vec[1]);
#ifdef THREEDIM
    fprintf(str, " %21.14E\n",vec[2]);
#else
    fprintf(str, "\n");
#endif
}
@


10.2
log
@Eliminated TMK_DISTRIBUTE.
@
text
@d16 1
a16 1
#include <stdio.h>
@


1.1
log
@Initial revision
@
text
@d56 1
a56 1
      TMK_DISTRIBUTE(bodytab);
@
