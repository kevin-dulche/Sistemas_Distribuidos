head	10.12;
access;
symbols;
locks; strict;
comment	@ * @;


10.12
date	97.12.23.07.53.22;	author alc;	state Exp;
branches;
next	10.11;

10.11
date	97.11.16.07.32.51;	author alc;	state Exp;
branches;
next	10.10;

10.10
date	97.07.18.20.03.34;	author alc;	state Exp;
branches;
next	10.9;

10.9
date	97.07.18.19.49.34;	author alc;	state Exp;
branches;
next	10.8;

10.8
date	97.07.18.19.33.47;	author alc;	state Exp;
branches;
next	10.7;

10.7
date	97.07.18.18.45.39;	author alc;	state Exp;
branches;
next	10.6;

10.6
date	97.07.18.18.15.59;	author alc;	state Exp;
branches;
next	10.5;

10.5
date	97.07.18.08.08.43;	author alc;	state Exp;
branches;
next	10.4;

10.4
date	97.07.18.07.24.48;	author alc;	state Exp;
branches;
next	10.3;

10.3
date	97.07.18.07.05.28;	author alc;	state Exp;
branches;
next	10.2;

10.2
date	97.06.02.08.04.43;	author alc;	state Exp;
branches;
next	1.1;

1.1
date	97.06.02.07.56.34;	author alc;	state Exp;
branches;
next	;


desc
@Gaussian Elimination
@


10.12
log
@Fixed a 64-bit portability error: sizeof(float) should be sizeof(float *).
@
text
@/*
 * $Id: gauss.c,v 10.11 1997/11/16 07:32:51 alc Exp alc $
 */
#include <stdio.h>
#include <sys/time.h>
#include <Tmk.h>

#define SWAP(a,b)       { float tmp; tmp = (a); (a) = (b); (b) = tmp; }
#define ABS(a)		(((a) > 0) ? (a) : -(a))	/* much faster than fabs */


struct GlobalMemory {
    float	**a;
    int		odd_sweep_pivot, even_sweep_pivot;
} *Global;


#define LOWERVAL 0.0
#define UPPERVAL 2.0


int CheckRow(row, rownum, size)
float *row;
int rownum;
int size; {

int     i;
int     errorcount = 0;
 
    for (i = 0; i < rownum; i++)
	if (row[i] != LOWERVAL)
	    errorcount++;
    for (i = rownum; i < size; i++)
	if (row[i] != UPPERVAL)
	    errorcount++;
    return errorcount;
}
 

int CheckArray(a, size)	/* check_array & check_row used to check res */
float **a;
int size; {

int i;
int errorcount = 0;
 
    for (i = 0; i < size; i++)
	errorcount += CheckRow(a[i], i, size);
    return errorcount;
}


void TransposeAndZero(a, size) 
float **a;
int size; {

int     i, j;
 
    for (i = 0; i < size; i++)
        for (j = 0; j < i; j++) {
            SWAP(a[i][j], a[j][i]);
            a[i][j] = 0;
        }
}


void InitArray(a, size)
float **a;
int size; {

int i, j;

#define fILEREAD
#ifdef FILEREAD
    for (i = 0; i < size; i++)
	for (j = 0; j < size; j++)
	    scanf("%f", &a[i][j]);
#else
    for (i = Tmk_proc_id; i < size; i += Tmk_nprocs) {
	for (j = 0; j < i; j++)
	    a[i][j] = j * 2 + 2;
	for (j = i; j < size; j++)
	    a[i][j] = i * 2 + 2;
    }
#endif
}


void PrintArray(a, size)
float **a;
int size; {

int i, j;
FILE *fd;

	fd = fopen("res", "w");
	printf("\n");
	for (i = 0; i < size; i++) {
	    for (j = 0; j < size; j++)
		fprintf(fd, "%f   ", a[i][j]);
	    fprintf(fd, "\n");
	}
	printf("\n");
}


void Compute(a, size, iters)
float **a;
int size;
int iters; {

float	factor;

int	curr_pivot, pivot_col, j, k;
int	starting_row = Tmk_proc_id;

    for (curr_pivot = 0; curr_pivot < iters; curr_pivot++) {

	if (starting_row == curr_pivot) {	/* Find pivot element */
	    float max = ABS(a[curr_pivot][curr_pivot]);
	    pivot_col = curr_pivot;

	    for (j = curr_pivot+1; j < size; j++) {
		float abs_j = ABS(a[curr_pivot][j]);
		if (max < abs_j) {
		    pivot_col = j;
		    max = abs_j;
		}
	    }
		
	    /* Place the pivot element on the diagonal */
	    SWAP(a[curr_pivot][curr_pivot], a[curr_pivot][pivot_col]);
	    if (curr_pivot & 0x01)		/* Odd sweep */
		Global->odd_sweep_pivot = pivot_col;
	    else
		Global->even_sweep_pivot = pivot_col;
	    for (j = curr_pivot+1; j < size; j++)
		a[curr_pivot][j] /= a[curr_pivot][curr_pivot];
		
	    starting_row += Tmk_nprocs;
	}

	Tmk_barrier(0);

	pivot_col = (curr_pivot & 0x01) ? Global->odd_sweep_pivot : 
						Global->even_sweep_pivot;

	for (k = starting_row; k < size; k += Tmk_nprocs) {
	    SWAP(a[k][curr_pivot], a[k][pivot_col]);
	    for (j = curr_pivot + 1; j < size; j++) {
		a[k][j] -= a[k][curr_pivot] * a[curr_pivot][j];
	    }
	}
    }

    Tmk_barrier(0);
}


void main(argc, argv)
int argc;
char **argv; {

int c, i, iters = 0, j, size = 1024;
extern char *optarg;
struct timeval start, finish;

    while ((c = getopt(argc, argv, "i:r:")) != -1) {
	switch (c) {
	  case 'i':
	    iters = atoi(optarg);
	    break;
	  case 'r':
	    size = atoi(optarg);
	    break;
	}
    }

    Tmk_startup(argc, argv);

    printf("Gaussian elimination on %d by %d using %d processors\n",
	size, size, Tmk_nprocs);

    if (iters == 0)
	iters = size - 1;
    else {
	if ((iters < 1) || (iters >= size)) {
	    printf("\tIllegal value, %d, to \"-i\" option.\n",
		   iters);

	    iters = size - 1;
	}
	printf("\tHalting after %d elimination steps.\n",
	       iters);
    }

    if (!Tmk_proc_id) {
	Global = (struct GlobalMemory *) Tmk_malloc(sizeof(struct GlobalMemory));
	Global->a = (float **) Tmk_malloc(size*sizeof(float *));

	for (j = 0; j < Tmk_nprocs; j++) {	/* Wacky init for distinct cachelines*/
	    for (i = j; i < size; i += Tmk_nprocs) {
		Global->a[i] = (float *) Tmk_malloc(size*sizeof(float));
	    }
	}
	Tmk_distribute((char *)&Global, sizeof(Global));
    }
    Tmk_barrier(0);

    InitArray(Global->a, size);

    Tmk_barrier(0);

    gettimeofday(&start, NULL);

    Compute(Global->a, size, iters);

    gettimeofday(&finish, NULL);

    if (!Tmk_proc_id) {
	printf("Elapsed time: %.3f seconds\n\n",
               (((finish.tv_sec * 1000000.0) + finish.tv_usec) -
                ((start.tv_sec * 1000000.0) + start.tv_usec)) / 1000000.0);

	if (iters == size - 1) {
	    TransposeAndZero(Global->a, size);
	    if ((i = CheckArray(Global->a, size)) != 0)
		printf("ERRORs IN RESULT! %d errors found\n", i);
	}
	else
	    printf("\tSkipping verification step.\n");
    }
    Tmk_exit(0);
}
@


10.11
log
@Change the variable "c"'s type in main to "int" from "char".  "char"
is unsigned on the SGIs and "c" is used to hold the return value
from "getopt".
@
text
@d2 1
a2 1
 * $Id: gauss.c,v 10.10 1997/07/18 20:03:34 alc Exp alc $
d199 1
a199 1
	Global->a = (float **) Tmk_malloc(size*sizeof(float));
@


10.10
log
@Distribute the initialization across the processors.
@
text
@d2 1
a2 1
 * $Id: gauss.c,v 10.9 1997/07/18 19:49:34 alc Exp alc $
d164 1
a164 2
int i, iters = 0, j, size = 1024;
char c;
@


10.9
log
@Eliminated some inconsistent spacing.  Added some parentheses
within the macros.
@
text
@d2 1
a2 1
 * $Id: gauss.c,v 10.8 1997/07/18 19:33:47 alc Exp alc $
d79 1
a79 1
    for (i = 0; i < size; i++) {
a206 2
	InitArray(Global->a, size);

d209 4
@


10.8
log
@Eliminated some inconsistent spacing.
@
text
@d2 1
a2 1
 * $Id: gauss.c,v 10.7 1997/07/18 18:45:39 alc Exp alc $
d8 2
a9 2
#define SWAP(a,b)       { float tmp; tmp = a; a = b; b = tmp; }
#define ABS(a)		((a > 0) ? a : -a)	/* much faster than fabs */
d61 1
a61 1
            SWAP (a[i][j],a[j][i]);
@


10.7
log
@Pass the array size and iteration count through arguments, instead
of shared memory.  Use a single variable and procedure naming convention
throughout.
@
text
@d2 1
a2 1
 * $Id: gauss.c,v 10.6 1997/07/18 18:15:59 alc Exp alc $
d77 1
a77 1
	    scanf ("%f", &a[i][j]);
d96 2
a97 2
	fd = fopen ("res", "w");
	printf ("\n");
d100 2
a101 2
		fprintf (fd, "%f   ", a[i][j]);
	    fprintf (fd, "\n");
d103 1
a103 1
	printf ("\n");
d120 1
a120 1
	    float max = ABS (a[curr_pivot][curr_pivot]);
d124 1
a124 1
		float abs_j = ABS (a[curr_pivot][j]);
d132 1
a132 1
	    SWAP (a[curr_pivot][curr_pivot], a[curr_pivot][pivot_col]);
d149 1
a149 1
	    SWAP (a[k][curr_pivot], a[k][pivot_col]);
@


10.6
log
@Eliminate the pointless "register" declarations.
@
text
@d2 1
a2 1
 * $Id: gauss.c,v 10.5 1997/07/18 08:08:43 alc Exp alc $
a3 1
#include <Tmk.h>
d6 1
d12 1
a12 1
struct	GlobalMemory {
a13 1
    int		a_size;
a14 1
    int		iters;
d22 4
a25 1
int     check_row(float *row, int rownum, int size) {
d32 1
a32 1
		    errorcount++;
d40 3
a42 3
int     check_array(a, size)	/* check_array & check_row used to check res */
float *a[];
int     size; {
d44 1
a45 1
int i;
d47 2
a48 1
    for (i = 0; i < size; i++) errorcount += check_row( a[i], i, size);
d53 1
a53 1
TransposeAndZero (a, size) 
d67 3
a69 3
void InitArray (a, size)
int   size;
float **a; {
d88 4
a91 3
void	PrintArray (a, size)
float	**a;
int	size; {
d107 4
a110 1
void Compute () {
d112 1
a112 3
float	**a = Global->a, factor;
int	a_size = Global->a_size;
int	iters = Global->iters;
d123 1
a123 1
	    for (j = curr_pivot+1; j < a_size; j++) {
d137 1
a137 1
	    for (j = curr_pivot+1; j < a_size; j++)
a144 1

d148 1
a148 1
	for (k = starting_row; k < a_size; k += Tmk_nprocs) {
d150 1
a150 1
	    for (j = curr_pivot + 1; j < a_size; j++) {
d160 8
a167 8
void main (argc, argv)
int	argc;
char	**argv; 
{
    int		i, iters = 0, j, size = 1024;
    char	c;
    extern char	*optarg;
    struct timeval start, finish;
d200 1
a200 3
	Global->a_size = size;
	Global->a = (float **) Tmk_malloc(Global->a_size*sizeof(float));
	Global->iters = iters;
d203 2
a204 2
	    for (i = j; i < Global->a_size; i += Tmk_nprocs) {
		Global->a[i] = (float *) Tmk_malloc(Global->a_size*sizeof(float));
d207 1
a207 1
	InitArray (Global->a, Global->a_size);
d215 1
a215 1
    Compute();
d225 2
a226 2
	    TransposeAndZero (Global->a, Global->a_size);
	    if ((i = check_array(Global->a, Global->a_size)) != 0)
@


10.5
log
@Added the option, "-i", to terminate after some specified number
of elimination steps.
@
text
@d2 1
a2 1
 * $Id: gauss.c,v 10.4 1997/07/18 07:24:48 alc Exp alc $
d8 1
a8 1
#define SWAP(a,b)       {register float tmp; tmp = a; a = b; b = tmp;}
d116 1
a116 1
	    register float max = ABS (a[curr_pivot][curr_pivot]);
d120 1
a120 1
		register float abs_j = ABS (a[curr_pivot][j]);
@


10.4
log
@Added $Id.
@
text
@d2 1
a2 1
 * $Id$
d16 1
d108 1
d113 1
a113 1
    for (curr_pivot = 0; curr_pivot < a_size - 1; curr_pivot++) {
d161 1
a161 1
    int		i, j, size = 1024;
d166 1
a166 1
    while ((c = getopt(argc, argv, "r:")) != -1) {
d168 3
d176 1
d182 13
d199 2
a200 1
	
d222 8
a229 4
	
	TransposeAndZero (Global->a, Global->a_size);
	if ((i = check_array(Global->a, Global->a_size)) != 0)
	    printf("ERRORs IN RESULT! %d errors found\n", i);
@


10.3
log
@Three minor changes: defines the timevals in main rather than globally,
indent the error printf, and eliminated an unnecessary barrier before
terminating.
@
text
@d1 3
@


10.2
log
@Eliminated TMK_DISTRIBUTE.
@
text
@a14 2
struct  timeval start, finish;

d159 2
a160 1
    
d202 1
a202 1
        printf("ERRORs IN RESULT! %d errors found\n", i);
a203 2
    Tmk_barrier(0);

@


1.1
log
@Initial revision
@
text
@d186 1
a186 4
	TMK_DISTRIBUTE(Global);
    }
    else {
	freopen("/tmp/err.log", "w", stderr); setbuf(stderr, NULL);
@
