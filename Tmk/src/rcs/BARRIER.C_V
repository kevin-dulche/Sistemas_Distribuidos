head	11.2;
access;
symbols
	Tmk-1_0_3_2R:10.6.1.10
	Tmk-1_0_3_1R:10.6.1.10
	Tmk-1_0_3R:10.6.1.9
	Tmk-1_0_TO-1_2_BRANCH_POINT:10.6.1.9
	Tmk-1_0_1R:10.6.1.3
	Tmk-1_1:11
	Tmk-1_0:10.6.1
	Tmk-1_0_TO-1_1_BRANCH_POINT:10.6
	Tmk-0_10_1_2R:10.1.3.1
	Tmk-0_10_1_1R:10.1.3.1
	Tmk-0_10_1R:10.1;
locks; strict;
comment	@ * @;


11.2
date	97.07.24.19.06.14;	author alc;	state Exp;
branches;
next	11.1;

11.1
date	97.05.27.02.25.29;	author alc;	state Exp;
branches;
next	10.6;

10.6
date	96.10.03.06.30.48;	author alc;	state Exp;
branches
	10.6.1.1;
next	10.5;

10.5
date	96.09.24.22.01.11;	author alc;	state Exp;
branches;
next	10.4;

10.4
date	96.08.24.21.10.49;	author alc;	state Exp;
branches;
next	10.3;

10.3
date	96.08.24.20.01.11;	author alc;	state Exp;
branches;
next	10.2;

10.2
date	96.08.24.18.03.17;	author alc;	state Exp;
branches;
next	10.1;

10.1
date	96.05.27.04.48.40;	author alc;	state Rel;
branches
	10.1.2.1
	10.1.3.1
	10.1.4.1
	10.1.5.1;
next	10.0;

10.0
date	96.03.15.09.47.40;	author alc;	state Rel;
branches
	10.0.1.1
	10.0.2.1
	10.0.3.1;
next	9.7;

9.7
date	96.03.15.09.39.04;	author alc;	state Rel;
branches
	9.7.2.1
	9.7.6.1;
next	9.6;

9.6
date	96.03.15.09.30.03;	author alc;	state Rel;
branches
	9.6.1.1;
next	9.5;

9.5
date	96.03.15.09.24.56;	author alc;	state Rel;
branches
	9.5.1.1;
next	9.4;

9.4
date	96.03.15.09.20.45;	author alc;	state Rel;
branches;
next	;

9.5.1.1
date	96.03.15.09.27.09;	author alc;	state Rel;
branches;
next	;

9.6.1.1
date	96.03.15.09.32.19;	author alc;	state Rel;
branches;
next	;

9.7.2.1
date	96.03.17.18.00.32;	author alc;	state Exp;
branches;
next	;

9.7.6.1
date	96.07.23.18.42.25;	author zhenghua;	state Exp;
branches;
next	;

10.0.1.1
date	96.03.15.09.51.03;	author alc;	state Rel;
branches;
next	;

10.0.2.1
date	96.03.17.18.12.04;	author alc;	state Exp;
branches
	10.0.2.1.2.1;
next	;

10.0.2.1.2.1
date	96.03.25.21.00.30;	author alc;	state Exp;
branches;
next	10.0.2.1.2.2;

10.0.2.1.2.2
date	96.03.30.21.17.57;	author alc;	state Exp;
branches;
next	10.0.2.1.2.3;

10.0.2.1.2.3
date	96.04.28.17.37.42;	author alc;	state Exp;
branches;
next	10.0.2.1.2.4;

10.0.2.1.2.4
date	96.05.29.21.54.09;	author alc;	state Exp;
branches;
next	;

10.0.3.1
date	96.04.22.16.59.08;	author alc;	state Exp;
branches;
next	;

10.1.2.1
date	96.06.25.19.28.51;	author tmiller;	state Exp;
branches;
next	;

10.1.3.1
date	96.11.14.06.25.07;	author alc;	state Rel;
branches;
next	;

10.1.4.1
date	96.07.29.21.09.00;	author rjf;	state Exp;
branches;
next	10.1.4.2;

10.1.4.2
date	96.07.30.20.52.50;	author rjf;	state Exp;
branches;
next	;

10.1.5.1
date	96.06.27.16.38.16;	author tmiller;	state Exp;
branches;
next	10.1.5.2;

10.1.5.2
date	96.06.27.23.05.15;	author tmiller;	state Exp;
branches;
next	10.1.5.3;

10.1.5.3
date	96.06.28.18.27.47;	author tmiller;	state Exp;
branches;
next	10.1.5.4;

10.1.5.4
date	96.06.28.20.24.01;	author tmiller;	state Exp;
branches;
next	10.1.5.5;

10.1.5.5
date	96.07.02.22.34.57;	author tmiller;	state Exp;
branches;
next	10.1.5.6;

10.1.5.6
date	96.07.03.19.32.35;	author tmiller;	state Exp;
branches;
next	10.1.5.7;

10.1.5.7
date	96.08.07.17.26.04;	author tmiller;	state Exp;
branches;
next	;

10.6.1.1
date	97.07.03.20.29.28;	author alc;	state Exp;
branches;
next	10.6.1.2;

10.6.1.2
date	97.07.23.06.39.32;	author alc;	state Exp;
branches;
next	10.6.1.3;

10.6.1.3
date	98.01.07.07.27.29;	author alc;	state Exp;
branches;
next	10.6.1.4;

10.6.1.4
date	98.05.14.20.10.16;	author alc;	state Exp;
branches;
next	10.6.1.5;

10.6.1.5
date	98.05.31.20.03.52;	author alc;	state Exp;
branches;
next	10.6.1.6;

10.6.1.6
date	98.06.11.22.22.55;	author alc;	state Exp;
branches;
next	10.6.1.7;

10.6.1.7
date	98.06.13.18.39.11;	author alc;	state Exp;
branches;
next	10.6.1.8;

10.6.1.8
date	98.06.14.06.27.56;	author alc;	state Exp;
branches;
next	10.6.1.9;

10.6.1.9
date	98.06.16.04.59.14;	author alc;	state Exp;
branches;
next	10.6.1.10;

10.6.1.10
date	98.08.17.16.31.41;	author alc;	state Exp;
branches;
next	;


desc
@@


11.2
log
@Eliminated the Ultrix-specific code.  (Identical to revision 10.6.1.1.)
@
text
@/*****************************************************************************
 *                                                                           *
 *  Copyright (c) 1991-1996						     *
 *  by ParallelTools, L.L.C. (PTOOLS), Houston, Texas			     *
 *                                                                           *
 *  This software is furnished under a license and may be used and copied    *
 *  only in accordance with the terms of such license and with the	     *
 *  inclusion of the above copyright notice.  This software or any other     *
 *  copies thereof may not be provided or otherwise made available to any    *
 *  other person.  No title to or ownership of the software is hereby	     *
 *  transferred.                                                             *
 *									     *
 *  The recipient of this software (RECIPIENT) acknowledges and agrees that  *
 *  the software contains information and trade secrets that are	     *
 *  confidential and proprietary to PTOOLS.  RECIPIENT agrees to take all    *
 *  reasonable steps to safeguard the software, and to prevent its	     *
 *  disclosure.								     * 
 *                                                                           *
 *  The information in this software is subject to change without notice     *
 *  and should not be construed as a commitment by PTOOLS.		     *
 *                                                                           *
 *  This software is furnished AS IS, without warranty of any kind, either   *
 *  express or implied (including, but not limited to, any implied warranty  *
 *  of merchantability or fitness), with regard to the software.  PTOOLS     *
 *  assumes no responsibility for the use or reliability of its software.    *
 *  PTOOLS shall not be liable for any special,	incidental, or		     *
 *  consequential damages, or any damages whatsoever due to causes beyond    *
 *  the reasonable control of PTOOLS, loss of use, data or profits, or from  *
 *  loss or destruction of materials provided to PTOOLS by RECIPIENT.	     *
 *									     *
 *  PTOOLS's liability for damages arising out of or in connection with the  *
 *  use or performance of this software, whether in an action of contract    *
 *  or tort including negligence, shall be limited to the purchase price,    *
 *  or the total amount paid by RECIPIENT, whichever is less.		     *
 *                                                                           *
 *****************************************************************************/

/*
 * $Id: barrier.c,v 11.1 1997/05/27 02:25:29 alc Exp alc $
 *
 * Description:    
 *	barrier synchronization routines
 *
 * External Functions:
 *			Tmk_barrier,
 *			Tmk_barrier_initialize
 *
 * External Variables:
 *			Tmk_barrier_sigio_handler
 *
 * Facility:	TreadMarks Distributed Shared Memory System
 * History:
 *	15-Apr-1993	Alan L. Cox	Created
 *	26-Jul-1993	Alan L. Cox	Added reliable message protocol
 *	26-Oct-1993	Alan L. Cox	Update inverse time in barrier
 *	 7-Jan-1994	Alan L. Cox	Shrink data structures
 *
 *	Version 0.9.0
 *
 *	Version 0.9.1
 *
 *	14-Jan-1995	Alan L. Cox	Adapted for STREAMS
 *
 *	Version	0.9.2
 *
 *	21-May-1995	Alan L. Cox	Adapted for SGI/IRIX
 *
 *	Version 0.9.3
 *
 *	17-Jul-1995	Alan L. Cox	Eliminated the message size parameter
 *					 to the barrier duplicate handler
 *	22-Jul-1995	Alan L. Cox	#ifdef'ed the Ultrix/ATM specific code
 *
 *	Version 0.9.4
 *
 *	16-Nov-1995	Alan L. Cox	Modified the barrier to merge (and
 *					  delay) the mprotects
 *	Version 0.9.6
 *
 *	27-Jan-1996	Alan L. Cox	Replaced sigblock and sigsetmask
 *					 with sigprocmask
 *	Version 0.10
 */
#include "Tmk.h"

static	struct	barrier	{
	unsigned char		manager;
	unsigned volatile	mask;
}			barrier_[NBARRIERS];

static	struct	arrival	{
	struct	req_syn	       *req;
	unsigned		size;
}			arrival_[NPROCS];

static	struct	req_typ	req_typ = { /*seqno=*/0, /*from=*/0, /*type=*/REQ_ARRIVAL };

static	char		req_data[MTU - sizeof(req_typ) - sizeof(proc_vector_time_)];

static	struct	iovec	req_iov[3] = {
	{ (caddr_t)&req_typ, sizeof(req_typ) },
	{ (caddr_t) proc_vector_time_, sizeof(proc_vector_time_) },
	{ req_data, 0 } };
static	struct	msghdr	req_hdr = { 0, 0, req_iov, sizeof(req_iov)/sizeof(req_iov[0]), 0, 0 };

static	struct	rep_typ	{
	unsigned	seqno;
	unsigned short	repo;
	char		data[MTU - sizeof(unsigned) - sizeof(unsigned short)];
}			rep_msg;

static	void	default_handler(req, size)
	struct req_syn *req;
	int		size;
{
	int		pid = req->from;

	struct arrival *arrival = &arrival_[pid];

	barrier_[req->id].mask |= 1 << pid;

	arrival->req = req;
	arrival->size = size;
}

static	void	special_handler(req, size)
	struct req_syn *req;
	int		size;
{
	int		pid = req->from;

	struct arrival *arrival = &arrival_[pid];

	barrier_[req->id].mask |= 1 << pid;

	arrival->req = req;

	if (req->type == REQ_ARRIVAL_REPO)
		rep_msg.repo = 1;

	Tmk_interval_incorporate((caddr_t)&req->vector_time[NPROCS], size - sizeof(struct req_syn), 0);
}

void  (*Tmk_barrier_sigio_handler)() = default_handler;

void	Tmk_barrier_sigio_duplicate_handler(req)
	struct req_syn *req;
{
	int		pid = req->from;
	struct barrier *barrier = &barrier_[req->id];

	if ((barrier->mask & (1 << pid)) == 0) {

		int	size = Tmk_interval_request(rep_msg.data, req->vector_time) - (caddr_t)&rep_msg;

		rep_msg.seqno = req->seqno;
	/*	rep_msg.repo = ? */

		if (0 > send(rep_fd_[pid], (char *)&rep_msg, size, 0))
			Tmk_perrexit("<send>Tmk_barrier_sigio_duplicate_handler");

		if (Tmk_debug)
			Tmk_err("<repeated seqno: %d>Tmk_barrier_sigio_duplicate_handler: seqno == %d\n", pid, req->seqno);
	}
}

/*
 *
 */
void	Tmk_barrier(id)
	unsigned	id;
{
	Tmk_stat.arrivals++;

	if (Tmk_debug)
		Tmk_err("barrier: %d ", id);

	if (id < NBARRIERS) {

		struct barrier *barrier = &barrier_[id];
		sigset_t	mask;
		int		j, manager, size, t;

		sigio_mutex(SIG_BLOCK, &ALRM_and_IO_mask, &mask);

		Tmk_interval_create(proc_vector_time_);

		if ((t = Tmk_diff_repo_test()) == 0)
			t = Tmk_interval_repo_test();

		if ((manager = barrier->manager) == Tmk_proc_id) {

			struct req_syn *req;

			Tmk_barrier_sigio_handler = special_handler;

			rep_msg.repo = t;

			for (j = 0; j < Tmk_nprocs; j++) {
				if (j == Tmk_proc_id)
					continue;

				if ((1 << j) & barrier->mask) {

					struct arrival *arrival = &arrival_[j];

					if ((req = arrival->req)->type == REQ_ARRIVAL_REPO)
						rep_msg.repo = 1;

					Tmk_interval_incorporate((caddr_t)&req->vector_time[NPROCS], arrival->size - sizeof(struct req_syn), 0);
				}
			}
			while (barrier->mask ^ Tmk_spinmask)
				sigio_handler();

			barrier->mask = 0;

			for (j = 0; j < Tmk_nprocs; j++) {
				if (j == Tmk_proc_id)
					continue;

				rep_msg.seqno = (req = arrival_[j].req)->seqno;

				size = Tmk_interval_request(rep_msg.data, req->vector_time) - (caddr_t)&rep_msg;

				if (0 > send(rep_fd_[j], (char *)&rep_msg, size, 0))
					Tmk_perrexit("<send>Tmk_barrier (proc: %d)", j);
			}
			/*
			 * Perform the merged mprotects.
			 */
			Tmk_page_inval_perform();

			Tmk_barrier_sigio_handler = default_handler;

			sigio_buffer_initialize();
		}
		else {
			req_typ.type = t ? REQ_ARRIVAL_REPO : REQ_ARRIVAL;
			req_typ.id = id;

			req_iov[2].iov_len = Tmk_interval_request_proc(req_data, Tmk_proc_id, MAX(inverse_time_[manager], proc_array_[manager].prev->vector_time_[Tmk_proc_id])) - req_data;

			req_typ.seqno = req_seqno += SEQNO_INCR;
	       rexmit:
			if (0 > sendmsg(req_fd_[manager], &req_hdr, 0))
				Tmk_perrexit("<sendmsg>Tmk_barrier");

			Tmk_tout_flag = 0;

			setitimer(ITIMER_REAL, &Tmk_tout, NULL);

			sigio_mutex(SIG_UNBLOCK, &ALRM_and_IO_mask, NULL);
		retry:
			if ((size = recv(req_fd_[manager], (char *)&rep_msg, sizeof(rep_msg), 0)) < 0)
				if (Tmk_tout_flag) {

					if (Tmk_debug)
						Tmk_err("<timeout: %d>Tmk_barrier: seqno == %d\n", manager, req_typ.seqno);

					sigio_mutex(SIG_BLOCK, &ALRM_and_IO_mask, NULL);

					goto rexmit;
				}
				else if (errno == EINTR)
					goto retry;
				else
					Tmk_perrexit("<recv>Tmk_barrier");

			if (rep_msg.seqno != req_typ.seqno) {

				if (Tmk_debug)
					Tmk_err("<bad seqno: %d>Tmk_barrier: seqno == %d (received: %d)\n", manager, req_typ.seqno, rep_msg.seqno);

				goto retry;
			}
			sigio_mutex(SIG_BLOCK, &ALRM_and_IO_mask, NULL);

			Tmk_stat.messages++;
			Tmk_stat.bytes += size;

			Tmk_interval_incorporate(rep_msg.data, size - sizeof(rep_msg.seqno) - sizeof(rep_msg.repo), proc_vector_time_);
		}
		for (j = 0; j < Tmk_nprocs; j++) {
			if (j == Tmk_proc_id)
				continue;

			inverse_time_[j] = proc_vector_time_[Tmk_proc_id];
		}
		if (rep_msg.repo)
			Tmk_repo();

		sigio_mutex(SIG_SETMASK, &mask, NULL);
	}
	else
		Tmk_errexit("Tmk_barrier: id == %d\n", id);
}

/*
 *
 */
int	Tmk_barrier_allocate(ip)
	unsigned       *ip;
{
	*ip = 0;

	return -1;
}

void	Tmk_barrier_initialize( void )
{
	int	i;

	for (i = 0; i < NBARRIERS; i++)
		barrier_[i].manager = i % Tmk_nprocs;

	req_typ.from = Tmk_proc_id;
}
@


11.1
log
@Replaced static spinmask by extern Tmk_spinmask.  (Required
by Tmk_spawn.)
@
text
@d39 1
a39 1
 * $Id: barrier.c,v 10.6 1996/10/03 06:30:48 alc Exp alc $
a103 1
#if ! defined(ultrix)
a104 1
#endif
d158 1
a158 10
#if defined(ultrix)
		/*
		 * The ATM driver doesn't check the message size.
		 */
		if (size > tmk_MTU)
			Tmk_errexit("<size == %d>Tmk_barrier_sigio_duplicate_handler\n", size);

		if (0 > write(rep_fd_[pid], &rep_msg, size))
			Tmk_perrexit("<write>Tmk_barrier_sigio_duplicate_handler");
#else
d161 1
a161 1
#endif
d225 1
a225 10
#if defined(ultrix)
				/*
				 * The ATM driver doesn't check the message size.
				 */
				if (size > tmk_MTU)
					Tmk_errexit("<size == %d>Tmk_barrier (proc: %d)\n", size, j);

				if (0 > write(rep_fd_[j], &rep_msg, size))
					Tmk_perrexit("<write>Tmk_barrier (proc: %d)", j);
#else
a227 1
#endif
d243 1
a243 7
#if defined(ultrix)
			/*
			 * The ATM driver doesn't check the message size.
			 */
			if (req_iov[2].iov_len + sizeof(struct req_syn) > tmk_MTU)
				Tmk_errexit("<size == %d>Tmk_barrier\n", req_iov[2].iov_len);
#endif
a245 4
#if defined(ultrix)
			if (0 > writev(req_fd_[manager], req_iov, sizeof(req_iov)/sizeof(req_iov[0])))
				Tmk_perrexit("<writev>Tmk_barrier");
#else
d248 1
a248 1
#endif
a254 3
#if defined(ultrix)
			if ((size = read(req_fd_[manager], &rep_msg, sizeof(rep_msg))) < 0)
#else
a255 1
#endif
a267 3
#if defined(ultrix)
					Tmk_perrexit("<read>Tmk_barrier");
#else
d269 1
a269 1
#endif
@


10.6
log
@Deleted the MPL specific code.
@
text
@d39 1
a39 1
 * $Id: barrier.c,v 10.5 1996/09/24 22:01:11 alc Exp $
a113 2
static	unsigned	spinmask;

d224 1
a224 1
			while (spinmask ^ barrier->mask)
a353 2

	spinmask = ((1 << Tmk_nprocs) - 1) &~ (1 << Tmk_proc_id);
@


10.6.1.1
log
@Eliminated the Ultrix-specific code.
@
text
@d39 1
a39 1
 * $Id: barrier.c,v 10.6 1996/10/03 06:30:48 alc Exp alc $
d104 1
d106 1
d162 10
a171 1

d174 1
a174 1

d238 10
a247 1

d250 1
d266 7
a272 1

d275 4
d281 1
a281 1

d288 3
d292 1
d305 3
d309 1
a309 1

@


10.6.1.2
log
@Added basic Pthreads support.
@
text
@a103 1

a174 3
#if defined(PTHREADS)
	pthread_mutex_lock(&Tmk_monitor_lock);
#endif
d245 1
a298 3
#if defined(PTHREADS)
	pthread_mutex_unlock(&Tmk_monitor_lock);
#endif
@


10.6.1.3
log
@Use a single GLOBAL spinmask instead of multiple static spinmasks.
@
text
@d39 1
a39 1
 * $Id: barrier.c,v 10.6.1.2 1997/07/23 06:39:32 alc Exp alc $
d113 2
d219 1
a219 1
			while (barrier->mask ^ Tmk_spinmask)
d324 2
@


10.6.1.4
log
@Add Tmk_errno_check, replacing Tmk_perrexit after send and sendmsg.  It
handles the ENOBUF returned by BSD/OS and FreeBSD.
@
text
@d39 1
a39 1
 * $Id: barrier.c,v 10.6.1.3 1998/01/07 07:27:29 alc Exp alc $
d160 2
a161 2
		while (0 > send(rep_fd_[pid], (char *)&rep_msg, size, 0))
			Tmk_errno_check("Tmk_barrier_sigio_duplicate_handler<send>");
d230 2
a231 2
				while (0 > send(rep_fd_[j], (char *)&rep_msg, size, 0))
					Tmk_errno_check("Tmk_barrier<send>");
d249 2
a250 2
			while (0 > sendmsg(req_fd_[manager], &req_hdr, 0))
				Tmk_errno_check("Tmk_barrier<sendmsg>");
@


10.6.1.5
log
@Added the "const" attribute to the req argument
to Tmk_barrier_sigio_duplicate_handler.
@
text
@d39 1
a39 1
 * $Id: barrier.c,v 10.6.1.4 1998/05/14 20:10:16 alc Exp alc $
d147 2
a148 6
/*
 *
 */
void
Tmk_barrier_sigio_duplicate_handler(
	const struct req_syn *req)
@


10.6.1.6
log
@Use the global req_from_[] instead of the (now defunct) private arrival_[].
req_from_[] is updated by the sigio handler instead of the individual
barrier and sched sigio handlers.
@
text
@d39 1
a39 1
 * $Id: barrier.c,v 10.6.1.5 1998/05/31 20:03:52 alc Exp alc $
d91 5
d119 2
d122 3
d133 2
d137 2
d213 1
a213 1
					req_entry_t    *arrival = &req_from_[j];
d230 1
a230 1
				rep_msg.seqno = (req = req_from_[j].req)->seqno;
@


10.6.1.7
log
@Made changes to barrier and sched to facilitate integration
of the FASTLINK barriers:

1. Use a single sigio handler for barriers and scheds (regardless
of whether the manager has arrived or not).

2. Use barrier->mask and sched->mask to determine whether or not
the manager has arrived/joined.

3. Redefine Tmk_spinmask to include the "host" processor.
@
text
@d39 1
a39 1
 * $Id: barrier.c,v 10.6.1.6 1998/06/11 22:22:55 alc Exp alc $
d108 25
d189 2
a206 2
			barrier->mask |= 1 << Tmk_proc_id;

d228 2
a303 17
}

/*
 *
 */
void
Tmk_barrier_sigio_handler(
	const struct req_syn *req,
	int		size)
{
	if ((barrier_[req->id].mask |= (1 << req->from)) & (1 << Tmk_proc_id)) {

		if (req->type == REQ_ARRIVAL_REPO)
			rep_msg.repo = 1;

		Tmk_interval_incorporate((caddr_t)&req->vector_time[NPROCS], size - sizeof(struct req_syn), NULL);
	}
@


10.6.1.8
log
@Quite a number of minor (harmless) changes.
@
text
@d39 1
a39 1
 * $Id: barrier.c,v 10.6.1.7 1998/06/13 18:39:11 alc Exp alc $
d106 1
a106 1
}			rep;
d112 26
a137 2
Tmk_barrier(
	unsigned	id)
d151 1
a151 1
		int		j, manager, repo, size;
d157 2
a158 2
		if ((repo = Tmk_diff_repo_test()) == 0)
			repo = Tmk_interval_repo_test();
d164 1
a164 1
			rep.repo = repo;
d172 1
a172 1
					req = req_from_[j].req;
d174 2
a175 3
					Tmk_interval_incorporate((caddr_t)&req->vector_time[NPROCS],
								 req_from_[j].size - sizeof(struct req_syn),
								 NULL);
d177 1
a177 2
					if (req->type == REQ_ARRIVAL_REPO)
						rep.repo = 1;
d191 1
a191 3
				req = req_from_[j].req;

				rep.seqno = req->seqno;
d193 1
a193 1
				size = Tmk_interval_request(rep.data, req->vector_time) - (caddr_t)&rep;
d195 1
a195 1
				while (0 > send(rep_fd_[j], (char *)&rep, size, 0))
d206 1
a206 3
			unsigned	time;

			req_typ.type = repo ? REQ_ARRIVAL_REPO : REQ_ARRIVAL;
d209 1
a209 4
			time = MAX(inverse_time_[manager], proc_array_[manager].prev->vector_time_[Tmk_proc_id]);

			req_iov[2].iov_len = Tmk_interval_request_proc(req_data, Tmk_proc_id, time) - req_data;

d221 1
a221 1
			if ((size = recv(req_fd_[manager], (char *)&rep, sizeof(rep), 0)) < 0)
d225 1
a225 2
						Tmk_err("Tmk_barrier: %d timed out (seqno %d)\n",
							manager, req_typ.seqno);
d234 1
a234 1
					Tmk_perrexit("Tmk_barrier<recv>");
d236 1
a236 1
			if (rep.seqno != req_typ.seqno) {
d239 1
a239 2
					Tmk_err("Tmk_barrier: bad seqno %d from %d (received %d)\n",
						req_typ.seqno, manager, rep.seqno);
d248 1
a248 1
			Tmk_interval_incorporate(rep.data, size - sizeof(rep.seqno) - sizeof(rep.repo), proc_vector_time_);
d256 1
a256 1
		if (rep.repo)
d271 2
a272 4
void
Tmk_barrier_sigio_handler(
	const struct req_syn *req,
	int		size)
d274 1
a274 1
	if ((barrier_[req->id].mask |= (1 << req->from)) & (1 << Tmk_proc_id)) {
d276 1
a276 5
		Tmk_interval_incorporate((caddr_t)&req->vector_time[NPROCS], size - sizeof(struct req_syn), NULL);

		if (req->type == REQ_ARRIVAL_REPO)
			rep.repo = 1;
	}
d283 1
a283 1
Tmk_barrier_sigio_duplicate_handler(
d287 1
a287 1
	int		from = req->from;
d289 2
a290 1
	if ((barrier_[req->id].mask & (1 << from)) == 0) {
d292 1
a292 11
		int	size = Tmk_interval_request(rep.data, req->vector_time) - (caddr_t)&rep;

		rep.seqno = req->seqno;
	/*	rep.repo = ? */

		while (0 > send(rep_fd_[from], (char *)&rep, size, 0))
			Tmk_errno_check("Tmk_barrier_sigio_duplicate_handler<send>");

		if (Tmk_debug)
			Tmk_err("Tmk_barrier_sigio_duplicate_handler: repeated seqno %d from %d\n",
				req->seqno, from);
d296 1
a296 5
/*
 *
 */
void
Tmk_barrier_initialize( void )
@


10.6.1.9
log
@Switch to Tmk_sigio_buffer_release for buffer management.  (Stop
using sigio_buffer_initialize.)
@
text
@d39 1
a39 1
 * $Id: barrier.c,v 10.6.1.8 1998/06/14 06:27:56 alc Exp alc $
a174 2
				Tmk_sigio_buffer_release(req);

d182 2
@


10.6.1.10
log
@Use "inverse_time_" exclusively to determine the consistency data
that is sent to the manager.  It always contains the correct value.
The MAX was pointless.
@
text
@d39 1
a39 1
 * $Id: barrier.c,v 10.6.1.9 1998/06/16 04:59:14 alc Exp alc $
d186 2
d191 3
a193 1
			req_iov[2].iov_len = Tmk_interval_request_proc(req_data, Tmk_proc_id, inverse_time_[manager]) - req_data;
@


10.5
log
@Added MPL support, in particular, a modified buffering scheme
for requests.
@
text
@d39 1
a39 1
 * $Id: barrier.c,v 10.4 1996/08/24 21:10:49 alc Exp alc $
a250 3
#if defined(MPL) 
				sigio_buffer_free(req);
#endif
d258 1
a258 3
#if defined(MPL)
			tmk_rnc_initialize(); 
#else
a259 1
#endif
@


10.4
log
@Replaced sigprocmask by sigio_mutex.  Sigio_mutex is defined
in Tmk.h.
@
text
@d39 1
a39 1
 * $Id: barrier.c,v 10.3 1996/08/24 20:01:11 alc Exp alc $
d251 3
d261 3
a263 1

d265 1
@


10.3
log
@Replaced "seqno += NPROCS" by "+= SEQNO_INCR".
@
text
@d39 1
a39 1
 * $Id$
d197 1
a197 1
		sigprocmask(SIG_BLOCK, &ALRM_and_IO_mask, &mask);
d286 1
a286 1
			sigprocmask(SIG_UNBLOCK, &ALRM_and_IO_mask, NULL);
d298 1
a298 1
					sigprocmask(SIG_BLOCK, &ALRM_and_IO_mask, NULL);
d317 1
a317 1
			sigprocmask(SIG_BLOCK, &ALRM_and_IO_mask, NULL);
d333 1
a333 1
		sigprocmask(SIG_SETMASK, &mask, NULL);
@


10.2
log
@Use SIG_UNBLOCK before recv rather than SIG_SETMASK.
@
text
@d37 4
a40 2
/*****************************************************************************
 * File:		barrier.c
d83 1
a83 2
 *
 *****************************************************************************/
d273 1
a273 1
			req_typ.seqno = req_seqno += NPROCS;
@


10.1
log
@Tmk-0.10.1R
@
text
@d285 1
a285 1
			sigprocmask(SIG_SETMASK, &mask, NULL);
@


10.1.3.1
log
@Tmk-0.10.1.1R: IRIX 6.2 support.
@
text
@@


10.1.4.1
log
@MPL Support
@
text
@d80 2
a81 2
 *	Version 0.10.1
 *	29-July-1996	Rob Fowler	IBM MPL support
a184 3
#if defined(THREADS)
	pthread_mutex_lock(&monitor_lock);
#endif
d196 1
a196 1
		sigio_mutex(SIG_BLOCK, &IO_mask, &mask, LOCK);
a224 3

			sigio_mutex(SIG_UNBLOCK, &IO_mask, NULL, UNLOCK);

d226 1
a226 1
				;
a229 2
			sigio_mutex(SIG_BLOCK, &IO_mask, NULL, LOCK);

a246 2
				if(Tmk_debug>1) Tmk_err(" releasing %d \n", j);

a249 6

#if defined(MPL) 
		    sigio_buffer_free(req);
#endif


a257 4

#if defined(MPL)
			 tmk_rnc_initialize(); 
#else
d259 4
a262 3
#endif
		} else { req_typ.type = t ?
			     REQ_ARRIVAL_REPO : REQ_ARRIVAL; req_typ.id = id;
d285 1
a285 1
			sigio_mutex(SIG_UNBLOCK, &ALRM_and_IO_mask, NULL, UNLOCK);
d297 1
a297 1
					sigio_mutex(SIG_BLOCK, &ALRM_and_IO_mask, NULL, LOCK);
d316 1
a316 1
			sigio_mutex(SIG_BLOCK, &ALRM_and_IO_mask, NULL, LOCK);
d332 1
a332 1
		sigio_mutex(SIG_SETMASK, &mask, NULL, UNLOCK);
a335 3
#if defined(THREADS)
	pthread_mutex_unlock(&monitor_lock);
#endif	
@


10.1.4.2
log
@Eliminated seqno and extra copying from MPL messages.
@
text
@d291 1
a291 1
			req_typ.seqno = req_seqno += SEQNO_INCR;
@


10.1.5.1
log
@Start of 0.10.1 THREADS branch. Incorporated alias code from SMP branch.
@
text
@@


10.1.5.2
log
@Added sigio_lock and monitor_lock. Changed segv_handler to avoid race condition.
@
text
@a184 3
#if defined(THREADS)
	pthread_mutex_lock(&monitor_lock);
#endif
d197 1
a197 3
#if defined(THREADS)
		pthread_mutex_lock(&sigio_lock);
#endif
d225 1
a225 10
#if defined(THREADS)
			pthread_mutex_unlock(&sigio_lock);
#endif
			while (spinmask ^ barrier->mask) {
#if defined(THREADS)
				const struct timespec timeout = {1,0};
				if (0 > sigtimedwait(&mask, NULL, &timeout));
					if ((errno != EINTR) && (errno != EAGAIN))
						Tmk_perrexit("<sigtimedwait>Tmk_barrier");
#else
d227 1
a227 2
#endif
			}
d229 1
a229 3
#if defined(THREADS)
			pthread_mutex_lock(&sigio_lock);
#endif
d284 1
a284 3
#if defined(THREADS)
			pthread_mutex_unlock(&sigio_lock);
#endif
d298 1
a298 3
#if defined(THREADS)
					pthread_mutex_lock(&sigio_lock);
#endif
d317 1
a317 3
#if defined(THREADS)
			pthread_mutex_lock(&sigio_lock);
#endif
d331 1
a331 3
#if defined(THREADS)
		pthread_mutex_unlock(&sigio_lock);
#endif
a335 3
#if defined(THREADS)
	pthread_mutex_unlock(&monitor_lock);
#endif	
@


10.1.5.3
log
@eliminated sigtimedwait (explicitly unblock signals instead)
@
text
@a231 2

			sigprocmask(SIG_SETMASK, &mask, NULL);
d235 4
a238 1
				/* NOTHING */
a244 2
			sigprocmask(SIG_BLOCK, &ALRM_and_IO_mask, NULL);

@


10.1.5.4
log
@Changed SIGALRM to be blocked by all threads and unblocked only when
a recv timeout is needed.
@
text
@d305 1
a305 1
			sigprocmask(SIG_UNBLOCK, &ALRM_and_IO_mask, NULL);
@


10.1.5.5
log
@Cleaned up sigprocmask/pthread_sigmask/sigthreadmask and sigio
locking/unlocking with sigio_mutex macro
@
text
@d199 4
a202 2
		sigio_mutex(SIG_BLOCK, &ALRM_and_IO_mask, &mask, LOCK);

d230 2
d233 9
a241 5
			sigio_mutex(SIG_SETMASK, &mask, NULL, UNLOCK);

			while (spinmask ^ barrier->mask)
				;

d243 2
d246 2
a247 2
			sigio_mutex(SIG_BLOCK, &ALRM_and_IO_mask, NULL, LOCK);

d302 4
a305 2

			sigio_mutex(SIG_UNBLOCK, &ALRM_and_IO_mask, NULL, UNLOCK);
d317 4
a320 2
					sigio_mutex(SIG_BLOCK, &ALRM_and_IO_mask, NULL, LOCK);

d338 4
a341 2
			sigio_mutex(SIG_BLOCK, &ALRM_and_IO_mask, NULL, LOCK);

d355 4
a358 2

		sigio_mutex(SIG_SETMASK, &mask, NULL, UNLOCK);
@


10.1.5.6
log
@cleaned up signal masks
@
text
@d199 1
a199 1
		sigio_mutex(SIG_BLOCK, &IO_mask, &mask, LOCK);
d229 1
a229 1
			sigio_mutex(SIG_UNBLOCK, &IO_mask, NULL, UNLOCK);
d236 1
a236 1
			sigio_mutex(SIG_BLOCK, &IO_mask, NULL, LOCK);
@


10.1.5.7
log
@Added $Id$
@
text
@a81 2
 * $Id$
 *
@


10.1.2.1
log
@changed page_dirty list and intervals to use ranges
@
text
@@


10.0
log
@POSIX Version
@
text
@@


10.0.3.1
log
@Initial Linux port by Rob Fowler.
@
text
@@


10.0.2.1
log
@Start of the 0.10.1 development branch
@
text
@@


10.0.2.1.2.1
log
@Start of the 0.10.1 multiprocessor development branch
@
text
@@


10.0.2.1.2.2
log
@Added sigio locking inside existing critical sections (sigprocmask). <SMP>
@
text
@d197 1
a197 3
#if   defined(__sgi)
		spin_lock(&sigio_lock);	/* SMP */
#endif
d284 1
a284 3
#if defined(__sgi)
			release_lock(&sigio_lock);	/* SMP */
#endif
d298 1
a298 3
#if defined(__sgi)
					spin_lock(&sigio_lock);	/* SMP */
#endif
d317 1
a317 3
#if defined(__sgi)
			spin_lock(&sigio_lock);	/* SMP */
#endif
d331 1
a331 3
#if defined(__sgi)
		release_lock(&sigio_lock);	/* SMP */
#endif
@


10.0.2.1.2.3
log
@Added counter to enable one process to act as the proxy for the other
processes on this node.  (Right now it only supports two processes
per node.) <SMP>
@
text
@a81 2
 * $Id$
 *
d87 1
a87 4
#if	defined(__sgi)
	unsigned char volatile	counter;	/* SMP */
#endif
	unsigned      volatile	mask;
a198 2

		if (barrier->counter) {
d200 1
a200 1
			Tmk_interval_create(proc_vector_time_);
d202 2
a203 2
			if ((t = Tmk_diff_repo_test()) == 0)
				t = Tmk_interval_repo_test();
d205 1
a205 1
			if ((manager = barrier->manager) == Tmk_proc_id) {
d207 1
a207 1
				struct req_syn *req;
d209 1
a209 1
				Tmk_barrier_sigio_handler = special_handler;
d211 1
a211 1
				rep_msg.repo = t;
d213 3
a215 3
				for (j = 0; j < Tmk_nprocs; j++) {
					if (j == Tmk_proc_id)
						continue;
d217 1
a217 1
					if ((1 << j) & barrier->mask) {
d219 1
a219 1
						struct arrival *arrival = &arrival_[j];
d221 2
a222 2
						if ((req = arrival->req)->type == REQ_ARRIVAL_REPO)
							rep_msg.repo = 1;
d224 1
a224 2
						Tmk_interval_incorporate((caddr_t)&req->vector_time[NPROCS], arrival->size - sizeof(struct req_syn), 0);
					}
d226 3
a228 2
				while (spinmask ^ barrier->mask)
					sigio_handler();
d230 1
a230 1
				barrier->mask = 0;
d232 3
a234 3
				for (j = 0; j < Tmk_nprocs; j++) {
					if (j == Tmk_proc_id)
						continue;
d236 1
a236 1
					rep_msg.seqno = (req = arrival_[j].req)->seqno;
d238 1
a238 1
					size = Tmk_interval_request(rep_msg.data, req->vector_time) - (caddr_t)&rep_msg;
d240 5
a244 5
					/*
					 * The ATM driver doesn't check the message size.
					 */
					if (size > tmk_MTU)
						Tmk_errexit("<size == %d>Tmk_barrier (proc: %d)\n", size, j);
d246 2
a247 2
					if (0 > write(rep_fd_[j], &rep_msg, size))
						Tmk_perrexit("<write>Tmk_barrier (proc: %d)", j);
d249 2
a250 2
					if (0 > send(rep_fd_[j], (char *)&rep_msg, size, 0))
						Tmk_perrexit("<send>Tmk_barrier (proc: %d)", j);
d252 5
a256 5
				}
				/*
				 * Perform the merged mprotects.
				 */
				Tmk_page_inval_perform();
d258 1
a258 1
				Tmk_barrier_sigio_handler = default_handler;
d260 5
a264 5
				sigio_buffer_initialize();
			}
			else {
				req_typ.type = t ? REQ_ARRIVAL_REPO : REQ_ARRIVAL;
				req_typ.id = id;
d266 1
a266 1
				req_iov[2].iov_len = Tmk_interval_request_proc(req_data, Tmk_proc_id, MAX(inverse_time_[manager], proc_array_[manager].prev->vector_time_[Tmk_proc_id])) - req_data;
d268 5
a272 5
				/*
				 * The ATM driver doesn't check the message size.
				 */
				if (req_iov[2].iov_len + sizeof(struct req_syn) > tmk_MTU)
					Tmk_errexit("<size == %d>Tmk_barrier\n", req_iov[2].iov_len);
d274 2
a275 2
				req_typ.seqno = req_seqno += NPROCS;
		       rexmit:
d277 2
a278 2
				if (0 > writev(req_fd_[manager], req_iov, sizeof(req_iov)/sizeof(req_iov[0])))
					Tmk_perrexit("<writev>Tmk_barrier");
d280 2
a281 2
				if (0 > sendmsg(req_fd_[manager], &req_hdr, 0))
					Tmk_perrexit("<sendmsg>Tmk_barrier");
d283 1
a283 1
				Tmk_tout_flag = 0;
d285 1
a285 1
				setitimer(ITIMER_REAL, &Tmk_tout, NULL);
d287 1
a287 1
				release_lock(&sigio_lock);	/* SMP */
d289 2
a290 2
				sigprocmask(SIG_SETMASK, &mask, NULL);
			retry:
d292 1
a292 1
				if ((size = read(req_fd_[manager], &rep_msg, sizeof(rep_msg))) < 0)
d294 1
a294 1
				if ((size = recv(req_fd_[manager], (char *)&rep_msg, sizeof(rep_msg), 0)) < 0)
d296 1
a296 1
					if (Tmk_tout_flag) {
d298 2
a299 2
						if (Tmk_debug)
							Tmk_err("<timeout: %d>Tmk_barrier: seqno == %d\n", manager, req_typ.seqno);
d301 1
a301 1
						sigprocmask(SIG_BLOCK, &ALRM_and_IO_mask, NULL);
d303 1
a303 1
						spin_lock(&sigio_lock);	/* SMP */
d305 5
a309 5
						goto rexmit;
					}
					else if (errno == EINTR)
						goto retry;
					else
d311 1
a311 1
						Tmk_perrexit("<read>Tmk_barrier");
d313 1
a313 1
						Tmk_perrexit("<recv>Tmk_barrier");
d315 1
a315 1
				if (rep_msg.seqno != req_typ.seqno) {
d317 2
a318 2
					if (Tmk_debug)
						Tmk_err("<bad seqno: %d>Tmk_barrier: seqno == %d (received: %d)\n", manager, req_typ.seqno, rep_msg.seqno);
d320 3
a322 3
					goto retry;
				}
				sigprocmask(SIG_BLOCK, &ALRM_and_IO_mask, NULL);
d324 1
a324 1
				spin_lock(&sigio_lock);	/* SMP */
d326 2
a327 15
				Tmk_stat.messages++;
				Tmk_stat.bytes += size;

				Tmk_interval_incorporate(rep_msg.data, size - sizeof(rep_msg.seqno) - sizeof(rep_msg.repo), proc_vector_time_);
			}
			for (j = 0; j < Tmk_nprocs; j++) {
				if (j == Tmk_proc_id)
					continue;

				inverse_time_[j] = proc_vector_time_[Tmk_proc_id];
			}
			if (rep_msg.repo)
				Tmk_repo();
#if defined(__sgi)
			barrier->counter = 0;
d329 1
a329 4
			release_lock(&sigio_lock);	/* SMP */
#endif
			sigprocmask(SIG_SETMASK, &mask, NULL);
#if defined(__sgi)
d331 3
a333 2
		else {
			barrier->counter++;
d335 1
a335 3
			release_lock(&sigio_lock);	/* SMP */

			while (barrier->counter);
d337 4
d342 1
@


10.0.2.1.2.4
log
@Added a missing sigprocmask by the first process to arrive at the barrier.
@
text
@d82 1
a82 1
 * $Id: barrier.c,v 10.0.2.1.2.3 1996/04/28 17:37:42 alc Exp alc $
d350 1
a350 1

d352 1
a358 2
			sigprocmask(SIG_SETMASK, &mask, NULL);

a360 2
#else
		sigprocmask(SIG_SETMASK, &mask, NULL);
@


10.0.1.1
log
@FASTLINK Version
@
text
@d113 3
a115 1
void	Tmk_barrier_sigio_handler(req, size)
d123 13
a135 1
	if ((barrier_[req->id].mask |= 1 << pid) & Tmk_proc_mask) {
d137 1
a137 2
		if (req->type == REQ_ARRIVAL_REPO)
			rep_msg.repo = 1;
a138 2
		Tmk_interval_incorporate((caddr_t)&req->vector_time[NPROCS], size - sizeof(struct req_syn), 0);
	}
d140 5
a144 1
	arrival->size = size;
d147 2
d185 2
d190 1
a190 1
	if ((id < NBARRIERS) && (id & Tmk_proc_mask))  {
d200 1
a200 1
		if ((t = id == Tmk_mask) && ((t = Tmk_diff_repo_test()) == 0))
d207 2
d211 3
a213 2
			for (j = 0, t = barrier->mask; t; j++) {
				if (t & 1) {
d215 2
a223 1
				t >>= 1;
d225 1
a225 3
			barrier->mask |= Tmk_proc_mask;

			for (t = id; t ^ barrier->mask; )
d230 3
a232 2
			for (t &= ~Tmk_proc_mask, j = 0; t; j++) {
				if (t & 1) {
d234 1
a234 1
					rep_msg.seqno = (req = arrival_[j].req)->seqno;
d236 1
a236 1
					size = Tmk_interval_request(rep_msg.data, req->vector_time) - (caddr_t)&rep_msg;
d238 5
a242 5
					/*
					 * The ATM driver doesn't check the message size.
					 */
					if (size > tmk_MTU)
						Tmk_errexit("<size == %d>Tmk_barrier (proc: %d)\n", size, j);
d244 2
a245 2
					if (0 > write(rep_fd_[j], &rep_msg, size))
						Tmk_perrexit("<write>Tmk_barrier (proc: %d)", j);
d247 2
a248 2
					if (0 > send(rep_fd_[j], (char *)&rep_msg, size, 0))
						Tmk_perrexit("<send>Tmk_barrier (proc: %d)", j);
a249 2
				}
				t >>= 1;
d256 1
a256 1
			if (tmk_stat_flag) {
d258 1
a258 2
				Tmk_stat.arrivals++;
			}
d318 3
a321 6
			if (tmk_stat_flag) {

				Tmk_stat.arrivals++;
				Tmk_stat.messages++;
				Tmk_stat.bytes += size;
			}
d323 3
a325 3
		for (id &= ~Tmk_proc_mask, j = 0; id; j++) {
			if (id & 1)
				inverse_time_[j] = proc_vector_time_[Tmk_proc_id];
d327 1
a327 1
			id >>= 1;
d353 2
a354 4
	for (i = 0; i < NPROCS; i++) {

		int     j = 1 << i;
		int     k = j << 1;
d356 1
a356 1
		while (j < NBARRIERS) {
a357 5
			barrier_[j].manager = i;

			j += k;
		}
	}
@


9.7
log
@Tmk-0.9.7R
@
text
@d3 1
a3 1
 *  Copyright (c) 1991-1995						     *
d78 4
d171 1
a171 1
		if (0 > send(rep_fd_[pid], &rep_msg, size, 0))
d193 1
a193 1
		int		mask = sigblock(sigmask(SIGALRM)|sigmask(SIGIO));
d196 2
d247 1
a247 1
				if (0 > send(rep_fd_[j], &rep_msg, size, 0))
d285 1
a285 1
			sigsetmask(mask);
d290 1
a290 1
			if ((size = recv(req_fd_[manager], &rep_msg, sizeof(rep_msg), 0)) < 0)
d297 1
a297 1
					sigblock(sigmask(SIGALRM)|sigmask(SIGIO));
d316 1
a316 1
			sigblock(sigmask(SIGALRM)|sigmask(SIGIO));
d332 1
a332 1
		sigsetmask(mask);
@


9.7.6.1
log
@with newbarrier
@
text
@d311 1
a311 1
#if 1
a313 4
#endif

			Tmk_stat.barrier_reply++;
			Tmk_stat.barrier_reply_bytes += size;
a322 1
#if 1
d325 1
a325 1
#endif
@


9.7.2.1
log
@Start of the 0.9.8 development branch
@
text
@@


9.6
log
@*** empty log message ***
@
text
@@


9.6.1.1
log
@FASTLINK Version
@
text
@d3 2
a4 2
 *  Copyright (c) 1991-1994                                                  *
 *  by TreadMarks, L.L.C. (TREADMARKS), Houston, Texas	  		     *
d6 5
a10 5
 *  This software is furnished under a license and may be used and  copied   *
 *  only  in  accordance  with  the  terms  of  such  license and with the   *
 *  inclusion of the above copyright notice.  This software or  any  other   *
 *  copies  thereof may not be provided or otherwise made available to any   *
 *  other person.  No title to or ownership of  the  software  is  hereby    *
d15 2
a16 2
 *  confidential and proprietary to TREADMARKS.  RECIPIENT agrees to take    *
 *  all reasonable steps to safeguard the software, and to prevent its       *
d19 2
a20 2
 *  The information in this software is subject to change  without  notice   *
 *  and should  not  be  construed  as  a commitment by TREADMARKS.	     *
d24 6
a29 7
 *  of merchantability or fitness), with regard to the software.  	     *
 *  TREADMARKS assumes no responsibility for the use or reliability of its   *
 *  software.  TREADMARKS shall not be liable for any special, incidental,   *
 *  or consequential damages, or any damages whatsoever due to causes beyond *
 *  the reasonable control of TREADMARKS, loss of use, data or profits, or   *
 *  from loss or destruction of materials provided to TREADMARKS by	     *
 *  RECIPIENT.								     *
d31 4
a34 4
 *  TREADMARKS's liability for damages arising out of or in connection with  *
 *  the use or performance of this software, whether in an action of	     *
 *  contract or tort including negligence, shall be limited to the purchase  *
 *  price, or the total amount paid by RECIPIENT, whichever is less.	     *
d74 4
d109 3
a111 1
void	Tmk_barrier_sigio_handler(req, size)
d119 13
a131 1
	if ((barrier_[req->id].mask |= 1 << pid) & Tmk_proc_mask) {
d133 1
a133 2
		if (req->type == REQ_ARRIVAL_REPO)
			rep_msg.repo = 1;
a134 2
		Tmk_interval_incorporate((caddr_t)&req->vector_time[NPROCS], size - sizeof(struct req_syn), 0);
	}
d136 5
a140 1
	arrival->size = size;
d143 2
d181 2
d186 1
a186 1
	if ((id < NBARRIERS) && (id & Tmk_proc_mask))  {
d194 1
a194 1
		if ((t = id == Tmk_mask) && ((t = Tmk_diff_repo_test()) == 0))
d201 2
d205 3
a207 2
			for (j = 0, t = barrier->mask; t; j++) {
				if (t & 1) {
d209 2
a217 1
				t >>= 1;
d219 1
a219 3
			barrier->mask |= Tmk_proc_mask;

			for (t = id; t ^ barrier->mask; )
d224 3
a226 2
			for (t &= ~Tmk_proc_mask, j = 0; t; j++) {
				if (t & 1) {
d228 1
a228 1
					rep_msg.seqno = (req = arrival_[j].req)->seqno;
d230 1
a230 1
					size = Tmk_interval_request(rep_msg.data, req->vector_time) - (caddr_t)&rep_msg;
d232 5
a236 5
					/*
					 * The ATM driver doesn't check the message size.
					 */
					if (size > tmk_MTU)
						Tmk_errexit("<size == %d>Tmk_barrier (proc: %d)\n", size, j);
d238 2
a239 2
					if (0 > write(rep_fd_[j], &rep_msg, size))
						Tmk_perrexit("<write>Tmk_barrier (proc: %d)", j);
d241 2
a242 2
					if (0 > send(rep_fd_[j], &rep_msg, size, 0))
						Tmk_perrexit("<send>Tmk_barrier (proc: %d)", j);
a243 2
				}
				t >>= 1;
d250 1
a250 1
			if (tmk_stat_flag) {
d252 1
a252 2
				Tmk_stat.arrivals++;
			}
d312 3
a315 6
			if (tmk_stat_flag) {

				Tmk_stat.arrivals++;
				Tmk_stat.messages++;
				Tmk_stat.bytes += size;
			}
d317 3
a319 3
		for (id &= ~Tmk_proc_mask, j = 0; id; j++) {
			if (id & 1)
				inverse_time_[j] = proc_vector_time_[Tmk_proc_id];
d321 1
a321 1
			id >>= 1;
d347 2
a348 4
	for (i = 0; i < NPROCS; i++) {

		int     j = 1 << i;
		int     k = j << 1;
d350 1
a350 1
		while (j < NBARRIERS) {
a351 5
			barrier_[j].manager = i;

			j += k;
		}
	}
@


9.5
log
@*** empty log message ***
@
text
@d3 2
a4 2
 *  Copyright (c) 1991-1994                                                  *
 *  by TreadMarks, L.L.C. (TREADMARKS), Houston, Texas	  		     *
d6 5
a10 5
 *  This software is furnished under a license and may be used and  copied   *
 *  only  in  accordance  with  the  terms  of  such  license and with the   *
 *  inclusion of the above copyright notice.  This software or  any  other   *
 *  copies  thereof may not be provided or otherwise made available to any   *
 *  other person.  No title to or ownership of  the  software  is  hereby    *
d15 2
a16 2
 *  confidential and proprietary to TREADMARKS.  RECIPIENT agrees to take    *
 *  all reasonable steps to safeguard the software, and to prevent its       *
d19 2
a20 2
 *  The information in this software is subject to change  without  notice   *
 *  and should  not  be  construed  as  a commitment by TREADMARKS.	     *
d24 6
a29 7
 *  of merchantability or fitness), with regard to the software.  	     *
 *  TREADMARKS assumes no responsibility for the use or reliability of its   *
 *  software.  TREADMARKS shall not be liable for any special, incidental,   *
 *  or consequential damages, or any damages whatsoever due to causes beyond *
 *  the reasonable control of TREADMARKS, loss of use, data or profits, or   *
 *  from loss or destruction of materials provided to TREADMARKS by	     *
 *  RECIPIENT.								     *
d31 4
a34 4
 *  TREADMARKS's liability for damages arising out of or in connection with  *
 *  the use or performance of this software, whether in an action of	     *
 *  contract or tort including negligence, shall be limited to the purchase  *
 *  price, or the total amount paid by RECIPIENT, whichever is less.	     *
d74 4
d245 5
@


9.5.1.1
log
@FASTLINK Version
@
text
@d106 3
a108 1
void	Tmk_barrier_sigio_handler(req, size)
d116 13
a128 1
	if ((barrier_[req->id].mask |= 1 << pid) & Tmk_proc_mask) {
d130 1
a130 2
		if (req->type == REQ_ARRIVAL_REPO)
			rep_msg.repo = 1;
a131 2
		Tmk_interval_incorporate((caddr_t)&req->vector_time[NPROCS], size - sizeof(struct req_syn), 0);
	}
d133 5
a137 1
	arrival->size = size;
d140 2
d178 1
a178 1
        struct timeval  start, end;
d183 1
a183 7
	if (tmk_stat_flag) {

		Tmk_stat.arrivals++;

		gettimeofday(&start, NULL);
	}
	if ((id < NBARRIERS) && (id & Tmk_proc_mask))  {
d191 1
a191 1
		if ((t = id == Tmk_mask) && ((t = Tmk_diff_repo_test()) == 0))
d198 2
d202 5
a206 2
			for (j = 0, t = barrier->mask; t; j++) {
				if (t & 1) {
a214 1
				t >>= 1;
d216 1
a216 3
			barrier->mask |= Tmk_proc_mask;

			for (t = id; t ^ barrier->mask; )
d221 3
a223 2
			for (t &= ~Tmk_proc_mask, j = 0; t; j++) {
				if (t & 1) {
d225 1
a225 1
					rep_msg.seqno = (req = arrival_[j].req)->seqno;
d227 1
a227 1
					size = Tmk_interval_request(rep_msg.data, req->vector_time) - (caddr_t)&rep_msg;
d229 5
a233 5
					/*
					 * The ATM driver doesn't check the message size.
					 */
					if (size > tmk_MTU)
						Tmk_errexit("<size == %d>Tmk_barrier (proc: %d)\n", size, j);
d235 2
a236 2
					if (0 > write(rep_fd_[j], &rep_msg, size))
						Tmk_perrexit("<write>Tmk_barrier (proc: %d)", j);
d238 2
a239 2
					if (0 > send(rep_fd_[j], &rep_msg, size, 0))
						Tmk_perrexit("<send>Tmk_barrier (proc: %d)", j);
a240 2
				}
				t >>= 1;
d242 3
d309 3
a311 3
		for (id &= ~Tmk_proc_mask, j = 0; id; j++) {
			if (id & 1)
				inverse_time_[j] = proc_vector_time_[Tmk_proc_id];
d313 1
a313 1
			id >>= 1;
d339 2
a340 4
	for (i = 0; i < NPROCS; i++) {

		int     j = 1 << i;
		int     k = j << 1;
d342 1
a342 1
		while (j < NBARRIERS) {
a343 5
			barrier_[j].manager = i;

			j += k;
		}
	}
@


9.4
log
@*** empty log message ***
@
text
@@
