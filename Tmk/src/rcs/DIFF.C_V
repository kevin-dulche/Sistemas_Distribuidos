head	11.11;
access;
symbols
	Tmk-1_0_3_2R:10.10.1.15.0.4
	Tmk-1_0_3_1R:10.10.1.15.0.4
	Tmk-2_0:10.10.1
	Tmk-1_2_TO-2_0_BRANCH_POINT:10.10.1.20
	Tmk-1_0_3R:10.10.1.15.0.4
	Tmk-1_2:10.10.1
	Tmk-1_0_TO-1_2_BRANCH_POINT:10.10.1.15
	Tmk-1_0_1R:10.10.1.6
	Tmk-1_1:11
	Tmk-1_0:10.10.1.15.0
	Tmk-1_0_TO-1_1_BRANCH_POINT:10.10
	Tmk-0_10_1_2R:10.1.3.1
	Tmk-0_10_1_1R:10.1.3.1
	Tmk-0_10_1R:10.1;
locks
	alc:10.10.1.20; strict;
comment	@ * @;


11.11
date	97.09.07.17.29.01;	author alc;	state Exp;
branches;
next	11.10;

11.10
date	97.08.07.17.08.31;	author alc;	state Exp;
branches;
next	11.9;

11.9
date	97.08.05.06.54.04;	author alc;	state Exp;
branches;
next	11.8;

11.8
date	97.08.01.05.46.00;	author alc;	state Exp;
branches;
next	11.7;

11.7
date	97.07.30.22.32.43;	author alc;	state Exp;
branches;
next	11.6;

11.6
date	97.07.24.19.28.37;	author alc;	state Exp;
branches;
next	11.5;

11.5
date	97.07.10.16.21.28;	author alc;	state Exp;
branches;
next	11.4;

11.4
date	97.06.26.22.54.02;	author alc;	state Exp;
branches;
next	11.3;

11.3
date	97.06.26.04.11.44;	author alc;	state Exp;
branches;
next	11.2;

11.2
date	97.06.25.18.26.53;	author alc;	state Exp;
branches;
next	11.1;

11.1
date	97.06.05.22.41.01;	author alc;	state Exp;
branches;
next	10.10;

10.10
date	97.03.16.18.48.52;	author alc;	state Exp;
branches
	10.10.1.1;
next	10.9;

10.9
date	97.03.09.01.14.53;	author alc;	state Exp;
branches;
next	10.8;

10.8
date	97.03.07.23.47.17;	author alc;	state Exp;
branches;
next	10.7;

10.7
date	97.03.07.04.03.58;	author alc;	state Exp;
branches;
next	10.6;

10.6
date	96.08.25.20.39.36;	author alc;	state Exp;
branches;
next	10.5;

10.5
date	96.08.24.21.10.49;	author alc;	state Exp;
branches;
next	10.4;

10.4
date	96.08.24.20.01.11;	author alc;	state Exp;
branches;
next	10.3;

10.3
date	96.08.08.18.26.56;	author alc;	state Exp;
branches;
next	10.2;

10.2
date	96.08.08.04.55.16;	author alc;	state Exp;
branches;
next	10.1;

10.1
date	96.05.27.04.45.30;	author alc;	state Rel;
branches
	10.1.2.1
	10.1.3.1
	10.1.4.1
	10.1.5.1;
next	10.0;

10.0
date	96.03.15.09.47.40;	author alc;	state Rel;
branches
	10.0.1.1
	10.0.2.1
	10.0.3.1;
next	9.7;

9.7
date	96.03.15.09.39.04;	author alc;	state Rel;
branches
	9.7.2.1
	9.7.6.1;
next	9.6;

9.6
date	96.03.15.09.30.03;	author alc;	state Rel;
branches
	9.6.1.1;
next	9.5;

9.5
date	96.03.15.09.24.56;	author alc;	state Rel;
branches
	9.5.1.1;
next	9.4;

9.4
date	96.03.15.09.20.45;	author alc;	state Rel;
branches;
next	;

9.5.1.1
date	96.03.15.09.27.09;	author alc;	state Rel;
branches;
next	;

9.6.1.1
date	96.03.15.09.32.19;	author alc;	state Rel;
branches;
next	;

9.7.2.1
date	96.03.17.18.00.32;	author alc;	state Exp;
branches;
next	;

9.7.6.1
date	96.07.23.18.42.25;	author zhenghua;	state Exp;
branches;
next	;

10.0.1.1
date	96.03.15.09.51.03;	author alc;	state Rel;
branches;
next	;

10.0.2.1
date	96.03.17.18.12.04;	author alc;	state Exp;
branches;
next	10.0.2.2;

10.0.2.2
date	96.03.18.01.29.09;	author alc;	state Exp;
branches
	10.0.2.2.2.1;
next	;

10.0.2.2.2.1
date	96.03.25.21.00.30;	author alc;	state Exp;
branches;
next	10.0.2.2.2.2;

10.0.2.2.2.2
date	96.03.27.06.26.50;	author alc;	state Exp;
branches;
next	10.0.2.2.2.3;

10.0.2.2.2.3
date	96.03.28.03.43.58;	author alc;	state Exp;
branches;
next	10.0.2.2.2.4;

10.0.2.2.2.4
date	96.03.28.04.01.56;	author alc;	state Exp;
branches;
next	10.0.2.2.2.5;

10.0.2.2.2.5
date	96.03.30.21.19.48;	author alc;	state Exp;
branches;
next	;

10.0.3.1
date	96.04.22.16.59.08;	author alc;	state Exp;
branches;
next	;

10.1.2.1
date	96.06.25.19.28.51;	author tmiller;	state Exp;
branches;
next	10.1.2.2;

10.1.2.2
date	96.08.01.19.56.28;	author alc;	state Exp;
branches;
next	10.1.2.3;

10.1.2.3
date	96.08.02.02.55.09;	author alc;	state Exp;
branches;
next	;

10.1.3.1
date	96.11.14.06.25.07;	author alc;	state Rel;
branches;
next	;

10.1.4.1
date	96.07.29.21.09.00;	author rjf;	state Exp;
branches;
next	10.1.4.2;

10.1.4.2
date	96.07.30.20.52.50;	author rjf;	state Exp;
branches;
next	;

10.1.5.1
date	96.06.27.16.38.16;	author tmiller;	state Exp;
branches;
next	10.1.5.2;

10.1.5.2
date	96.06.27.23.05.15;	author tmiller;	state Exp;
branches;
next	10.1.5.3;

10.1.5.3
date	96.07.02.22.34.57;	author tmiller;	state Exp;
branches;
next	10.1.5.4;

10.1.5.4
date	96.07.03.19.32.35;	author tmiller;	state Exp;
branches;
next	10.1.5.5;

10.1.5.5
date	96.08.07.17.23.37;	author tmiller;	state Exp;
branches;
next	10.1.5.6;

10.1.5.6
date	96.08.08.15.30.28;	author tmiller;	state Exp;
branches;
next	;

10.10.1.1
date	97.07.03.20.23.30;	author alc;	state Exp;
branches;
next	10.10.1.2;

10.10.1.2
date	97.07.03.20.48.13;	author alc;	state Exp;
branches;
next	10.10.1.3;

10.10.1.3
date	97.07.30.22.33.27;	author alc;	state Exp;
branches;
next	10.10.1.4;

10.10.1.4
date	97.08.01.05.52.51;	author alc;	state Exp;
branches;
next	10.10.1.5;

10.10.1.5
date	97.08.05.06.56.22;	author alc;	state Exp;
branches;
next	10.10.1.6;

10.10.1.6
date	97.08.07.17.17.52;	author alc;	state Exp;
branches;
next	10.10.1.7;

10.10.1.7
date	98.03.02.04.45.00;	author alc;	state Exp;
branches;
next	10.10.1.8;

10.10.1.8
date	98.03.22.05.52.28;	author alc;	state Exp;
branches;
next	10.10.1.9;

10.10.1.9
date	98.04.02.07.21.06;	author alc;	state Exp;
branches;
next	10.10.1.10;

10.10.1.10
date	98.05.10.04.53.20;	author alc;	state Exp;
branches;
next	10.10.1.11;

10.10.1.11
date	98.05.10.05.06.23;	author alc;	state Exp;
branches;
next	10.10.1.12;

10.10.1.12
date	98.05.14.03.57.28;	author alc;	state Exp;
branches;
next	10.10.1.13;

10.10.1.13
date	98.05.14.20.10.16;	author alc;	state Exp;
branches;
next	10.10.1.14;

10.10.1.14
date	98.07.09.06.13.38;	author alc;	state Exp;
branches;
next	10.10.1.15;

10.10.1.15
date	98.07.09.06.18.23;	author alc;	state Exp;
branches
	10.10.1.15.0.1;
next	10.10.1.16;

10.10.1.16
date	98.07.17.05.15.55;	author alc;	state Exp;
branches;
next	10.10.1.17;

10.10.1.17
date	98.07.26.05.25.28;	author alc;	state Exp;
branches;
next	10.10.1.18;

10.10.1.18
date	98.07.26.06.26.40;	author alc;	state Exp;
branches;
next	10.10.1.19;

10.10.1.19
date	98.07.31.20.17.33;	author alc;	state Exp;
branches;
next	10.10.1.20;

10.10.1.20
date	98.08.06.05.53.40;	author alc;	state Exp;
branches;
next	;

10.10.1.15.0.1
date	98.07.17.02.34.14;	author alc;	state Exp;
branches;
next	10.10.1.15.0.2;

10.10.1.15.0.2
date	98.07.17.03.01.09;	author alc;	state Exp;
branches;
next	10.10.1.15.0.3;

10.10.1.15.0.3
date	98.07.17.03.45.30;	author alc;	state Exp;
branches;
next	10.10.1.15.0.4;

10.10.1.15.0.4
date	98.08.06.05.59.08;	author alc;	state Exp;
branches;
next	;


desc
@@


11.11
log
@Modified Tmk_diff_create and Tmk_diff_request to adapt to write
granularity.
@
text
@/*****************************************************************************
 *                                                                           *
 *  Copyright (c) 1991-1996						     *
 *  by ParallelTools, L.L.C. (PTOOLS), Houston, Texas			     *
 *                                                                           *
 *  This software is furnished under a license and may be used and copied    *
 *  only in accordance with the terms of such license and with the	     *
 *  inclusion of the above copyright notice.  This software or any other     *
 *  copies thereof may not be provided or otherwise made available to any    *
 *  other person.  No title to or ownership of the software is hereby	     *
 *  transferred.                                                             *
 *									     *
 *  The recipient of this software (RECIPIENT) acknowledges and agrees that  *
 *  the software contains information and trade secrets that are	     *
 *  confidential and proprietary to PTOOLS.  RECIPIENT agrees to take all    *
 *  reasonable steps to safeguard the software, and to prevent its	     *
 *  disclosure.								     * 
 *                                                                           *
 *  The information in this software is subject to change without notice     *
 *  and should not be construed as a commitment by PTOOLS.		     *
 *                                                                           *
 *  This software is furnished AS IS, without warranty of any kind, either   *
 *  express or implied (including, but not limited to, any implied warranty  *
 *  of merchantability or fitness), with regard to the software.  PTOOLS     *
 *  assumes no responsibility for the use or reliability of its software.    *
 *  PTOOLS shall not be liable for any special,	incidental, or		     *
 *  consequential damages, or any damages whatsoever due to causes beyond    *
 *  the reasonable control of PTOOLS, loss of use, data or profits, or from  *
 *  loss or destruction of materials provided to PTOOLS by RECIPIENT.	     *
 *									     *
 *  PTOOLS's liability for damages arising out of or in connection with the  *
 *  use or performance of this software, whether in an action of contract    *
 *  or tort including negligence, shall be limited to the purchase price,    *
 *  or the total amount paid by RECIPIENT, whichever is less.		     *
 *                                                                           *
 *****************************************************************************/

/*
 * $Id: diff.c,v 11.10 1997/08/07 17:08:31 alc Exp alc $
 *
 * Description:    
 *	diff management routines
 *
 * External Functions:
 *			Tmk_diff_create,
 *			Tmk_diff_initialize,
 *			Tmk_diff_repo,
 *			Tmk_diff_repo_test,
 *			Tmk_diff_request,
 *			Tmk_diff_sigio_handler
 *
 * Facility:	TreadMarks Distributed Shared Memory System
 * History:
 *	15-Apr-1993	Alan L. Cox 	Created
 *	26-Oct-1993	Alan L. Cox	Optimized diff create
 *	19-Nov-1993	Alan L. Cox	Adapted for RS/6000
 *	 7-Jan-1994	Alan L. Cox	Partial retransmission of diff req
 *	 5-Jun-1994	Alan L. Cox	Reduced diff requests
 *	13-Jun-1994	Alan L. Cox	Overlapped diff requests
 *	14-Jun-1994	Alan L. Cox	Adapted for Alpha
 *					 (changes provided by Povl T. Koch)
 *	24-Jul-1994	Alan L. Cox	Immediate retransmission performed
 *					 after high seqno received
 *	Version 0.9.0
 *
 *	Version 0.9.1
 *
 *	10-Dec-1994	Alan L. Cox	Changed to a single seqno counter
 *					 (suggested by Pete Keleher)
 *	14-Jan-1995	Alan L. Cox	Adapted for STREAMS
 *	28-Jan-1995	Alan L. Cox	Corrected iov merge by sigio handler
 *
 *	Version 0.9.2
 *
 *	21-Apr-1995	Alan L. Cox	Optimized diff create
 *	20-May-1995	Alan L. Cox	Modified heap to allow on-demand
 *					 expansion
 *	21-May-1995	Alan L. Cox	Adapted for SGI/IRIX
 *	 7-Jun-1995	Sandhya Dwarkadas
 *					Corrected request retransmission seqno
 *					 (See 10-Dec-1994 change)
 *	Version 0.9.3
 *
 *	 1-Jul-1995	Alan L. Cox	Added volatile to diff create to
 *					 prevent memory access reordering 
 *	Version 0.9.4
 *
 *	17-Dec-1995	Alan L. Cox	Moved the mprotect in the sigio
 *					 handler after the send
 *	Version 0.9.7
 *
 *	27-Jan-1996	Alan L. Cox	Replaced sigblock and sigsetmask
 *					 with sigprocmask
 *	Version 0.10
 */
#include "Tmk.h"

#define	H_SIZE	1048576

typedef	struct	heap	{
	struct	heap   *next;
	char	heap_[H_SIZE - MTU - sizeof(struct heap *)];
	char	heap_overflow_[MTU];
}      *heap_t;

static	heap_t	heap_expand( void )
{
	heap_t	heap = (heap_t) malloc(sizeof(struct heap));

	if (heap == 0)
		Tmk_errexit("<malloc>Tmk_heap_expand: out of memory");

	heap->next = 0;

	return heap;
}

static	heap_t	heap_1_start;

static	heap_t	heap_1_current;

static	char   *heap_1_brk;

static	char   *heap_1_end;

static	void	heap_1_ptr_initialize(heap)
	heap_t	heap;
{
	heap_1_current = heap;

	heap_1_brk = heap->heap_;

	heap_1_end = heap->heap_overflow_;
}

static	struct	req_dif	req = { /*seqno=*/0, /*from=*/0, /*type=*/REQ_DIFF };

static	unsigned	rep_seqno;
static	struct	iovec	rep_iov[2] = {
	{ (caddr_t)&rep_seqno, sizeof(rep_seqno) },
	{                   0, MTU - sizeof(rep_seqno) } };
static	struct	msghdr	rep_hdr = { 0, 0, rep_iov, sizeof(rep_iov)/sizeof(rep_iov[0]), 0, 0 };

static	heap_t	heap_2_start;

static	heap_t	heap_2_current;

#	define	heap_2_brk	*(char **)&rep_iov[1].iov_base	/* void *? */

static	char   *heap_2_end;

static	void	heap_2_ptr_initialize(heap)
	heap_t	heap;
{
	heap_2_current = heap;

	heap_2_brk = heap->heap_;

	heap_2_end = heap->heap_overflow_;
}

/*
 * Called by Tmk_repo
 */
void	Tmk_diff_repo()
{
	heap_1_ptr_initialize(heap_1_start);

	heap_2_ptr_initialize(heap_2_start);
}

/*
 * Called by Tmk_barrier
 */
int	Tmk_diff_repo_test()
{
	return heap_1_current != heap_1_start;
}

/*
 * Contorted to avoid cache conflict misses and pipeline stalls.  On
 * Intel processors, preload the diff into the cache to take advantage
 * of page mode access.
 *
 * See Tmk_diff_create for the description of the diff encoding.
 */
static	caddr_t	diff_apply(caddr_t page, caddr_t diff)
{
	short  *diff_cur = (short *) diff;
	short  *diff_run_end;

	int	run_length;

	while ((run_length = *diff_cur), (diff_cur += 2), (run_length > 0)) {

		int	run_offset = *(diff_cur - 1);
		int    *run_dest_cur = (int *)(page + run_offset);

		if (run_length & 4) {

			int	diff0 = *(int *) diff_cur;

			diff_cur += sizeof(int)/sizeof(*diff_cur);

			run_dest_cur[0] = diff0;

			if ((run_length -= 4) == 0)
				continue;

			run_dest_cur++;
		}
		if (run_length & 8) {

			int	diff0 = *(int *) diff_cur;
			int	diff1 = *(int *)(diff_cur + sizeof(int)/sizeof(*diff_cur));

			diff_cur += 2*sizeof(int)/sizeof(*diff_cur);

			run_dest_cur[0] = diff0;
			run_dest_cur[1] = diff1;

			if ((run_length -= 8) == 0)
				continue;

			run_dest_cur += 2;
		}
#if defined(__i386)
		{
			int	i = 0;

			do
				*(volatile int *)((caddr_t) diff_cur + i);
			while ((i += 32) < run_length);
		}
#endif
		diff_run_end = (short *)((caddr_t) diff_cur + run_length);

		do {
			int	diff0 = *(int *) diff_cur;
			int	diff1 = *(int *)(diff_cur + sizeof(int)/sizeof(*diff_cur));
			int	diff2 = *(int *)(diff_cur + 2*sizeof(int)/sizeof(*diff_cur));
			int	diff3 = *(int *)(diff_cur + 3*sizeof(int)/sizeof(*diff_cur));

			diff_cur += 4*sizeof(int)/sizeof(*diff_cur);

			run_dest_cur[0] = diff0;
			run_dest_cur[1] = diff1;
			run_dest_cur[2] = diff2;
			run_dest_cur[3] = diff3;
			run_dest_cur += 4;

		} while (diff_cur != diff_run_end);
	}
	return (caddr_t) diff_cur;
}

static	struct	interval	Interval;
static	struct	write_notice	Write_notice = { 0, 0, 0, &Interval };

#define NWRITES	((MTU - sizeof(struct req_typ))/(2*sizeof(unsigned short)))

/*
 * Called by segv_handler and Tmk_repo
 *
 * The algorithm for sorting the write notices and requesting the
 * corresponding DIFFs isn't optimal, i.e., it isn't guaranteed to
 * use the minimal number of request messages.  In practice, however,
 * it works well.
 */
void	Tmk_diff_request(page)
	page_t		page;
{
	int		i, j, n = 0;
	write_notice_t	write_[NWRITES + 1];

	write_[0] = &Write_notice;

	for (i = 0; i < NPROCS; i++) {

		write_notice_t	write = page->write_notice_[i]; 

		for (j = 0; write && write->diff == 0; j++) {

			interval_t	interval = write->interval;

			int		k;

			for (k = 0; k < NPROCS; k++)
				if (page->vector_time_[k] < interval->vector_time_[k])
					goto next_j;

			break;
		next_j:
			for (k = 0; k < NPROCS; k++)
				if (interval->vector_time_[k] < write_[j]->interval->vector_time_[k]) {
					j++; goto next_j;
				}
			assert(n < NWRITES - 1);

			for (k = n += 1; k > j; k--)
				write_[k] = write_[k - 1];

			write_[k] = write;

			write = write->next;
		}
	}
	if (n > 0) {

		struct	preq	{
			int		to;
			unsigned	seqno;
			int		i;
			int		n;	/* i < n */
		}	preq_[NPROCS*NPROCS];

		struct	preq   *preq = preq_;

		unsigned short *req_data_ptr;

		req.seqno = req_seqno += SEQNO_INCR;
		req.id = page - page_array_;

		n--;

		do {
			int		dom = n - 1;

			req_data_ptr = req.data;

			for (preq->n = n;; dom = MIN(dom, n - 1)) {

				do {
					interval_t	interval = write_[n]->interval;

					int		id = interval->id;

					req_data_ptr[0] = id;
					req_data_ptr[1] = interval->vector_time_[id];
					req_data_ptr += 2;

					if (Tmk_debug) {

						Tmk_err("(%d) ", id);

						for (j = 0; j < NPROCS; j++)
							Tmk_err("%d ", interval->vector_time_[j]);
					}

				} while (--n > dom);

				if (n < 0)
					goto xmit;
			redo:
				i = n + 1;

				do {
					for (j = 0; j < NPROCS; j++)
						if (write_[dom]->interval->vector_time_[j] < write_[i]->interval->vector_time_[j]) {

							if (--dom < 0)
								goto xmit;

							goto redo;
						}

				} while (--i > dom);
			}
		xmit:
			if (Tmk_debug)
				Tmk_err("Sending\n");

			preq->seqno = req_seqno;
			preq->to    = j = req_data_ptr[-2];
			preq->i     = n;
			preq++;

			if (0 > send(req_fd_[j], (char *)&req, (char *) req_data_ptr - (char *)&req, 0))
				Tmk_perrexit("<send>Tmk_diff_request");

		} while (n >= 0);

		preq = preq_;

		req_data_ptr = 0;

		do {
			caddr_t	diff;
			caddr_t	diff_end;
			int	size;
			sigset_t
				mask;
		receive:
			Tmk_tout_flag = 0;

			setitimer(ITIMER_REAL, &Tmk_tout, NULL);

			sigio_mutex(SIG_UNBLOCK, &ALRM_and_IO_mask, &mask);
		retry:
			if ((size = recvmsg(req_fd_[preq->to], &rep_hdr, 0)) < 0)
				if (Tmk_tout_flag) {

					if (Tmk_debug)
						Tmk_err("<timeout: %d>Tmk_diff_request: seqno == %d\n", preq->to, preq->seqno);
		rexmit:
					sigio_mutex(SIG_SETMASK, &mask, NULL);

					req_data_ptr = req.data;

					for (i = preq->n; i > preq->i; i--) {

						interval_t	interval = write_[i]->interval;

						int		id = interval->id;

						req_data_ptr[0] = id;
						req_data_ptr[1] = interval->vector_time_[id];
						req_data_ptr += 2;
					}
					req.seqno = preq->seqno;

					if (0 > send(req_fd_[preq->to], (char *)&req, (char *) req_data_ptr - (char *)&req, 0))
						Tmk_perrexit("<send>Tmk_diff_request");

					Tmk_stat.rexmits++;

					goto receive;
				}
				else if (errno == EINTR)
					goto retry;
				else
					Tmk_perrexit("<recvmsg>Tmk_diff_request");

			if (rep_seqno != preq->seqno) {

				if (Tmk_debug)
					Tmk_err("<bad seqno: %d>Tmk_diff_request: seqno == %d (received: %d)\n", preq->to, preq->seqno, rep_seqno);

				/*
				 * If the received seqno is greater than the expected seqno and
				 * the request hasn't been retransmitted, retransmit immediately.
				 * Don't wait for the timeout to retransmit.
				 */
				if (rep_seqno > preq->seqno && req_data_ptr == 0)
					goto rexmit;

				goto retry;
			}
			if (Tmk_debug)
				Tmk_err("size: %d\n", size);

			sigio_mutex(SIG_SETMASK, &mask, NULL);

			req_data_ptr = 0;

			Tmk_stat.messages++;
			Tmk_stat.bytes += size;
			Tmk_stat.bytes_of_data += size -= 4;

			diff = heap_2_brk;

			diff_end = diff + size;

			if ((heap_2_brk = diff_end) >= heap_2_end) {

				heap_t	heap = heap_2_current->next;

				if (heap == 0) {

					heap = heap_expand();

					heap_2_current->next = heap;
				}
				heap_2_ptr_initialize(heap);
			}
			for (;;) {

				write_notice_t	write = write_[preq->n];

				write->diff = diff;

				write->diff_size = (diff = diff_apply(page->vadr, diff)) - write->diff;

				if (write->diff_size >= Tmk_page_size)
					page->proto = single_writer;

				if ((preq->n -= 1) == preq->i)
					break;

				if (diff == diff_end) {

					if ((preq->seqno += SEQNO_INCR) > req_seqno)
						req_seqno = preq->seqno;

					goto receive;
				}
			}

		} while (preq++->i >= 0);
	}
}

/*
 * Called by diff_sigio_handler and interval_incorporate
 *
 * The format of a diff is <size in bytes,starting offset>,word,word, ...
 */
void	Tmk_diff_create(page, write_notice)
	page_t		page;
	write_notice_t	write_notice;
{
	volatile int   *vadr = (volatile int *) page->vadr;
	volatile int   *twin = (volatile int *) page->twin;
	volatile int   *begin = vadr + 1;
	int	       *end = (int *)((caddr_t) vadr + Tmk_page_size);
	unsigned short *start;
	int	       *diff = (int *) heap_1_brk;

#if	defined(__GNUC__) && defined(sparc)
	register	vadr0 asm("l0");
	register	vadr1 asm("l1");
	register	vadr2 asm("l2");
	register	vadr3 asm("l3");
#else
	int		vadr0;
	int		vadr1;
	int		vadr2;
	int		vadr3;
#endif
#if	defined(__GNUC__) && defined(sparc)
	register	twin0 asm("l4");
	register	twin1 asm("l5");
	register	twin2 asm("l6");
	register	twin3 asm("l7");
#else
	int		twin0;
	int		twin1;
	int		twin2;
	int		twin3;
#endif

	write_notice->diff = (caddr_t) diff;

#if	defined(__i386)
	{
		volatile int   *vadr_cur = vadr;

		do
			*vadr_cur;
		while ((vadr_cur += 32/sizeof(*vadr_cur)) < end);
	}
#endif

#if	defined(__i386)
	{
		volatile int   *twin_cur = twin;
		volatile int   *twin_end = (volatile int *)((caddr_t) twin + Tmk_page_size);

		do
			*twin_cur;
		while ((twin_cur += 32/sizeof(*twin_cur)) < twin_end);
	}
#endif
	do {
#if	defined(__GNUC__) && defined(sparc)
		asm ("ldd %2,%0" : "=r" (vadr0), "=r" (vadr1) : "m" (vadr[0]));
		asm ("ldd %2,%0" : "=r" (vadr2), "=r" (vadr3) : "m" (vadr[2]));
#else
		vadr0 = vadr[0];
		vadr1 = vadr[1];
		vadr2 = vadr[2];
		vadr3 = vadr[3];
#endif
		vadr += 4;

#if	defined(__GNUC__) && defined(sparc)
		asm ("ldd %2,%0" : "=r" (twin0), "=r" (twin1) : "m" (twin[0]));
		asm ("ldd %2,%0" : "=r" (twin2), "=r" (twin3) : "m" (twin[2]));
#else
		twin0 = twin[0];
		twin1 = twin[1];
		twin2 = twin[2];
		twin3 = twin[3];
#endif
		twin += 4;

		if (twin0 != vadr0) {

			diff += 2*sizeof(*start)/sizeof(*diff);
			start = (unsigned short *) diff;
			start[-1] = (caddr_t) vadr - (caddr_t)(begin + 3);

			goto diff0;
	same0:
			start[-2] = (caddr_t) diff - (caddr_t) start;
		}
		if (twin1 != vadr1) {

			diff += 2*sizeof(*start)/sizeof(*diff);
			start = (unsigned short *) diff;
			start[-1] = (caddr_t) vadr - (caddr_t)(begin + 2);

			goto diff1;
	same1:
			start[-2] = (caddr_t) diff - (caddr_t) start;
		}
		if (twin2 != vadr2) {

			diff += 2*sizeof(*start)/sizeof(*diff);
			start = (unsigned short *) diff;
			start[-1] = (caddr_t) vadr - (caddr_t)(begin + 1);

			goto diff2;
	same2:
			start[-2] = (caddr_t) diff - (caddr_t) start;
		}
		if (twin3 != vadr3) {

			diff += 2*sizeof(*start)/sizeof(*diff);
			start = (unsigned short *) diff;
			start[-1] = (caddr_t) vadr - (caddr_t) begin;

			goto diff3;
	same3:
			start[-2] = (caddr_t) diff - (caddr_t) start;
		}
	} while (vadr != end);

	goto done;

	do {
#if	defined(__GNUC__) && defined(sparc)
		asm ("ldd %2,%0" : "=r" (vadr0), "=r" (vadr1) : "m" (vadr[0]));
		asm ("ldd %2,%0" : "=r" (vadr2), "=r" (vadr3) : "m" (vadr[2]));
#else
		vadr0 = vadr[0];
		vadr1 = vadr[1];
		vadr2 = vadr[2];
		vadr3 = vadr[3];
#endif
		vadr += 4;

#if	defined(__GNUC__) && defined(sparc)
		asm ("ldd %2,%0" : "=r" (twin0), "=r" (twin1) : "m" (twin[0]));
		asm ("ldd %2,%0" : "=r" (twin2), "=r" (twin3) : "m" (twin[2]));
#else
		twin0 = twin[0];
		twin1 = twin[1];
		twin2 = twin[2];
		twin3 = twin[3];
#endif
		twin += 4;

		if (twin0 == vadr0)
			goto same0;

	diff0:	*diff++ = vadr0;

		if (twin1 == vadr1)
			goto same1;

	diff1:	*diff++ = vadr1;

		if (twin2 == vadr2)
			goto same2;

	diff2:	*diff++ = vadr2;

		if (twin3 == vadr3)
			goto same3;

	diff3:	*diff++ = vadr3;

	} while (vadr != end);

	start[-2] = (caddr_t) diff - (caddr_t) start;
 done:
	*diff++ = 0;

	write_notice->diff_size = (caddr_t) diff - write_notice->diff;

	if (write_notice->diff_size >= Tmk_page_size)
		page->proto = single_writer;

	if ((heap_1_brk = (caddr_t) diff) >= heap_1_end) {

		heap_t	heap = heap_1_current->next;

		if (heap == 0) {

			heap = heap_expand();

			heap_1_current->next = heap;
		}
		heap_1_ptr_initialize(heap);
	}
	Tmk_stat.diffs++;
	Tmk_stat.total_diff_size += write_notice->diff_size;
}

/*
 *
 */
void	Tmk_diff_sigio_handler(req, size)
	struct req_dif *req;
	int		size;
{
static	unsigned	seqno;

static	struct	iovec	iov[MSG_MAXIOVLEN] = { { (caddr_t)&seqno, sizeof(seqno) } };

static	struct	msghdr	hdr = { 0, 0, iov, 0, 0, 0 };

	int		fd = rep_fd_[req->from];

	page_t		page = &page_array_[req->id];

	unsigned short *ptr = req->data;
	unsigned short *end = (unsigned short *)((caddr_t) req + size);

	int		perform_mprotect_and_free = 0;

	int		j = 1;

	seqno = req->seqno;

	size = sizeof(seqno);

	do {
		int		pid = ptr[0];
		int		time = ptr[1];
		write_notice_t	write_notice = page->write_notice_[pid];

		while (write_notice->interval->vector_time_[pid] != time)
			write_notice = write_notice->next;

		if (write_notice->diff == 0) {

			Tmk_diff_create(page, write_notice);

			perform_mprotect_and_free = 1;
		}
		if ((size += write_notice->diff_size) > MTU) {

			hdr.msg_iovlen = j;

			if (0 > sendmsg(fd, &hdr, 0))
				Tmk_perrexit("<sendmsg>diff_sigio_handler");

			j = 1;

			seqno += SEQNO_INCR;

			size = sizeof(seqno) + write_notice->diff_size;
		}
		/*
		 * Account for the seqno that uses entry 0
		 */
		if ((j > 2) && (write_notice->diff == ((caddr_t) iov[j - 1].iov_base + iov[j - 1].iov_len)))
			iov[j - 1].iov_len += write_notice->diff_size;
		else {
			iov[j].iov_base = write_notice->diff;
			iov[j].iov_len  = write_notice->diff_size;

			if ((j += 1) == MSG_MAXIOVLEN) {

				hdr.msg_iovlen = j;

				if (0 > sendmsg(fd, &hdr, 0))
					Tmk_perrexit("<sendmsg>diff_sigio_handler");

				j = 1;

				seqno += SEQNO_INCR;

				size = sizeof(seqno);
			}
		}

	} while ((ptr += 2) < end);

	if (j > 1) {

		hdr.msg_iovlen = j;

		if (0 > sendmsg(fd, &hdr, 0))
			Tmk_perrexit("<sendmsg>diff_sigio_handler");
	}
	if (perform_mprotect_and_free) {

		if (0 > mprotect(page->vadr, Tmk_page_size, PROT_READ))
			Tmk_perrexit("<mprotect>diff_sigio_handler");

		Tmk_free_twin(page);
	}
}

/*
 * Reapply diffs that are more recent than the single-writer copy.
 */
void	Tmk_diff_reapply(page_t page)
{
	int		i, n;
	write_notice_t	write_[NWRITES + 1];

	write_[0] = &Write_notice;

	for (n = i = 0; i < NPROCS; i++) {

		int	j = 0;

		write_notice_t	write_notice = page->write_notice_[i]; 

		while (write_notice) {

			interval_t	interval = write_notice->interval;

			int		k;

			for (k = 0; k < NPROCS; k++)
				if (page->vector_time_[k] < interval->vector_time_[k])
					goto insert;

			break;
		insert:
			if (write_notice->diff) {
		next_j:
				for (k = 0; k < NPROCS; k++)
					if (interval->vector_time_[k] < write_[j]->interval->vector_time_[k]) {
						j++; goto next_j;
					}
				assert(n < NWRITES - 1);

				for (k = n += 1; k > j; k--)
					write_[k] = write_[k - 1];

				write_[k] = write_notice;

				j++;
			}
			write_notice = write_notice->next;
		}
	}
	while (n-- > 0)
		diff_apply(page->vadr, write_[n]->diff);
}

/*
 *
 */
void	Tmk_diff_initialize()
{
	heap_1_ptr_initialize(heap_1_start = heap_expand());

	heap_2_ptr_initialize(heap_2_start = heap_expand());

	req.from = Tmk_proc_id;
}
@


11.10
log
@Use __i386 instead of i386 in diff_apply.

Use sizeof to compute the pointer increment in Tmk_diff_create.
@
text
@d39 1
a39 1
 * $Id: diff.c,v 11.9 1997/08/05 06:54:04 alc Exp alc $
d484 3
d681 3
@


11.9
log
@Added an optimization to Tmk_diff_create for machines with page mode
access memories.  Specifically, preload the cache.
@
text
@d39 1
a39 1
 * $Id: diff.c,v 11.8 1997/08/01 05:46:00 alc Exp alc $
d227 1
a227 1
#if defined(i386)
d547 1
a547 1
		while ((vadr_cur += 8) < end);
d558 1
a558 1
		while ((twin_cur += 8) < twin_end);
@


11.8
log
@Modified diff_apply to preload the diff into the cache on Intel processors,
yielding some speedup due to fast page mode access.
@
text
@d39 1
a39 1
 * $Id: diff.c,v 11.7 1997/07/30 22:32:43 alc Exp alc $
d541 20
@


11.7
log
@Improved diff apply procedure.
@
text
@d39 1
a39 1
 * $Id: diff.c,v 11.6 1997/07/24 19:28:37 alc Exp alc $
d181 5
a185 2
 * Contorted to avoid conflict misses and pipeline stalls.  See Tmk_diff_create
 * for the description of the diff encoding.
d227 9
@


11.6
log
@Eliminated the Ultrix-specific code.  (Identical to revision 10.10.1.1.)
@
text
@d39 1
a39 1
 * $Id: diff.c,v 11.5 1997/07/10 16:21:28 alc Exp alc $
d180 5
a184 3
static	caddr_t	diff_apply(
	caddr_t	page,
	caddr_t	diff)
d186 6
a191 1
	int	t;
d193 2
a194 1
	while (t = *(short *) diff, diff += 2*sizeof(short), t) {
d196 1
a196 2
		int    *pptr = (int *)(page + *(short *)(diff - sizeof(short)));
		int    *eptr = (int *)((caddr_t) pptr + t);
d198 1
a198 1
		if (t & 4) {
d200 1
a200 2
			pptr[0] = *(int *) diff;
			pptr += 1;
d202 1
a202 1
			diff += sizeof(int);
d204 1
a204 1
			if (pptr == eptr)
d206 2
d209 12
a220 3
		do {
			int	diff0 = *(int *) diff;
			int	diff1 = *(int *)(diff + sizeof(int));
d222 3
a224 3
			pptr[0] = diff0;
			pptr[1] = diff1;
			pptr += 2;
d226 13
a238 1
			diff += 2*sizeof(int);
d240 1
a240 1
		} while (pptr != eptr);
d242 1
a242 1
	return diff;
@


11.5
log
@Use the new page states.

Rewrote Tmk_diff_reapply to topologically sort the diffs before applying
them.
@
text
@d39 1
a39 1
 * $Id: diff.c,v 11.4 1997/06/26 22:54:02 alc Exp alc $
a141 1
#if ! defined(ultrix)
a142 1
#endif
d336 1
a336 4
#if defined(ultrix)
			if (0 > write(req_fd_[j], &req, (caddr_t) req_data_ptr - (caddr_t)&req))
				Tmk_perrexit("<write>Tmk_diff_request");
#else
d339 1
a339 1
#endif
a358 3
#if defined(ultrix)
			if ((size = readv(req_fd_[preq->to], rep_iov, sizeof(rep_iov)/sizeof(rep_iov[0]))) < 0)
#else
a359 1
#endif
d380 1
a380 4
#if defined(ultrix)
					if (0 > write(req_fd_[preq->to], &req, (caddr_t) req_data_ptr - (caddr_t)&req))
						Tmk_perrexit("<write>Tmk_diff_request");
#else
d383 1
a383 1
#endif
a390 3
#if defined(ultrix)
					Tmk_perrexit("<readv>Tmk_diff_request");
#else
d392 1
a392 1
#endif
d644 1
a644 1
#if ! defined(ultrix)
d646 1
a646 1
#endif
d677 1
a677 4
#if defined(ultrix)
			if (0 > writev(fd, iov, j))
				Tmk_perrexit("<writev>diff_sigio_handler");
#else
d682 1
a682 1
#endif
d699 1
a699 4
#if defined(ultrix)
				if (0 > writev(fd, iov, j))
					Tmk_perrexit("<writev>diff_sigio_handler");
#else
d704 1
a704 1
#endif
d716 1
a716 4
#if defined(ultrix)
		if (0 > writev(fd, iov, j))
			Tmk_perrexit("<writev>diff_sigio_handler");
#else
a720 1
#endif
@


11.4
log
@Renamed "page->SW_WN_vector_time_" to "page->vector_time_".  Deleted
"page->time".
@
text
@d39 1
a39 1
 * $Id: diff.c,v 11.3 1997/06/26 04:11:44 alc Exp alc $
d218 5
a233 5
static	struct	interval	Interval;
static	struct	write_notice	Write_notice = { 0, 0, 0, &Interval };

#define NWRITES	((MTU - sizeof(struct req_typ))/(2*sizeof(unsigned short)))

a268 2
	page->state = valid;

d757 1
a757 1
 *
d759 1
a759 1
void Tmk_local_diff_check(page_t page)
d761 4
a764 1
	int	i, j;
d766 1
a766 1
	for (j = 0; j < NPROCS; j++) {
d768 1
a768 1
		write_notice_t	local_write_notice = page->write_notice_[j];
d770 1
a770 2
		if ((local_write_notice) &&
		    (local_write_notice->diff)) {
d772 1
a772 2
			for (i = 0; i < NPROCS; i++)
				if (page->vector_time_[i] < local_write_notice->interval->vector_time_[i]) {
d774 1
a774 1
					diff_apply(page->vadr, local_write_notice->diff);
d776 24
a799 2
					return;
				}
d802 2
@


11.3
log
@Fixed the write notice pruning in diff request.

Added Tmk_local_diff_check.  (It needs fixing.  It doesn't apply
all of the diffs.)
@
text
@d39 1
a39 1
 * $Id: diff.c,v 11.2 1997/06/25 18:26:53 alc Exp alc $
d250 1
a250 1
				if (page->SW_WN_vector_time_[k] < interval->vector_time_[k])
d773 1
a773 1
				if (page->SW_WN_vector_time_[i] < local_write_notice->interval->vector_time_[i]) {
@


11.2
log
@Changed "page->owner" -> "page->writer".  Commented out the diff request
pruning: It doesn't work.
@
text
@d39 1
a39 1
 * $Id: diff.c,v 11.1 1997/06/05 22:41:01 alc Exp alc $
d248 6
a253 4
#if 0
			if (interval->vector_time_[page->writer] < page->time)
				break;
#endif
d755 25
@


11.1
log
@Modified Tmk_diff_request to support the adaptive protocol: Prune the list
of write notices that are fetched based upon the interval number at the
last owner.
@
text
@d39 1
a39 1
 * $Id: diff.c,v 10.10 1997/03/16 18:48:52 alc Exp alc $
d248 2
a249 2

			if (interval->vector_time_[page->owner] < page->time)
d251 1
@


10.10
log
@Introduced a cast of the heap iovec because Linux changed the iovec data
pointer to void *.
@
text
@d39 1
a39 1
 * $Id: diff.c,v 10.9 1997/03/09 01:14:53 alc Exp alc $
d248 3
@


10.10.1.1
log
@Eliminated the Ultrix-specific code.
@
text
@d39 1
a39 1
 * $Id: diff.c,v 10.10 1997/03/16 18:48:52 alc Exp alc $
d142 1
d144 1
d334 4
a337 1

d340 1
a340 1

d360 3
d364 1
d385 4
a388 1

d391 1
a391 1

d399 3
d403 1
a403 1

d655 1
a655 1

d657 1
a657 1

d688 4
a691 1

d696 1
a696 1

d713 4
a716 1

d721 1
a721 1

d733 4
a736 1

d741 1
@


10.10.1.2
log
@Added basic Pthreads support.
@
text
@d436 1
a436 3
#if defined(PTHREADS)
				write->diff_size = (diff = diff_apply(page->v_alias, diff)) - write->diff;
#else
d438 1
a438 1
#endif
d649 1
a649 1
#if ! defined(PTHREADS)
d651 1
a651 1
#endif
d667 1
a667 8
#if defined(PTHREADS)
			/*
			 * Prevent further writes by another thread
			 * on this node before diff'ing.
			 */
			if (0 > mprotect(page->vadr, Tmk_page_size, PROT_READ))
				Tmk_perrexit("Tmk_diff_sigio_handler<mprotect>");
#endif
d669 1
a669 3
#if defined(PTHREADS)
			Tmk_free_twin(page);
#else
a670 1
#endif
a717 1
#if ! defined(PTHREADS)
a724 1
#endif
@


10.10.1.3
log
@Improved diff apply procedure.  (Identical to new revision: 11.7.)
@
text
@d39 1
a39 1
 * $Id: diff.c,v 10.10.1.2 1997/07/03 20:48:13 alc Exp alc $
d180 3
a182 5
/*
 * Contorted to avoid conflict misses and pipeline stalls.  See Tmk_diff_create
 * for the description of the diff encoding.
 */
static	caddr_t	diff_apply(caddr_t page, caddr_t diff)
d184 1
a184 6
	short  *diff_cur = (short *) diff;
	short  *diff_run_end;

	int	run_length;

	while ((run_length = *diff_cur), (diff_cur += 2), (run_length > 0)) {
d186 1
a186 2
		int	run_offset = *(diff_cur - 1);
		int    *run_dest_cur = (int *)(page + run_offset);
d188 2
a189 1
		if (run_length & 4) {
d191 1
a191 1
			int	diff0 = *(int *) diff_cur;
d193 2
a194 1
			diff_cur += sizeof(int)/sizeof(*diff_cur);
d196 1
a196 1
			run_dest_cur[0] = diff0;
d198 1
a198 1
			if ((run_length -= 4) == 0)
a199 2

			run_dest_cur++;
d201 3
a203 4
		if (run_length & 8) {

			int	diff0 = *(int *) diff_cur;
			int	diff1 = *(int *)(diff_cur + sizeof(int)/sizeof(*diff_cur));
d205 3
a207 1
			diff_cur += 2*sizeof(int)/sizeof(*diff_cur);
d209 1
a209 23
			run_dest_cur[0] = diff0;
			run_dest_cur[1] = diff1;

			if ((run_length -= 8) == 0)
				continue;

			run_dest_cur += 2;
		}
		diff_run_end = (short *)((caddr_t) diff_cur + run_length);

		do {
			int	diff0 = *(int *) diff_cur;
			int	diff1 = *(int *)(diff_cur + sizeof(int)/sizeof(*diff_cur));
			int	diff2 = *(int *)(diff_cur + 2*sizeof(int)/sizeof(*diff_cur));
			int	diff3 = *(int *)(diff_cur + 3*sizeof(int)/sizeof(*diff_cur));

			diff_cur += 4*sizeof(int)/sizeof(*diff_cur);

			run_dest_cur[0] = diff0;
			run_dest_cur[1] = diff1;
			run_dest_cur[2] = diff2;
			run_dest_cur[3] = diff3;
			run_dest_cur += 4;
d211 1
a211 1
		} while (diff_cur != diff_run_end);
d213 1
a213 1
	return (caddr_t) diff_cur;
@


10.10.1.4
log
@Modified diff_apply to preload the diff into the cache on Intel processors,
yielding some speedup due to fast page mode access.  (Identical
to revision 11.8.)
@
text
@d39 1
a39 1
 * $Id: diff.c,v 10.10.1.3 1997/07/30 22:33:27 alc Exp alc $
d181 2
a182 5
 * Contorted to avoid cache conflict misses and pipeline stalls.  On
 * Intel processors, preload the diff into the cache to take advantage
 * of page mode access.
 *
 * See Tmk_diff_create for the description of the diff encoding.
a223 9
#if defined(i386)
		{
			int	i = 0;

			do
				*(volatile int *)((caddr_t) diff_cur + i);
			while ((i += 32) < run_length);
		}
#endif
@


10.10.1.5
log
@Added an optimization to Tmk_diff_create for machines with page mode
access memories.  Specifically, preload the cache.  (Identical
to revision 11.9.)
@
text
@d39 1
a39 1
 * $Id: diff.c,v 10.10.1.4 1997/08/01 05:52:51 alc Exp alc $
a538 20
#if	defined(__i386)
	{
		volatile int   *vadr_cur = vadr;

		do
			*vadr_cur;
		while ((vadr_cur += 8) < end);
	}
#endif

#if	defined(__i386)
	{
		volatile int   *twin_cur = twin;
		volatile int   *twin_end = (volatile int *)((caddr_t) twin + Tmk_page_size);

		do
			*twin_cur;
		while ((twin_cur += 8) < twin_end);
	}
#endif
@


10.10.1.6
log
@Use __i386 instead of i386 in diff_apply.

Use sizeof to compute the pointer increment in Tmk_diff_create.

(Identical to revision 11.10.)
@
text
@d39 1
a39 1
 * $Id: diff.c,v 10.10.1.5 1997/08/05 06:56:22 alc Exp alc $
d227 1
a227 1
#if defined(__i386)
d545 1
a545 1
		while ((vadr_cur += 32/sizeof(*vadr_cur)) < end);
d556 1
a556 1
		while ((twin_cur += 32/sizeof(*twin_cur)) < twin_end);
@


10.10.1.7
log
@Set the page's state to valid in the segv_handler instead of diff_request
for consistency with version 1.1+.
@
text
@d39 1
a39 1
 * $Id: diff.c,v 10.10.1.6 1997/08/07 17:17:52 alc Exp alc $
d302 2
@


10.10.1.8
log
@Change NPROCS to Tmk_nprocs.
@
text
@d39 1
a39 1
 * $Id: diff.c,v 10.10.1.7 1998/03/02 04:45:00 alc Exp alc $
d278 1
a278 1
	i = 0;
a279 1
	do {
d288 1
a288 3
			k = 0;

			do {
d292 1
a292 1
			} while (++k < Tmk_nprocs);
d301 1
a301 2
	} while (++i < Tmk_nprocs);

d340 1
a340 3
						j = 0;

						do {
a341 1
						} while (++j < Tmk_nprocs);
d352 1
a352 3
					j = 0;

					do {
d360 1
a360 1
					} while (++j < Tmk_nprocs);
@


10.10.1.9
log
@Speedup the check for concurrent write notices in Tmk_diff_request.
@
text
@d39 1
a39 1
 * $Id: diff.c,v 10.10.1.8 1998/03/22 05:52:28 alc Exp alc $
d359 1
a359 1
					j = write_[i]->interval->id;
d361 2
a362 1
					if (write_[dom]->interval->vector_time_[j] < write_[i]->interval->vector_time_[j]) {
d364 2
a365 2
						if (--dom < 0)
							goto xmit;
d367 3
a369 2
						goto redo;
					}
@


10.10.1.10
log
@Speedup the write notice sort in Tmk_diff_request.
@
text
@d39 1
a39 1
 * $Id: diff.c,v 10.10.1.9 1998/04/02 07:21:06 alc Exp alc $
d289 7
a295 1
			k = write_[j]->interval->id;
a296 3
			if (interval->vector_time_[k] < write_[j]->interval->vector_time_[k]) {
				j++; goto next_j;
			}
@


10.10.1.11
log
@Rename "Tmk_free_twin" to "Tmk_twin_free" for consistency
with the rest of the interface.
@
text
@d39 1
a39 1
 * $Id: diff.c,v 10.10.1.10 1998/05/10 04:53:20 alc Exp alc $
d742 1
a742 1
			Tmk_twin_free(page);
d799 1
a799 1
		Tmk_twin_free(page);
@


10.10.1.12
log
@Made a minor optimization to Tmk_diff_request.
@
text
@d39 1
a39 1
 * $Id: diff.c,v 10.10.1.11 1998/05/10 05:06:23 alc Exp alc $
d294 1
a294 4

			k = (n += 1);

			do {
a295 1
			} while (--k > j);
@


10.10.1.13
log
@Add Tmk_errno_check, replacing Tmk_perrexit after send and sendmsg.  It
handles the ENOBUF returned by BSD/OS and FreeBSD.
@
text
@d39 1
a39 1
 * $Id: diff.c,v 10.10.1.12 1998/05/14 03:57:28 alc Exp alc $
d380 2
a381 2
			while (0 > send(req_fd_[j], (char *)&req, (char *) req_data_ptr - (char *)&req, 0))
				Tmk_errno_check("Tmk_diff_request<send>");
d424 2
a425 2
					while (0 > send(req_fd_[preq->to], (char *)&req, (char *) req_data_ptr - (char *)&req, 0))
						Tmk_errno_check("Tmk_diff_request<send>");
d755 2
a756 2
			while (0 > sendmsg(fd, &hdr, 0))
				Tmk_errno_check("Tmk_diff_sigio_handler<sendmsg>");
d777 2
a778 2
				while (0 > sendmsg(fd, &hdr, 0))
					Tmk_errno_check("Tmk_diff_sigio_handler<sendmsg>");
d794 2
a795 2
		while (0 > sendmsg(fd, &hdr, 0))
			Tmk_errno_check("Tmk_diff_sigio_handler<sendmsg>");
@


10.10.1.14
log
@Improved Tmk_diff_create performance on x86 architecture machines
by up to %25.  (I hate machines without registers.)
@
text
@d39 1
a39 1
 * $Id: diff.c,v 10.10.1.13 1998/05/14 20:10:16 alc Exp alc $
a512 5
#if	defined(__GNUC__) && defined(__i386)
	register int   *vadr asm("edi") = (int *) page->vadr;
	register int   *twin asm("esi") = (int *) page->twin;
	int	       *begin = vadr + 1;
#else
a515 1
#endif
d525 1
a525 1
#elif ! defined(__i386)
d536 1
a536 1
#elif ! defined(__i386)
a568 5
#elif	defined(__i386)
#	define	vadr0	vadr[-4]
#	define	vadr1	vadr[-3]
#	define	vadr2	vadr[-2]
#	define	vadr3	vadr[-1]
a579 5
#elif	defined(__i386)
#	define	twin0	twin[-4]
#	define	twin1	twin[-3]
#	define	twin2	twin[-2]
#	define	twin3	twin[-1]
d636 1
a636 1
#elif ! defined(__i386)
d647 1
a647 1
#elif ! defined(__i386)
@


10.10.1.15
log
@Changed defined(sparc) to defined(__sparc).
@
text
@d39 1
a39 1
 * $Id: diff.c,v 10.10.1.14 1998/07/09 06:13:38 alc Exp alc $
d526 1
a526 1
#if	defined(__GNUC__) && defined(__sparc)
d537 1
a537 1
#if	defined(__GNUC__) && defined(__sparc)
d572 1
a572 1
#if	defined(__GNUC__) && defined(__sparc)
d588 1
a588 1
#if	defined(__GNUC__) && defined(__sparc)
d649 1
a649 1
#if	defined(__GNUC__) && defined(__sparc)
d660 1
a660 1
#if	defined(__GNUC__) && defined(__sparc)
@


10.10.1.16
log
@Integrate revisions 10.10.1.15.0.1 through 10.10.1.15.0.3.
@
text
@d39 1
a39 1
 * $Id: diff.c,v 10.10.1.15.0.3 1998/07/17 03:45:30 alc Exp $
d165 1
a165 2
void
Tmk_diff_repo( void )
d175 1
a175 2
int
Tmk_diff_repo_test( void )
d460 1
a460 1
			Tmk_stat.bytes_of_data += size -= sizeof(rep_seqno);
d718 3
a720 4
void
Tmk_diff_sigio_handler(
	const struct req_dif *req,
	int		size)
d827 1
a827 2
void
Tmk_diff_initialize( void )
@


10.10.1.17
log
@Changed the definition of "page_t".  The new definition enables
the use of "const" page pointers.
@
text
@d39 1
a39 1
 * $Id: diff.c,v 10.10.1.16 1998/07/17 05:15:55 alc Exp alc $
d267 2
a268 3
void
Tmk_diff_request(
	const page_t   *page)
d511 3
a513 4
void
Tmk_diff_create(
	const page_t   *page,
	write_notice_t	write_notice)
d733 1
a733 1
	page_t	       *page = &page_array_[req->id];
@


10.10.1.18
log
@Changed the definition of "interval_t".
@
text
@d39 1
a39 1
 * $Id: diff.c,v 10.10.1.17 1998/07/26 05:25:28 alc Exp alc $
d271 1
a271 1
static	interval_t	Interval;
d288 1
a288 1
			interval_t     *interval = write->interval;
d336 1
a336 1
					interval_t     *interval = write_[n]->interval;
d417 1
a417 1
						interval_t     *interval = write_[i]->interval;
@


10.10.1.19
log
@Changed the definition of "write_notice_t".
@
text
@d39 1
a39 1
 * $Id: diff.c,v 10.10.1.18 1998/07/26 06:26:40 alc Exp alc $
d272 1
a272 1
static	write_notice_t	Write_notice = { 0, 0, 0, &Interval };
d277 1
a277 1
	write_notice_t *write_[NWRITES + 1];
d284 1
a284 1
		write_notice_t *write = page->write_notice_[i]; 
d483 1
a483 1
				write_notice_t *write = write_[preq->n];
d515 1
a515 1
	write_notice_t *write_notice)
d751 1
a751 1
		write_notice_t *write_notice = page->write_notice_[pid];
@


10.10.1.20
log
@The Digital Unix compiler would prefer that "ptr" in the diff sigio
handler is defined "const".
@
text
@d39 1
a39 1
 * $Id: diff.c,v 10.10.1.19 1998/07/31 20:17:33 alc Exp alc $
d737 1
a737 2
	const unsigned short
		       *ptr = req->data;
@


10.10.1.15.0.1
log
@Use sizeof(rep_seqno) instead of 4.
@
text
@d39 1
a39 1
 * $Id: diff.c,v 10.10.1.15 1998/07/09 06:18:23 alc Exp alc $
d460 1
a460 1
			Tmk_stat.bytes_of_data += size -= sizeof(rep_seqno);
@


10.10.1.15.0.2
log
@Add void to several function definitions.
@
text
@d39 1
a39 1
 * $Id: diff.c,v 10.10.1.15.0.1 1998/07/17 02:34:14 alc Exp alc $
d165 1
a165 2
void
Tmk_diff_repo( void )
d175 1
a175 2
int
Tmk_diff_repo_test( void )
d827 1
a827 2
void
Tmk_diff_initialize( void )
@


10.10.1.15.0.3
log
@Added the "const" attribute to the sigio handler "req" argument.
@
text
@d39 1
a39 1
 * $Id: diff.c,v 10.10.1.15.0.2 1998/07/17 03:01:09 alc Exp alc $
d720 3
a722 4
void
Tmk_diff_sigio_handler(
	const struct req_dif *req,
	int		size)
@


10.10.1.15.0.4
log
@The Digital Unix compiler would prefer that "ptr" in the diff sigio
handler is defined "const".
(Identical to revision 10.10.1.20.)
@
text
@d39 1
a39 1
 * $Id: diff.c,v 10.10.1.15.0.3 1998/07/17 03:45:30 alc Exp alc $
d735 1
a735 2
	const unsigned short
		       *ptr = req->data;
@


10.9
log
@Added cast to heap_2_brk to pacify compilers on systems that define
iovec's iov_base as void *.
@
text
@d39 1
a39 1
 * $Id: diff.c,v 10.8 1997/03/07 23:47:17 alc Exp alc $
d150 1
a150 1
#	define	heap_2_brk	*(char **const)&rep_iov[1].iov_base
@


10.8
log
@Eliminated tmk_MTU.  This existed because of an Ultrix ATM driver bug.
@
text
@d39 1
a39 1
 * $Id: diff.c,v 10.7 1997/03/07 04:03:58 alc Exp alc $
d150 1
a150 1
#	define	heap_2_brk	rep_iov[1].iov_base
@


10.7
log
@Added cast of iov_base to the diff sigio handler because SGI IRIX 6.2
redefined iov_base as void *.
@
text
@d39 1
a39 1
 * $Id: diff.c,v 10.6 1996/08/25 20:39:36 alc Exp alc $
d687 1
a687 1
		if ((size += write_notice->diff_size) > tmk_MTU) {
@


10.6
log
@Standardize the sigio handler interfaces.  Specifically, eliminate
the "fd" parameter.
@
text
@d39 1
a39 1
 * $Id: diff.c,v 10.5 1996/08/24 21:10:49 alc Exp alc $
d706 1
a706 1
		if ((j > 2) && (write_notice->diff == iov[j - 1].iov_base + iov[j - 1].iov_len))
@


10.5
log
@Replaced sigprocmask by sigio_mutex.  Sigio_mutex is defined
in Tmk.h.
@
text
@d39 1
a39 1
 * $Id: diff.c,v 10.4 1996/08/24 20:01:11 alc Exp alc $
d648 1
a648 2
void	Tmk_diff_sigio_handler(fd, req, size)
	int		fd;
d658 2
@


10.4
log
@Replaced "seqno += NPROCS" by "+= SEQNO_INCR".
@
text
@d39 1
a39 1
 * $Id: diff.c,v 10.3 1996/08/08 18:26:56 alc Exp alc $
d358 1
a358 1
			sigprocmask(SIG_UNBLOCK, &ALRM_and_IO_mask, &mask);
d370 1
a370 1
					sigprocmask(SIG_SETMASK, &mask, NULL);
d422 1
a422 1
			sigprocmask(SIG_SETMASK, &mask, NULL);
@


10.3
log
@Changed page_dirty list and intervals to use ranges.  (Imported
from the 10.1.2 branch.)
@
text
@d39 1
a39 1
 * $Id$
d278 1
a278 1
		req.seqno = req_seqno += NPROCS;
d459 1
a459 1
					if ((preq->seqno += NPROCS) > req_seqno)
d698 1
a698 1
			seqno += NPROCS;
d723 1
a723 1
				seqno += NPROCS;
@


10.2
log
@Replace "page->valid" and "page->empty" with "page->state".
@
text
@d37 4
a40 2
/*****************************************************************************
 * File:		diff.c
d95 1
a95 2
 *
 *****************************************************************************/
d230 1
a230 1
static	struct	write_notice	Write_notice = { 0, 0, 0, 0, 0, &Interval };
d279 3
a281 1
		req.id = write_[--n]->page_id;
@


10.1
log
@Tmk-0.10.1R
@
text
@d262 1
a262 1
	page->valid = 1;
@


10.1.3.1
log
@Tmk-0.10.1.1R: IRIX 6.2 support.
@
text
@d702 1
a702 1
		if ((j > 2) && (write_notice->diff == ((caddr_t) iov[j - 1].iov_base + iov[j - 1].iov_len)))
@


10.1.4.1
log
@MPL Support
@
text
@d355 1
a355 1
			sigio_mutex(SIG_UNBLOCK, &ALRM_and_IO_mask, &mask, UNLOCK);
d367 1
a367 1
					sigio_mutex(SIG_BLOCK, &ALRM_and_IO_mask, NULL, LOCK);
d419 1
a419 1
			sigio_mutex(SIG_SETMASK, &mask, NULL, LOCK);
d448 1
a448 3
#if defined(THREADS)
				write->diff_size = (diff = diff_apply(page->v_alias, diff)) - write->diff;
#else
d450 1
a450 1
#endif
d660 1
a660 1
#if ! defined(THREADS)
d662 1
a662 1
#endif
d678 1
a678 8
#if defined(THREADS)
                        /*
                         * Prevent further writes by another thread
                         * on this node before diff'ing.
                         */
                        if (0 > mprotect(page->vadr, Tmk_page_size, PROT_READ))
                                Tmk_perrexit("<mprotect>diff_sigio_handler");
#endif
d680 1
a680 3
#if defined(THREADS)
			Tmk_free_twin(page);
#else
a681 1
#endif
a738 1
#if ! defined(THREADS)
a745 1
#endif
@


10.1.4.2
log
@Eliminated seqno and extra copying from MPL messages.
@
text
@d277 1
a277 1
		req.seqno = req_seqno += SEQNO_INCR;
d458 1
a458 1
					if ((preq->seqno += SEQNO_INCR) > req_seqno)
d707 1
a707 1
			seqno += SEQNO_INCR;
d732 1
a732 1
				seqno += SEQNO_INCR;
@


10.1.5.1
log
@Start of 0.10.1 THREADS branch. Incorporated alias code from SMP branch.
@
text
@d448 1
a448 3
#if defined(THREADS)
				write->diff_size = (diff = diff_apply(page->v_alias, diff)) - write->diff;
#else
d450 1
a450 1
#endif
d660 1
a660 1
#if ! defined(THREADS)
d662 1
a662 1
#endif
d678 1
a678 8
#if defined(THREADS)
                        /*
                         * Prevent further writes by another thread
                         * on this node before diff'ing.
                         */
                        if (0 > mprotect(page->vadr, Tmk_page_size, PROT_READ))
                                Tmk_perrexit("<mprotect>diff_sigio_handler");
#endif
d680 1
a680 3
#if defined(THREADS)
			Tmk_free_twin(page);
#else
a681 1
#endif
a738 1
#if ! defined(THREADS)
a745 1
#endif
@


10.1.5.2
log
@Added sigio_lock and monitor_lock. Changed segv_handler to avoid race condition.
@
text
@d354 1
a354 3
#if defined(THREADS)
			pthread_mutex_unlock(&sigio_lock);
#endif
d368 1
a368 3
#if defined(THREADS)
					pthread_mutex_lock(&sigio_lock);
#endif
d420 1
a420 3
#if defined(THREADS)
			pthread_mutex_lock(&sigio_lock);
#endif
@


10.1.5.3
log
@Cleaned up sigprocmask/pthread_sigmask/sigthreadmask and sigio
locking/unlocking with sigio_mutex macro
@
text
@d354 4
a357 2

			sigio_mutex(SIG_UNBLOCK, &ALRM_and_IO_mask, &mask, UNLOCK);
d369 4
a372 2
					sigio_mutex(SIG_SETMASK, &mask, NULL, LOCK);

d423 4
a426 2
			sigio_mutex(SIG_SETMASK, &mask, NULL, LOCK);

@


10.1.5.4
log
@cleaned up signal masks
@
text
@d367 1
a367 1
					sigio_mutex(SIG_BLOCK, &ALRM_and_IO_mask, NULL, LOCK);
@


10.1.5.5
log
@Added $Id$
@
text
@a93 1
 * $Id$
@


10.1.5.6
log
@Added (caddr_t) cast to iov.iov_base to conform to new sgi definition
@
text
@d94 1
a94 1
 * $Id: diff.c,v 10.1.5.5 1996/08/07 17:23:37 tmiller Exp tmiller $
d715 1
a715 1
		if ((j > 2) && (write_notice->diff == (caddr_t)iov[j - 1].iov_base + iov[j - 1].iov_len))
@


10.1.2.1
log
@changed page_dirty list and intervals to use ranges
@
text
@d229 1
a229 1
static	struct	write_notice	Write_notice = { 0, 0, 0, 0, &Interval };
@


10.1.2.2
log
@Changed diff request to accomodate the removal of "page_id"
from the write notice structure.
@
text
@d278 1
a278 3
		req.id = page - page_array_;

		--n;
@


10.1.2.3
log
@Corrected the initializer in diff request to account for the removal
of "page_id" from the write notice.
@
text
@d229 1
a229 1
static	struct	write_notice	Write_notice = { 0, 0, 0, &Interval };
@


10.0
log
@POSIX Version
@
text
@d355 1
a355 1
			sigprocmask(SIG_SETMASK, &BUS_or_SEGV_mask, &mask);
@


10.0.3.1
log
@Initial Linux port by Rob Fowler.
@
text
@d431 1
a431 1
			if ((heap_2_brk = diff_end) >= (void *) heap_2_end) {
@


10.0.2.1
log
@Start of the 0.10.1 development branch
@
text
@@


10.0.2.2
log
@Eliminated empty_mask and BUS_or_SEGV_mask.  Use SIG_UNBLOCK instead.
@
text
@d355 1
a355 1
			sigprocmask(SIG_UNBLOCK, &ALRM_and_IO_mask, &mask);
@


10.0.2.2.2.1
log
@Start of the 0.10.1 multiprocessor development branch
@
text
@@


10.0.2.2.2.2
log
@Modified diff request to use the v_alias mapping.
@
text
@d448 1
a448 3
#if defined(__sgi)
				write->diff_size = (diff = diff_apply(page->v_alias, diff)) - write->diff;
#else
d450 1
a450 1
#endif
@


10.0.2.2.2.3
log
@Modified diff sigio handler to perform the mprotect before creating
the diff.
@
text
@d662 1
a662 1
#if ! defined(__sgi)
d664 1
a664 1
#endif
d680 1
a680 8
#if defined(__sgi)
			/*
			 * Prevent further writes by another processor
			 * on this node before diff'ing.  <SMP>
			 */
			if (0 > mprotect(page->vadr, Tmk_page_size, PROT_READ))
				Tmk_perrexit("<mprotect>diff_sigio_handler");
#endif
d682 1
a682 1
#if ! defined(__sgi)
a683 1
#endif
a740 1
#if ! defined(__sgi)
a747 1
#endif
@


10.0.2.2.2.4
log
@Corrected the previous revision.  The call to Tmk_free_twin was
omitted from the diff sigio handler.
@
text
@d689 1
a689 3
#if defined(__sgi)
			Tmk_free_twin(page);
#else
@


10.0.2.2.2.5
log
@Added sigio locking inside existing critical sections (sigprocmask). <SMP>
@
text
@d354 1
a354 3
#if defined(__sgi)
			release_lock(&sigio_lock);	/* SMP */
#endif
d368 1
a368 3
#if defined(__sgi)
					spin_lock(&sigio_lock);	/* SMP */
#endif
d420 1
a420 3
#if defined(__sgi)
			spin_lock(&sigio_lock);	/* SMP */
#endif
@


10.0.1.1
log
@FASTLINK Version
@
text
@@


9.7
log
@Tmk-0.9.7R
@
text
@d3 2
a4 2
 *  Copyright (c) 1991-1994                                                  *
 *  by TreadMarks, L.L.C. (TREADMARKS), Houston, Texas	  		     *
d6 5
a10 5
 *  This software is furnished under a license and may be used and  copied   *
 *  only  in  accordance  with  the  terms  of  such  license and with the   *
 *  inclusion of the above copyright notice.  This software or  any  other   *
 *  copies  thereof may not be provided or otherwise made available to any   *
 *  other person.  No title to or ownership of  the  software  is  hereby    *
d15 2
a16 2
 *  confidential and proprietary to TREADMARKS.  RECIPIENT agrees to take    *
 *  all reasonable steps to safeguard the software, and to prevent its       *
d19 2
a20 2
 *  The information in this software is subject to change  without  notice   *
 *  and should  not  be  construed  as  a commitment by TREADMARKS.	     *
d24 6
a29 7
 *  of merchantability or fitness), with regard to the software.  	     *
 *  TREADMARKS assumes no responsibility for the use or reliability of its   *
 *  software.  TREADMARKS shall not be liable for any special, incidental,   *
 *  or consequential damages, or any damages whatsoever due to causes beyond *
 *  the reasonable control of TREADMARKS, loss of use, data or profits, or   *
 *  from loss or destruction of materials provided to TREADMARKS by	     *
 *  RECIPIENT.								     *
d31 4
a34 4
 *  TREADMARKS's liability for damages arising out of or in connection with  *
 *  the use or performance of this software, whether in an action of	     *
 *  contract or tort including negligence, shall be limited to the purchase  *
 *  price, or the total amount paid by RECIPIENT, whichever is less.	     *
d90 4
d335 1
a335 1
			if (0 > send(req_fd_[j], &req, (caddr_t) req_data_ptr - (caddr_t)&req, 0))
d345 5
a349 3
			caddr_t	diff,	diff_end;

			int	mask,	size;
d355 1
a355 1
			mask = sigsetmask(sigmask(SIGBUS_or_SEGV));
d367 1
a367 1
					sigsetmask(mask);
d386 1
a386 1
					if (0 > send(req_fd_[preq->to], &req, (caddr_t) req_data_ptr - (caddr_t)&req, 0))
d419 1
a419 1
			sigsetmask(mask);
@


9.7.6.1
log
@with newbarrier
@
text
@a421 4

			Tmk_stat.diff_reply++;
			Tmk_stat.diff_reply_bytes += size;

d669 1
a669 6
#if 0
		/* zhenghua's hack*/
		if(!write_notice)
		  return;
#endif
		while ((write_notice->interval->vector_time_[pid] != time)) /* && (write_notice->next != NULL))*/
@


9.7.2.1
log
@Start of the 0.9.8 development branch
@
text
@@


9.6
log
@*** empty log message ***
@
text
@d87 4
d350 1
a350 1
			mask = sigsetmask(sigmask(SIGSEGV));
d652 1
d656 1
a656 1
	int	j = 1;
d658 2
d676 1
a676 4
			if (0 > mprotect(page->vadr, Tmk_page_size, PROT_READ))
				Tmk_perrexit("<mprotect>diff_sigio_handler");

			Tmk_free_twin(page);
d733 7
@


9.6.1.1
log
@FASTLINK Version
@
text
@@


9.5
log
@*** empty log message ***
@
text
@@


9.5.1.1
log
@FASTLINK Version
@
text
@@


9.4
log
@*** empty log message ***
@
text
@@
