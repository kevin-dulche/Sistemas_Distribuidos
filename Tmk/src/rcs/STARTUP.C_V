head	11.17;
access;
symbols
	Tmk-1_0_3_2R:10.19.1.19.0.5
	Tmk-1_0_3_1R:10.19.1.19.0.4
	Tmk-2_0:10.19.1
	Tmk-1_2_TO-2_0_BRANCH_POINT:10.19.1.23
	Tmk-1_0_3R:10.19.1.19.0.2
	Tmk-1_2:10.19.1
	Tmk-1_0_TO-1_2_BRANCH_POINT:10.19.1.19
	Tmk-1_0_1R:10.19.1.12
	Tmk-1_1:11
	Tmk-1_0:10.19.1.19.0
	Tmk-1_0_TO-1_1_BRANCH_POINT:10.19
	Tmk-0_10_1_2R:10.1.3.4
	Tmk-0_10_1_1R:10.1.3.1
	Tmk-0_10_1R:10.1;
locks; strict;
comment	@ * @;


11.17
date	98.05.09.06.12.47;	author alc;	state Exp;
branches;
next	11.16;

11.16
date	98.01.09.22.38.20;	author alc;	state Exp;
branches;
next	11.15;

11.15
date	98.01.07.08.17.24;	author alc;	state Exp;
branches;
next	11.14;

11.14
date	97.12.14.05.58.05;	author alc;	state Exp;
branches;
next	11.13;

11.13
date	97.09.29.18.49.01;	author alc;	state Exp;
branches;
next	11.12;

11.12
date	97.09.26.20.01.40;	author alc;	state Exp;
branches;
next	11.11;

11.11
date	97.09.26.06.10.10;	author alc;	state Exp;
branches;
next	11.10;

11.10
date	97.09.26.05.59.20;	author alc;	state Exp;
branches;
next	11.9;

11.9
date	97.09.03.19.01.00;	author alc;	state Exp;
branches;
next	11.8;

11.8
date	97.07.31.05.17.52;	author alc;	state Exp;
branches;
next	11.7;

11.7
date	97.07.30.02.29.10;	author pparker;	state Exp;
branches;
next	11.6;

11.6
date	97.07.24.06.58.38;	author alc;	state Exp;
branches;
next	11.5;

11.5
date	97.07.24.06.30.45;	author alc;	state Exp;
branches;
next	11.4;

11.4
date	97.06.08.05.33.51;	author alc;	state Exp;
branches;
next	11.3;

11.3
date	97.06.03.20.04.39;	author alc;	state Exp;
branches;
next	11.2;

11.2
date	97.05.27.04.55.30;	author alc;	state Exp;
branches;
next	11.1;

11.1
date	97.05.25.19.18.22;	author alc;	state Exp;
branches;
next	10.19;

10.19
date	97.05.21.05.32.31;	author alc;	state Exp;
branches
	10.19.1.1;
next	10.18;

10.18
date	97.05.09.05.22.59;	author alc;	state Exp;
branches;
next	10.17;

10.17
date	97.03.18.07.22.55;	author alc;	state Exp;
branches;
next	10.16;

10.16
date	97.03.07.03.56.33;	author alc;	state Exp;
branches;
next	10.15;

10.15
date	97.02.21.18.01.52;	author alc;	state Exp;
branches;
next	10.14;

10.14
date	97.01.09.06.20.59;	author alc;	state Exp;
branches;
next	10.13;

10.13
date	96.10.04.23.29.10;	author alc;	state Exp;
branches;
next	10.12;

10.12
date	96.10.03.20.58.40;	author alc;	state Exp;
branches;
next	10.11;

10.11
date	96.10.03.20.27.45;	author alc;	state Exp;
branches;
next	10.10;

10.10
date	96.09.29.20.19.04;	author alc;	state Exp;
branches;
next	10.9;

10.9
date	96.09.25.04.06.51;	author alc;	state Exp;
branches;
next	10.8;

10.8
date	96.08.24.21.10.49;	author alc;	state Exp;
branches;
next	10.7;

10.7
date	96.07.28.20.27.05;	author alc;	state Exp;
branches;
next	10.6;

10.6
date	96.07.26.20.02.39;	author alc;	state Exp;
branches;
next	10.5;

10.5
date	96.07.26.03.57.51;	author alc;	state Exp;
branches;
next	10.4;

10.4
date	96.06.23.17.02.27;	author alc;	state Exp;
branches;
next	10.3;

10.3
date	96.06.23.06.46.01;	author alc;	state Exp;
branches;
next	10.2;

10.2
date	96.06.22.01.11.04;	author alc;	state Exp;
branches;
next	10.1;

10.1
date	96.05.27.04.43.49;	author alc;	state Rel;
branches
	10.1.2.1
	10.1.3.1
	10.1.4.1
	10.1.5.1;
next	10.0;

10.0
date	96.03.15.09.47.40;	author alc;	state Rel;
branches
	10.0.1.1
	10.0.2.1
	10.0.3.1;
next	9.7;

9.7
date	96.03.15.09.39.04;	author alc;	state Rel;
branches
	9.7.2.1
	9.7.6.1;
next	9.6;

9.6
date	96.03.15.09.30.03;	author alc;	state Rel;
branches
	9.6.1.1;
next	9.5;

9.5
date	96.03.15.09.24.56;	author alc;	state Rel;
branches
	9.5.1.1;
next	9.4;

9.4
date	96.03.15.09.20.45;	author alc;	state Rel;
branches;
next	;

9.5.1.1
date	96.03.15.09.27.09;	author alc;	state Rel;
branches;
next	;

9.6.1.1
date	96.03.15.09.32.19;	author alc;	state Rel;
branches;
next	;

9.7.2.1
date	96.03.15.10.01.57;	author alc;	state Exp;
branches;
next	9.7.2.2;

9.7.2.2
date	96.04.12.04.09.11;	author alc;	state Exp;
branches;
next	9.7.2.3;

9.7.2.3
date	96.05.03.03.59.37;	author alc;	state Exp;
branches;
next	9.7.2.4;

9.7.2.4
date	96.05.03.04.16.53;	author alc;	state Exp;
branches;
next	9.7.2.5;

9.7.2.5
date	96.05.03.16.13.41;	author alc;	state Exp;
branches;
next	9.7.2.6;

9.7.2.6
date	96.05.17.02.28.03;	author alc;	state Exp;
branches;
next	;

9.7.6.1
date	96.07.23.18.42.25;	author zhenghua;	state Exp;
branches;
next	;

10.0.1.1
date	96.03.15.09.51.03;	author alc;	state Rel;
branches;
next	;

10.0.2.1
date	96.03.17.18.12.04;	author alc;	state Exp;
branches;
next	10.0.2.2;

10.0.2.2
date	96.03.18.01.23.38;	author alc;	state Exp;
branches;
next	10.0.2.3;

10.0.2.3
date	96.03.21.05.14.00;	author alc;	state Exp;
branches
	10.0.2.3.2.1;
next	10.0.2.4;

10.0.2.4
date	96.04.12.04.15.25;	author alc;	state Exp;
branches;
next	10.0.2.5;

10.0.2.5
date	96.04.22.01.46.15;	author alc;	state Exp;
branches;
next	10.0.2.6;

10.0.2.6
date	96.04.27.21.15.23;	author alc;	state Exp;
branches;
next	10.0.2.7;

10.0.2.7
date	96.05.04.06.34.14;	author alc;	state Exp;
branches;
next	10.0.2.8;

10.0.2.8
date	96.05.17.04.30.33;	author alc;	state Exp;
branches;
next	10.0.2.9;

10.0.2.9
date	96.05.25.17.57.43;	author alc;	state Exp;
branches;
next	10.0.2.10;

10.0.2.10
date	96.05.27.04.20.26;	author alc;	state Exp;
branches;
next	;

10.0.2.3.2.1
date	96.03.25.21.00.30;	author alc;	state Exp;
branches;
next	10.0.2.3.2.2;

10.0.2.3.2.2
date	96.03.30.22.00.52;	author alc;	state Exp;
branches;
next	;

10.0.3.1
date	96.04.22.16.59.08;	author alc;	state Exp;
branches;
next	;

10.1.2.1
date	96.06.25.19.28.51;	author tmiller;	state Exp;
branches;
next	;

10.1.3.1
date	96.11.14.06.25.07;	author alc;	state Rel;
branches;
next	10.1.3.2;

10.1.3.2
date	97.05.10.20.37.32;	author alc;	state Exp;
branches;
next	10.1.3.3;

10.1.3.3
date	97.05.10.23.43.27;	author alc;	state Exp;
branches;
next	10.1.3.4;

10.1.3.4
date	97.05.11.00.06.17;	author alc;	state Rel;
branches;
next	;

10.1.4.1
date	96.07.29.21.09.00;	author rjf;	state Exp;
branches;
next	;

10.1.5.1
date	96.06.27.16.38.16;	author tmiller;	state Exp;
branches;
next	10.1.5.2;

10.1.5.2
date	96.06.27.23.05.15;	author tmiller;	state Exp;
branches;
next	10.1.5.3;

10.1.5.3
date	96.07.02.00.09.02;	author tmiller;	state Exp;
branches;
next	10.1.5.4;

10.1.5.4
date	96.07.02.22.34.57;	author tmiller;	state Exp;
branches;
next	10.1.5.5;

10.1.5.5
date	96.07.02.22.47.18;	author tmiller;	state Exp;
branches;
next	10.1.5.6;

10.1.5.6
date	96.07.03.19.32.35;	author tmiller;	state Exp;
branches;
next	10.1.5.7;

10.1.5.7
date	96.07.03.23.20.36;	author alc;	state Exp;
branches;
next	;

10.19.1.1
date	97.06.02.01.17.28;	author alc;	state Exp;
branches;
next	10.19.1.2;

10.19.1.2
date	97.07.03.19.06.35;	author alc;	state Exp;
branches;
next	10.19.1.3;

10.19.1.3
date	97.07.22.22.50.03;	author alc;	state Exp;
branches;
next	10.19.1.4;

10.19.1.4
date	97.07.23.06.14.57;	author alc;	state Exp;
branches;
next	10.19.1.5;

10.19.1.5
date	97.09.03.19.03.12;	author alc;	state Exp;
branches;
next	10.19.1.6;

10.19.1.6
date	97.09.24.22.44.34;	author alc;	state Exp;
branches;
next	10.19.1.7;

10.19.1.7
date	97.10.01.05.57.31;	author alc;	state Exp;
branches;
next	10.19.1.8;

10.19.1.8
date	97.12.14.06.00.57;	author alc;	state Exp;
branches;
next	10.19.1.9;

10.19.1.9
date	98.01.07.07.27.29;	author alc;	state Exp;
branches;
next	10.19.1.10;

10.19.1.10
date	98.01.07.08.17.59;	author alc;	state Exp;
branches;
next	10.19.1.11;

10.19.1.11
date	98.01.09.22.39.47;	author alc;	state Exp;
branches;
next	10.19.1.12;

10.19.1.12
date	98.01.09.23.00.07;	author alc;	state Exp;
branches;
next	10.19.1.13;

10.19.1.13
date	98.02.18.17.45.46;	author alc;	state Exp;
branches;
next	10.19.1.14;

10.19.1.14
date	98.04.04.20.02.29;	author alc;	state Exp;
branches;
next	10.19.1.15;

10.19.1.15
date	98.05.09.06.18.34;	author alc;	state Exp;
branches;
next	10.19.1.16;

10.19.1.16
date	98.05.09.07.09.50;	author alc;	state Exp;
branches;
next	10.19.1.17;

10.19.1.17
date	98.05.14.20.10.16;	author alc;	state Exp;
branches;
next	10.19.1.18;

10.19.1.18
date	98.06.13.18.39.11;	author alc;	state Exp;
branches;
next	10.19.1.19;

10.19.1.19
date	98.06.22.04.11.21;	author alc;	state Exp;
branches
	10.19.1.19.0.1;
next	10.19.1.20;

10.19.1.20
date	98.07.16.17.54.39;	author alc;	state Exp;
branches;
next	10.19.1.21;

10.19.1.21
date	98.08.06.21.44.04;	author alc;	state Exp;
branches;
next	10.19.1.22;

10.19.1.22
date	98.08.10.19.49.41;	author alc;	state Exp;
branches;
next	10.19.1.23;

10.19.1.23
date	98.08.24.03.06.56;	author alc;	state Exp;
branches;
next	;

10.19.1.19.0.1
date	98.08.06.21.45.53;	author alc;	state Exp;
branches;
next	10.19.1.19.0.2;

10.19.1.19.0.2
date	98.08.06.21.53.54;	author alc;	state Exp;
branches;
next	10.19.1.19.0.3;

10.19.1.19.0.3
date	98.08.12.22.00.35;	author alc;	state Exp;
branches;
next	10.19.1.19.0.4;

10.19.1.19.0.4
date	98.10.11.20.12.48;	author alc;	state Exp;
branches;
next	10.19.1.19.0.5;

10.19.1.19.0.5
date	98.11.02.23.51.00;	author alc;	state Exp;
branches;
next	10.19.1.19.0.6;

10.19.1.19.0.6
date	99.08.03.04.49.49;	author alc;	state Exp;
branches;
next	;


desc
@@


11.17
log
@Added "const" to the Tmk_startup definition.  This is consistent
with getopt.
@
text
@/*****************************************************************************
 *                                                                           *
 *  Copyright (c) 1991-1997						     *
 *  by ParallelTools, L.L.C. (PTOOLS), Houston, Texas			     *
 *                                                                           *
 *  This software is furnished under a license and may be used and copied    *
 *  only in accordance with the terms of such license and with the	     *
 *  inclusion of the above copyright notice.  This software or any other     *
 *  copies thereof may not be provided or otherwise made available to any    *
 *  other person.  No title to or ownership of the software is hereby	     *
 *  transferred.                                                             *
 *									     *
 *  The recipient of this software (RECIPIENT) acknowledges and agrees that  *
 *  the software contains information and trade secrets that are	     *
 *  confidential and proprietary to PTOOLS.  RECIPIENT agrees to take all    *
 *  reasonable steps to safeguard the software, and to prevent its	     *
 *  disclosure.								     * 
 *                                                                           *
 *  The information in this software is subject to change without notice     *
 *  and should not be construed as a commitment by PTOOLS.		     *
 *                                                                           *
 *  This software is furnished AS IS, without warranty of any kind, either   *
 *  express or implied (including, but not limited to, any implied warranty  *
 *  of merchantability or fitness), with regard to the software.  PTOOLS     *
 *  assumes no responsibility for the use or reliability of its software.    *
 *  PTOOLS shall not be liable for any special,	incidental, or		     *
 *  consequential damages, or any damages whatsoever due to causes beyond    *
 *  the reasonable control of PTOOLS, loss of use, data or profits, or from  *
 *  loss or destruction of materials provided to PTOOLS by RECIPIENT.	     *
 *									     *
 *  PTOOLS's liability for damages arising out of or in connection with the  *
 *  use or performance of this software, whether in an action of contract    *
 *  or tort including negligence, shall be limited to the purchase price,    *
 *  or the total amount paid by RECIPIENT, whichever is less.		     *
 *                                                                           *
 *****************************************************************************/

/*
 * $Id: startup.c,v 11.16 1998/01/09 22:38:20 alc Exp alc $
 *
 * Description:    
 *	initialization and cleanup routines
 *
 * External Functions:
 *			Tmk_err,
 *			Tmk_errexit,
 *			Tmk_exit,
 *			Tmk_perrexit,
 *			Tmk_startup
 *
 * External Variables:
 *			Tmk_hostlist
 *			Tmk_proc_id,
 *			Tmk_nprocs
 *
 * Facility:	TreadMarks Distributed Shared Memory System
 * History:
 *	15-Apr-1993	Alan L. Cox	Created
 *	 1-Aug-1993	Alan L. Cox	Added reliable message protocol
 *	 7-Apr-1994	Alan L. Cox	Added X window support for slaves
 *	16-May-1994	Alan L. Cox	Modified Tmk_*err* to use vprintf
 *	 1-Aug-1994	Alan L. Cox	Dynamic port/SAP allocation
 *					 (changes provided by Cristiana Amza)
 *	Version 0.9.1
 *
 *	13-Jan-1995	Alan L. Cox	Additional error reporting
 *					 in start_process
 *	18-Jan-1995	Rob Fowler	Added license expiration code
 *	28-Jan-1995	Alan L. Cox	Modified license expiration code and
 *					 error reporting
 *	Version 0.9.2
 *
 *	18-May-1995	Alan L. Cox	Corrected process creation using rsh
 *	22-May-1995	Alan L. Cox	Added debugger support
 *
 *	Version 0.9.4
 *
 *	15-Jun-1995	Rob Fowler	Added IBM Load Leveler support
 *	 1-Sep-1995	Alan L. Cox	Corrected process limit check under -h
 *
 *	Version 0.9.5
 *
 *	10-Nov-1995	Alan L. Cox	Corrected the change of 1-Sep-1995
 *
 *	Version 0.9.6
 *
 *	20-Jan-1996	Alan L. Cox	Modified (getcwd) to adhere to ANSI C
 *	27-Jan-1996	Alan L. Cox	Replaced sigblock and sigsetmask
 *					 with sigprocmask
 *	Version 0.10
 */
#include "Tmk.h"

#include <net/if.h>

#include <netinet/in.h>

#if ! defined(DAYS_VALID)
#define	DAYS_VALID	10*365	/* ~10 years */
#endif

#include <stdarg.h>

sigset_t	ALRM_and_IO_mask;

unsigned short	proc_vector_time_[NPROCS];

unsigned short	inverse_time_[NPROCS];

struct	Tmk	tmk_ = { /*proc_id=*/0, /*nprocs=*/0, /*page_size=*/0, /*npages=*/NPAGES };

unsigned	Tmk_spinmask;

int		Tmk_debug;

/*
 * How many hosts did the user specify with -h ?
 */
int             Tmk_nhosts_listed_cmdline;

char		Tmk_hostlist[NPROCS][MAXHOSTNAMELEN];

void	Tmk_err(char *format, ...)
{
	va_list args;

	va_start(args, format);
	vfprintf(stderr, format, args);
	va_end(args);

	fflush(stderr);
}

void	Tmk_errexit(char *format, ...)
{
	va_list args;

	va_start(args, format);
	vfprintf(stderr, format, args);
	va_end(args);

	exit(-1);
}

#if defined(__hpux)
int	h_errno;
#endif
#if ! (defined(__bsdi) || defined(__FreeBSD__) || defined(__sgi))
char   *h_errlist[] = {
	"Resolver Error 0 (no error)",
	"Unknown host",				/* 1 HOST_NOT_FOUND */
	"Host name lookup failure",		/* 2 TRY_AGAIN */
	"Unknown server error",			/* 3 NO_RECOVERY */
	"No address associated with name",	/* 4 NO_ADDRESS */
	"Service unavailable",	/* AIX 4.1 */	/* 5 SERVICE_UNAVAILABLE */
	NULL
};

/*
 * h_errno is thread safe under AIX 4.1 and DEC UNIX 3.2C, but not Solaris 2.5
 */
void	herror(const char *string)
{
	fprintf(stderr, "%s: %s\n", string, h_errlist[h_errno]);
}
#endif

/*
 * This function is called if gethostbyname fails.
 */
void	Tmk_herrexit(char *format, ...)
{
	va_list args;
	char	string[257];

	va_start(args, format);
	vsprintf(string, format, args);
	va_end(args);

	herror(string);

	exit(-1);
}

void	Tmk_perrexit(char *format, ...)
{
	va_list args;
	char	string[257];

	va_start(args, format);
	vsprintf(string, format, args);
	va_end(args);
	
	perror(string);

	exit(-1);
}

#if defined(__GNUC__)
/*
 * This function is called by the `assert' macro provided with gcc.
 */
void	__eprintf(string, expression, line, filename)
	const char     *string;
	const char     *expression;
	unsigned	line;
	const char     *filename;
{
	fprintf(stderr, string, expression, line, filename);
	fflush(stderr);
	abort();
}
#endif

/*
 * Points to the string that is bound to the environment variable DEBUGGER.
 */
static  char   *debugger;

/*
 * Points to the string that is bound to the environment variable DISPLAY.
 */
static	char   *display;

#if defined(LoadL)
/*
 * Is this an IBM LoadLeveler job?
 */
static	int	ll_job = 0;

#include <llapi.h>

static	struct JM_JOB_INFO job_request;

#endif

/*
 * Does the user have a .netrc file?
 */
static	int	netrc_found = 0;

#if !defined(MPL)
/*
 * Allow 30 seconds for the remote process to contact the manager.
 */
static	struct	timeval	timeout = { 30, 0 };

/*
 * Code that doesn't work with the ATM network isn't compiled under Ultrix.
 */
void	Tmk_start_process(i, argc, argv)
	int	i;
	int	argc;
	char   *argv[];
{
	char   *ptr;
	char	pathname[MAXPATHLEN];
	char	string[MAXPATHLEN];
	char   *sptr = string;
	char	arguments[MAXPATHLEN];
	int	j;
	int	flag = 0;
	char   *hostname = Tmk_hostlist[i];
	int	fd;
	int	fd2p;
	FILE   *fp2;
	fd_set	fds;
	int	maxfdp1;
	sigset_t
		mask;

	sigio_mutex(SIG_BLOCK, &ALRM_and_IO_mask, &mask);

	if ((ptr = getenv("PWD")) == 0)
		if ((ptr = getcwd(pathname, MAXPATHLEN)) == 0)
			Tmk_errexit("Tmk_start_process<getwd>: %s\n", ptr);

	sprintf(string, "cd %s ; ", ptr);

	if (display)
		sprintf(string, "%sxterm -display %s -name %s -title %s -e ", string, display, hostname, hostname);

	if (debugger) {

		sprintf(string, "%s%s %s", string, debugger, argv[0]);

		sptr = arguments;
		sptr[0] = 0;
	}
	for (j = 0; j < argc; j++) {

		if (0 == strcmp(argv[j], "--"))
			flag = 1;

		sprintf(sptr, "%s%s ", sptr, argv[j]);
	}
	if (flag)
		sprintf(sptr, "%s-i%d -m%ld", sptr, i, page_array_[0].vadr);
	else
		sprintf(sptr, "%s-- -i%d -m%ld", sptr, i, page_array_[0].vadr);
#if defined(LoadL)
	if (ll_job)
		for (j = 0; j < Tmk_nprocs; j++)
			sprintf(sptr, "%s -h%s", sptr, Tmk_hostlist[j]);
#endif
	for (j = 0; j < i; j++)
		sprintf(sptr, "%s -p%d", sptr, Tmk_port_[j][i]);

	if (debugger)
		printf("Arguments: %s\n", sptr);

	if (Tmk_debug)
		Tmk_err("%s\n", string);
#if defined(LoadL)
	if (ll_job) {

		char	command[MAXPATHLEN];

		sprintf(command, "/bin/sh -c \"%s\"", string);

		if ((fd2p = ll_start_host(hostname, command)) < 0)
			Tmk_ll_errexit(fd2p);

		fp2 = fdopen(fd2p, "r");
	}
	else	/*  Danger!   Dangling "else".  */
#endif
	if (netrc_found) {

		if ((fd = rexec(&hostname, getservbyname("exec", "tcp")->s_port, NULL, NULL, string, &fd2p)) < 0)
			Tmk_errexit("Tmk_startup: process creation failed on %s.\n", hostname);

		fp2 = fdopen(fd2p, "r");
	}
	else {
		char	command[MAXPATHLEN];
#if ! defined(__hpux)
		sprintf(command, "rsh %s -n \"%s\"", hostname, string);
#else
		sprintf(command, "remsh %s -n \"%s\"", hostname, string);
#endif
		if ((fp2 = popen(command, "r")) == NULL)
			Tmk_perrexit("popen");

		fd2p = fileno(fp2);
	}
	FD_ZERO(&fds);

	FD_SET(fd2p, &fds);

	for (maxfdp1 = MAX(fd2p + 1, rep_fd_[i] + 1);;) {

		fd_set	fds_tmp, fds_exc;
# if defined(__linux)
		struct	timeval	timeout_tmp;

		timeout_tmp = timeout;
# endif
		fds_tmp = fds;

		FD_SET(rep_fd_[i], &fds_tmp);

		FD_ZERO(&fds_exc);

		FD_SET(rep_fd_[i], &fds_exc);
# if defined(__linux)
		if ((flag = select(maxfdp1, (fd_set_t)&fds_tmp, NULL, (fd_set_t)&fds_exc, &timeout_tmp)) < 0)
# else
		if ((flag = select(maxfdp1, (fd_set_t)&fds_tmp, NULL, (fd_set_t)&fds_exc, &timeout)) < 0)
# endif
			Tmk_perrexit("select");

		if (flag == 0)
			Tmk_errexit("Tmk_startup: process creation failed on %s.\n", hostname);

		if (FD_ISSET(fd2p, &fds_tmp))
			if (string == fgets(string, sizeof(string), fp2))
				Tmk_err("from %s: %s", hostname, string);
			else
				FD_CLR(fd2p, &fds);
		else {
			assert(FD_ISSET(rep_fd_[i], &fds_tmp) || FD_ISSET(rep_fd_[i], &fds_exc));

			break;
		}
	}
#if  defined(LoadL)
	if (netrc_found && ! ll_job)
#else
	if (netrc_found)
#endif
		close(fd);
# if ! defined(__linux)
	fclose(fp2);
# endif
	sigio_mutex(SIG_SETMASK, &mask, NULL);

	Tmk_err("[ Tmk: %s started ]\n", hostname);
}

/*
 * Obtain the list of network interfaces attached to this host,
 * including their associated IP addresses.  Obtain the IP address of 
 * Tmk_hostlist[Tmk_proc_id] and search for a match among the network
 * interfaces.  Exit if a match isn't found.  Otherwise, return.
 */
static	void	test_hostlist( void )
{
	char		buf[1024];

	struct	ifconf	ifconf;
	struct	ifreq  *ifreq;

	struct hostent *hp;

	int		dummy_s;

	if ((dummy_s = socket(PF_INET, SOCK_DGRAM, 0)) < 0)
		Tmk_perrexit("<socket>Tmk_startup");

	ifconf.ifc_buf = buf;
	ifconf.ifc_len = sizeof(buf);

	if (0 > ioctl(dummy_s, SIOCGIFCONF, (char *)&ifconf))
		Tmk_perrexit("<ioctl>Tmk_startup");

	if (0 > close(dummy_s))
		Tmk_perrexit("<close>Tmk_startup");

	if ((hp = gethostbyname(Tmk_hostlist[Tmk_proc_id])) == NULL)
		Tmk_herrexit("Tmk_startup: %s", Tmk_hostlist[Tmk_proc_id]);

	assert(hp->h_addrtype == AF_INET);

	ifreq = ifconf.ifc_req;

	while (ifreq < (struct ifreq *)(ifconf.ifc_buf + ifconf.ifc_len)) {

		if (ifreq->ifr_addr.sa_family == AF_INET)
			if (0 == memcmp(&((struct sockaddr_in *)&ifreq->ifr_addr)->sin_addr, hp->h_addr, hp->h_length))
				return;

#if defined(_AIX) || defined(__bsdi) || defined(__FreeBSD__)
	        ifreq = (struct ifreq *)((caddr_t) ifreq + sizeof(ifreq->ifr_name) + ifreq->ifr_addr.sa_len);
#else
		ifreq++;
#endif
	}
	Tmk_errexit("Tmk_startup: this host isn't %s.  Please change your host list.\n", Tmk_hostlist[Tmk_proc_id]);
}
#endif /* !defined(MPL) */

/*
 * Used by the exit handler
 */
static	void	int_handler(int signo)
{
}

/*
 * Called by atexit (or on_exit)
 */
#if defined(__sun) && ! defined(__SVR4)
static	void	exit_handler(status, arg)
	int	status;
	caddr_t	arg;
#else
static	void	exit_handler( void )
#endif
{
	if (display && Tmk_proc_id) {

		struct	sigaction sa;
		struct	sigaction sa_old;

		Tmk_err("[ Tmk: to exit type ^C (SIGINT) ]\n");

		sa.sa_flags = 0;
		sa.sa_handler = int_handler;

		sigemptyset(&sa.sa_mask);

		sigaction(SIGINT, &sa, &sa_old);

		sigsuspend(&ALRM_and_IO_mask);

		sigaction(SIGINT, &sa_old, NULL);
	}
}

/*
 *
 */
void
Tmk_startup(
	int		argc,
	char   * const *argv)
{
	char   *cp = 0;
extern	char   *optarg;
extern	int	optind;
	char	filename[MAXPATHLEN];
	time_t	timestamp = TIMESTAMP;
	struct	timeval	now;
	int	c, i = 0, j = 0;
extern	int	end;
#if  defined(LoadL)
static	char   *ll_bad_option = "Tmk_startup: the \"%s\" option is not allowed under LoadLeveler.\n";
#endif
	FILE   *fp;

#if defined(__sun) && ! defined(__SVR4)
	if (on_exit(exit_handler, NULL))
		Tmk_err("Unable to register handler with \"on_exit\"\n");
#else
	if (0 > atexit(exit_handler))
		perror("Unable to register handler with \"atexit\"");
#endif
	while ((c = getopt(argc, argv, "D:df:h:I:i:m:n:P:p:rSstvW:X:x")) != -1)
		switch (c) {
		case '?':
			exit(-1);
	        case 'D':
			Tmk_err("Warning: \"-D\" is obsolete.\n");
			continue;
		case 'd':
			if ((debugger = getenv("DEBUGGER")) == 0)
				Tmk_errexit("Tmk_startup: DEBUGGER=(null)\n");
			goto get_display;
		case 'f':
			cp = optarg;
			continue;
		case 'h':
			strcpy(Tmk_hostlist[i], optarg); i++;
			continue;
	        case 'I':
			Tmk_err("Warning: \"-I\" is obsolete.\n");
			continue;
		case 'i':
			Tmk_proc_id = atoi(optarg);
			continue;
		case 'm':
			page_array_[0].vadr = (caddr_t) atol(optarg);
			continue;
		case 'n':
			if ((Tmk_nprocs = atoi(optarg)) > NPROCS)
				Tmk_errexit("Tmk_startup: -n%d exceeds the %d-process limit.\n", Tmk_nprocs, NPROCS);
			else if (Tmk_nprocs == 0)
				Tmk_errexit("Tmk_startup: \"%s\" is an invalid argument for -n.\n", optarg);
			continue;
		case 'P':
			if ((Tmk_npages = atoi(optarg)) > NPAGES)
				Tmk_errexit("Tmk_startup: -P%d exceeds the %d-page limit.\n", Tmk_npages, NPAGES);
			continue;
		case 'p':
			Tmk_port_[j][Tmk_proc_id] = atoi(optarg); j++;
			continue;
		case 'r':
			netrc_found = 1;
			continue;
		case 'S':
			tmk_stat_flag = 2;
			continue;
		case 's':
			tmk_stat_flag = 1;
			continue;
		case 't':
			Tmk_debug = 1;
			continue;
		case 'v':
			Tmk_page_init_to_valid = 1;
			continue;
		case 'W':
			switch (*optarg) {
			case 'm':
				Tmk_page_init_proto = multiple_writer;
				break;
			case 's':
				Tmk_page_init_proto = single_writer;
				break;
			default:
				break;
			}
			continue;
		case 'x':
		get_display:
			if ((display = getenv("DISPLAY")) == 0)
				Tmk_errexit("Tmk_startup: DISPLAY=(null)\n");
			continue;
		case 'X':
			if ((page_shift = atoi(optarg)) > 3)
				Tmk_errexit("Tmk_startup: -X%d exceeds the maximum page size.\n", page_shift);
			continue;
		}

	if (optind < argc)
		Tmk_errexit("Tmk_startup: \"%s\" is an invalid argument.\n", argv[optind]);

	Tmk_nhosts_listed_cmdline = i;

	if (Tmk_nhosts_listed_cmdline > Tmk_nprocs)
		Tmk_nprocs = Tmk_nhosts_listed_cmdline;
#if defined(LoadL)
	if (Tmk_proc_id == 0 && getenv("LOADL_ACTIVE")) {

		if (debugger)
			Tmk_errexit(ll_bad_option, "-d");

		if (display)
			Tmk_errexit(ll_bad_option, "-x");

		if ((c = ll_get_hostlist(&job_request)) < 0)
			Tmk_ll_errexit(c);

		if (Tmk_nprocs)
			Tmk_errexit(ll_bad_option, "-n");

		Tmk_nprocs = job_request.jm_min_num_nodes;

		if (Tmk_nprocs > NPROCS) 
			Tmk_errexit("Tmk_startup: the LoadLeveler allocation, %d, exceeds the %d-process limit.\n", Tmk_nprocs, NPROCS);
	    
		if (i)
			Tmk_errexit(ll_bad_option, "-h");

		for ( ; i < Tmk_nprocs; i++) {

			struct in_addr	addr;
			struct hostent *host;

			addr.s_addr = inet_addr(job_request.jm_min_node_info[i].jm_node_address);

			if ((host = gethostbyaddr((char *)&addr, sizeof(addr), AF_INET)) == 0)
				Tmk_perrexit("Tmk_startup: gethostbyaddr");

			strcpy(Tmk_hostlist[i], host->h_name);
		}
		ll_job = 1;
	}
#elif defined(MPL)
	if (i > 0)
		Tmk_errexit("Tmk_startup: the \"-h\" option is not allowed under MPL.\n");

	if (0 > mpc_environ(&i, (int *)&Tmk_proc_id))
		Tmk_MPLerrexit("<mpc_environ>Tmk_startup");
#endif
	if (i == 0) {

		/*
		 * Neither LoadLeveler nor "-h" were used.  (Under LoadLeveler slaves
		 * always receive the "-h" option from the master.)
		 */
		if (cp == 0)
			sprintf(cp = filename, "%s/.Tmkrc", getenv("HOME"));

		if ((fp = fopen(cp, "r")) == 0)
			Tmk_perrexit(cp);

		if (0 < Tmk_nprocs)
			j = Tmk_nprocs;
		else
			j = NPROCS + 1;

		for (i = 0; i < j; i++)
			switch (fscanf(fp, "%s\n", Tmk_hostlist[i])) {
			case 0:
				Tmk_errexit("Tmk_startup: %s is improperly formatted.\n", cp);
			case EOF:
				goto escape;
			default:
				continue;
			}
	escape:
		fclose(fp);
	}
	else {
		if (cp)
#if defined(LoadL)
			if (ll_job)
				Tmk_errexit(ll_bad_option, "-f");
			else	/*  Danger!   Dangling "else".  */
#endif
			Tmk_errexit("Tmk_startup: the \"-f\" and \"-h\" options are incompatible\n");

		cp = "command line";
	}
	if (0 > gettimeofday(&now, NULL))
		Tmk_perrexit("Tmk_startup: gettimeofday");

	if (i > NPROCS)
		Tmk_errexit("Tmk_startup: %s exceeds the %d-process limit.\n", cp, NPROCS);
	else if (i < Tmk_nprocs)
		Tmk_errexit("Tmk_startup: %s contains less than %d host(s).\n", cp, Tmk_nprocs);
	else if (Tmk_nprocs == 0)
		Tmk_nprocs = i;
	else if (i > Tmk_nprocs) {

		Tmk_err("Tmk_startup: %s contains %d host(s), using the first %d.\n", cp, i, Tmk_nprocs);

		i = Tmk_nprocs;
	}
#if ! defined(MPL)
	test_hostlist();
#endif
	if (now.tv_sec > TIMESTAMP + DAYS_VALID*24*3600)
		Tmk_nprocs = 1;

	/*
	 * This abomination is necessary to handle Tmk_nprocs == 32.
	 */
	Tmk_spinmask  = ((1 << (Tmk_nprocs - 1)) << 1) - 1;
	Tmk_spinmask &= ~(1 << Tmk_proc_id);

	sigemptyset(&ALRM_and_IO_mask);
	sigaddset(&ALRM_and_IO_mask, SIGALRM);
	sigaddset(&ALRM_and_IO_mask, SIGIO);

	Tmk_page_initialize();

	Tmk_interval_initialize();

	Tmk_diff_initialize();

	Tmk_repo_initialize();

	Tmk_segv_initialize();

	Tmk_distribute_initialize();

	Tmk_barrier_initialize();

	Tmk_lock_initialize();

	Tmk_sched_initialize();

	Tmk_ownership_initialize();
#if !defined(MPL)
	Tmk_spawn_initialize();

	Tmk_tout_initialize();
#endif
	Tmk_sigio_initialize();
#if !defined(MPL)
	if (Tmk_proc_id) {

		if (display == 0) {

			close(0);
			close(1);

			open("/dev/null", O_RDONLY, 0);
			open("/dev/null", O_WRONLY, 0);

			dup2(1, 2);
		}
	}
	else if (netrc_found == 0) {

		int	fd;

		sprintf(filename, "%s/.netrc", getenv("HOME"));

		if ((fd = open(filename, O_RDONLY, 0)) != -1) {

			close(fd);

			netrc_found = 1;
		}
	}
#endif
	Tmk_err("TreadMarks Version 1.1.0-ALPHA of %s"
#if DAYS_VALID < 32
		"Copyright (c) ParallelTools, L.L.C., 1991-1997\n"
		"\n"
		"\tUSE OF THIS DEMONSTRATION COPY OF TREADMARKS IS SUBJECT TO THE TERMS\n"
		"\tAND CONDITIONS OF THE LICENSE AGREEMENT INCLUDED WITH THIS SOFTWARE.\n"
		"\n",
#else
		"Copyright (c) ParallelTools, L.L.C., 1991-1997\n",
#endif
		ctime(&timestamp));

	if (i != Tmk_nprocs) {

		Tmk_err("\007\n"
			"\tYour license has expired.  This program will execute sequentially.\n"
			"\n"
			"\tPlease contact ParallelTools, L.L.C.\n"
			"\n");

		sleep(5);
	}
	for (i = 0; i < Tmk_nprocs; i++) {
		if (i == Tmk_proc_id)
			continue;

		Tmk_accept_initialize(i);
	}
	Tmk_connect_initialize();

#if ! defined(MPL)
	for (i = 0; i < Tmk_proc_id; i++) {

		Tmk_connect(i);

		Tmk_accept(i);
	}
	for (i += 1; i < Tmk_nprocs; i++) {

		if (Tmk_proc_id == 0)
			Tmk_start_process(i, argc, argv);

		Tmk_accept(i);

		Tmk_connect(i);
	}
#endif
}
@


11.16
log
@Eliminate Tmk_heap_initialize.  Initialize the heap
during the first call to Tmk_malloc, Tmk_free, or Tmk_sbrk.
@
text
@d39 1
a39 1
 * $Id: startup.c,v 11.15 1998/01/07 08:17:24 alc Exp alc $
d494 4
a497 3
void	Tmk_startup(argc, argv)
	int	argc;
	char   *argv[];
@


11.15
log
@Changed the Tmk_spinmask construction to work if Tmk_nprocs == 32.
@
text
@d39 1
a39 1
 * $Id: startup.c,v 11.14 1997/12/14 05:58:05 alc Exp alc $
a741 3

	if (page_array_[0].vadr >= (caddr_t)&end)
		Tmk_heap_initialize();
@


11.14
log
@Define "h_errno" on HP-UX 10.0.

"h_errlist" and "herror" are provided by IRIX 6.2.  Don't
redefine them.
@
text
@d39 1
a39 1
 * $Id: startup.c,v 11.13 1997/09/29 18:49:01 alc Exp alc $
d707 5
a711 1
	Tmk_spinmask = ((1 << Tmk_nprocs) - 1) &~ (1 << Tmk_proc_id);
@


11.13
log
@Added the "-P" option to set the number of shared pages at startup.

Swapped "x" and "X" in the getopt string for consistency
with the other options.
@
text
@d39 1
a39 1
 * $Id: startup.c,v 11.12 1997/09/26 20:01:40 alc Exp alc $
d145 4
a148 1
#if ! (defined(__bsdi) || defined(__FreeBSD__))
@


11.12
log
@MPL-specific change: Tmk_spawn isn't supported under MPL.
@
text
@d39 1
a39 1
 * $Id: startup.c,v 11.11 1997/09/26 06:10:10 alc Exp alc $
d515 1
a515 1
	while ((c = getopt(argc, argv, "D:df:h:I:i:m:n:p:rSstvW:xX:")) != -1)
d546 4
@


11.11
log
@Fixed an MPL-specific problem in Tmk_startup: Tmk_heap_initialize
wasn't called (when appropriate).  Reported by Y. Charlie Hu.
(Identical to revision 10.19.1.6.)
@
text
@d39 1
a39 1
 * $Id: startup.c,v 11.10 1997/09/26 05:59:20 alc Exp alc $
d725 2
a727 2
	Tmk_spawn_initialize();
#if !defined(MPL)
@


11.10
log
@Added Tmk_page_init_proto: a single-writer/multiple-writer protocol
switch.

The initial protocol is set by the "-W" command-line option.  "-Wm"
sets the initial protocol to multiple-writer, and "-Ws" sets the
initial protocol to single-writer.
@
text
@d39 1
a39 1
 * $Id: startup.c,v 11.9 1997/09/03 19:01:00 alc Exp alc $
d731 1
a731 1
#if !defined(MPL)
d734 1
a734 1

@


11.9
log
@BSD/OS-specific changes.  Identical to FreeBSD.
@
text
@d39 1
a39 1
 * $Id: startup.c,v 11.8 1997/07/31 05:17:52 alc Exp alc $
d515 1
a515 1
	while ((c = getopt(argc, argv, "D:df:h:I:i:m:n:p:rSstvxX:")) != -1)
d564 12
@


11.8
log
@Moved the Tmk_nhosts_listed_cmdline definition to the neighborhood
of Tmk_hostlist.

Don't increment Tmk_nhosts_listed_cmdline for each host.  Wait until
after command line option processing and assign the total kept in i.
@
text
@d39 1
a39 1
 * $Id: startup.c,v 11.7 1997/07/30 02:29:10 pparker Exp alc $
d145 1
a145 1
#if ! defined(__FreeBSD__)
d440 1
a440 1
#if defined(_AIX) || defined(__FreeBSD__)
@


11.7
log
@Fixed Tmk_nprocs and -h addition for spawn
@
text
@d39 1
a39 1
 * $Id: startup.c,v 11.6 1997/07/24 06:58:38 alc Exp $
d116 5
a238 5
/*
 * How many hosts did the user specify with -h ?
 */
int             Tmk_nhosts_listed_cmdline = 0;

a530 1
			Tmk_nhosts_listed_cmdline++;
d576 5
a582 3
	
	if (optind < argc)
		Tmk_errexit("Tmk_startup: \"%s\" is an invalid argument.\n", argv[optind]);
@


11.6
log
@Added the "-S" option for reporting per processor statistics.  (Identical
to revision 10.19.1.4.)
@
text
@d39 1
a39 1
 * $Id: startup.c,v 11.5 1997/07/24 06:30:45 alc Exp alc $
d234 5
d531 1
d577 3
@


11.5
log
@Eliminated the Ultrix-specific code.  (Identical to revision 10.19.1.2.)
@
text
@d39 1
a39 1
 * $Id: startup.c,v 11.4 1997/06/08 05:33:51 alc Exp alc $
d510 1
a510 1
	while ((c = getopt(argc, argv, "D:df:h:I:i:m:n:p:rstvxX:")) != -1)
d547 3
@


11.4
log
@Call Tmk_ownership_initialize from Tmk_startup.
@
text
@d39 1
a39 1
 * $Id: startup.c,v 11.3 1997/06/03 20:04:39 alc Exp alc $
a237 1
#if !defined(ultrix)
a238 1
#endif
a256 1
#if !defined(ultrix)
a260 1
#endif
a305 2
#if ! defined(ultrix)

a387 4
#else
	if ((fd = rexec(&hostname, getservbyname("exec", "tcp")->s_port, NULL, NULL, string, NULL)) < 0)
		Tmk_errexit("Tmk_startup: process creation failed on %s.\n", hostname);
#endif
@


11.3
log
@Changed the Fortran API to use a common block to hold the proc_id,
nprocs, page_size and npages.  Dropped the trailing "_" from
struct Tmk_, and added page_size and npages.  (Identical to
revision 10.19.1.1.)
@
text
@d39 1
a39 1
 * $Id: startup.c,v 11.2 1997/05/27 04:55:30 alc Exp alc $
d708 2
@


11.2
log
@Added support for Tmk_spawn: Made the static start_process into the extern
Tmk_start_process.  Added the extern Tmk_spinmask.  Called
Tmk_spawn_initialize.
@
text
@d39 1
a39 1
 * $Id: startup.c,v 11.1 1997/05/25 19:18:22 alc Exp alc $
d110 1
a110 1
struct	Tmk_	Tmk_;
@


11.1
log
@Updated the version number.
@
text
@d39 1
a39 1
 * $Id: startup.c,v 10.19 1997/05/21 05:32:31 alc Exp alc $
d112 2
d245 1
a245 1
static	void	start_process(i, argc, argv)
d272 1
a272 1
			Tmk_errexit("<getwd>start_process: %s\n", ptr);
d685 2
d708 2
d785 1
a785 1
			start_process(i, argc, argv);
@


10.19
log
@Eliminated Tmk_monitor_initialize.  The condition variable functions
were merged into lock.c.  Tmk_lock_initialize subsumes
Tmk_monitor_initialize.
@
text
@d3 1
a3 1
 *  Copyright (c) 1991-1996						     *
d39 1
a39 1
 * $Id: startup.c,v 10.18 1997/05/09 05:22:59 alc Exp alc $
d739 1
a739 1
	Tmk_err("TreadMarks Version 1.0.0-BETA of %s"
@


10.19.1.1
log
@Changed the Fortran API to use a common block to hold the proc_id,
nprocs, page_size and npages.  Dropped the trailing "_" from
struct Tmk_, and added page_size and npages.
@
text
@d39 1
a39 1
 * $Id: startup.c,v 10.19 1997/05/21 05:32:31 alc Exp alc $
d110 1
a110 1
struct	Tmk	tmk_ = { /*proc_id=*/0, /*nprocs=*/0, /*page_size=*/0, /*npages=*/NPAGES };
@


10.19.1.2
log
@Eliminated the Ultrix-specific code.
@
text
@d39 1
a39 1
 * $Id: startup.c,v 10.19.1.1 1997/06/02 01:17:28 alc Exp alc $
d236 1
d238 1
d257 1
d262 1
d308 2
d392 4
@


10.19.1.3
log
@Added basic Pthreads support.  (Modified some spacing for consistency.)
@
text
@a115 4
#if defined(PTHREADS)
pthread_mutex_t	Tmk_monitor_lock = PTHREAD_MUTEX_INITIALIZER;
#endif

d344 1
a344 1
#if defined(__linux)
d348 1
a348 1
#endif
d356 1
a356 1
#if defined(__linux)
d358 1
a358 1
#else
d360 1
a360 1
#endif
d383 1
a383 1
#if ! defined(__linux)
d385 1
a385 1
#endif
d500 1
a500 3
#if  defined(PTHREADS)
	pthread_mutex_lock(&Tmk_monitor_lock);
#endif
a775 3
#if defined(PTHREADS)
	pthread_mutex_unlock(&Tmk_monitor_lock);
#endif	
@


10.19.1.4
log
@Added the "-S" option for reporting per processor statistics.
@
text
@d39 1
a39 1
 * $Id: startup.c,v 10.19.1.3 1997/07/22 22:50:03 alc Exp alc $
d514 1
a514 1
	while ((c = getopt(argc, argv, "D:df:h:I:i:m:n:p:rSstvxX:")) != -1)
a550 3
			continue;
		case 'S':
			tmk_stat_flag = 2;
@


10.19.1.5
log
@BSD/OS-specific changes.  Identical to FreeBSD.  (Identical
to revision 11.9.)
@
text
@d39 1
a39 1
 * $Id: startup.c,v 10.19.1.4 1997/07/23 06:14:57 alc Exp alc $
d142 1
a142 1
#if ! (defined(__bsdi) || defined(__FreeBSD__))
d437 1
a437 1
#if defined(_AIX) || defined(__bsdi) || defined(__FreeBSD__)
@


10.19.1.6
log
@Fixed an MPL-specific problem in Tmk_startup: Tmk_heap_initialize
wasn't called (when appropriate).  Reported by Y. Charlie Hu.
@
text
@d39 1
a39 1
 * $Id: startup.c,v 10.19.1.5 1997/09/03 19:03:12 alc Exp alc $
d707 1
a707 1

d710 1
a710 1
#if !defined(MPL)
@


10.19.1.7
log
@Added the "-P" option to set the number of shared pages at startup.

Swapped "x" and "X" in the getopt string for consistency
with the other options.

(Identical to revision 11.13.)
@
text
@d39 1
a39 1
 * $Id: startup.c,v 10.19.1.6 1997/09/24 22:44:34 alc Exp alc $
d514 1
a514 1
	while ((c = getopt(argc, argv, "D:df:h:I:i:m:n:P:p:rSstvX:x")) != -1)
a544 4
			continue;
		case 'P':
			if ((Tmk_npages = atoi(optarg)) > NPAGES)
				Tmk_errexit("Tmk_startup: -P%d exceeds the %d-page limit.\n", Tmk_npages, NPAGES);
@


10.19.1.8
log
@Define "h_errno" on HP-UX 10.0.

"h_errlist" and "herror" are provided by IRIX 6.2.  Don't
redefine them.


(Identical to revision 11.14.)
@
text
@d39 1
a39 1
 * $Id: startup.c,v 10.19.1.7 1997/10/01 05:57:31 alc Exp alc $
d142 1
a142 4
#if defined(__hpux)
int	h_errno;
#endif
#if ! (defined(__bsdi) || defined(__FreeBSD__) || defined(__sgi))
@


10.19.1.9
log
@Use a single GLOBAL spinmask instead of multiple static spinmasks.
@
text
@d39 1
a39 1
 * $Id: startup.c,v 10.19.1.8 1997/12/14 06:00:57 alc Exp alc $
a111 2
unsigned	Tmk_spinmask;

a687 2

	Tmk_spinmask = ((1 << Tmk_nprocs) - 1) &~ (1 << Tmk_proc_id);
@


10.19.1.10
log
@Changed the Tmk_spinmask construction to work if Tmk_nprocs == 32.
(Identical to revision 11.14.)
@
text
@d39 1
a39 1
 * $Id: startup.c,v 10.19.1.9 1998/01/07 07:27:29 alc Exp alc $
d691 1
a691 5
	/*
	 * This abomination is necessary to handle Tmk_nprocs == 32.
	 */
	Tmk_spinmask  = ((1 << (Tmk_nprocs - 1)) << 1) - 1;
	Tmk_spinmask &= ~(1 << Tmk_proc_id);
@


10.19.1.11
log
@Eliminate Tmk_heap_initialize.  Initialize the heap
during the first call to Tmk_malloc, Tmk_free, or Tmk_sbrk.
@
text
@d39 1
a39 1
 * $Id: startup.c,v 10.19.1.10 1998/01/07 08:17:59 alc Exp alc $
d722 3
@


10.19.1.12
log
@Bump the version number to 1.0.1.
@
text
@d39 1
a39 1
 * $Id: startup.c,v 10.19.1.11 1998/01/09 22:39:47 alc Exp alc $
d750 1
a750 1
	Tmk_err("TreadMarks Version 1.0.1-RELEASE of %s"
@


10.19.1.13
log
@Bump the version number to 1.0.2-BETA.
@
text
@d39 1
a39 1
 * $Id: startup.c,v 10.19.1.12 1998/01/09 23:00:07 alc Exp alc $
d750 1
a750 1
	Tmk_err("TreadMarks Version 1.0.2-BETA of %s"
@


10.19.1.14
log
@Bump the version number to 1.0.3-ALPHA.
@
text
@d39 1
a39 1
 * $Id: startup.c,v 10.19.1.13 1998/02/18 17:45:46 alc Exp alc $
d750 1
a750 1
	Tmk_err("TreadMarks Version 1.0.3-ALPHA of %s"
@


10.19.1.15
log
@Added "const" to the Tmk_startup definition.  This is consistent
with getopt.  (Identical to revision 11.17.)
@
text
@d39 1
a39 1
 * $Id: startup.c,v 10.19.1.14 1998/04/04 20:02:29 alc Exp alc $
d493 3
a495 4
void
Tmk_startup(
	int		argc,
	char   * const *argv)
@


10.19.1.16
log
@Added the "const" attribute to the format parameter for several error
reporting functions.
@
text
@d39 1
a39 1
 * $Id: startup.c,v 10.19.1.15 1998/05/09 06:18:34 alc Exp alc $
d122 1
a122 7
/*
 *
 */
void
Tmk_err(
	const char     *format,
	...)
d124 1
a124 1
	va_list		args;
d133 1
a133 7
/*
 *
 */
void
Tmk_errexit(
	const char     *format,
	...)
d135 1
a135 1
	va_list 	args;
a143 3
/*
 *
 */
d170 1
a170 4
void
Tmk_herrexit(
	const char     *format,
	...)
d172 2
a173 2
	va_list 	args;
	char		string[257];
d184 1
a184 7
/*
 *
 */
void
Tmk_perrexit(
	const char     *format,
	...)
d186 2
a187 2
	va_list 	args;
	char		string[257];
@


10.19.1.17
log
@Add Tmk_errno_check, replacing Tmk_perrexit after send and sendmsg.  It
handles the ENOBUF returned by BSD/OS and FreeBSD.
@
text
@d39 1
a39 1
 * $Id: startup.c,v 10.19.1.16 1998/05/09 07:09:50 alc Exp alc $
a219 24
}

/*
 *
 */
void
Tmk_errno_check(
	const char     *format,
	...)
{
	if (errno == ENOBUFS)
		return;
	else {
		va_list 	args;
		char		string[257];

		va_start(args, format);
		vsprintf(string, format, args);
		va_end(args);
	
		perror(string);

		exit(-1);
	}
@


10.19.1.18
log
@Made changes to barrier and sched to facilitate integration
of the FASTLINK barriers:

1. Use a single sigio handler for barriers and scheds (regardless
of whether the manager has arrived or not).

2. Use barrier->mask and sched->mask to determine whether or not
the manager has arrived/joined.

3. Redefine Tmk_spinmask to include the "host" processor.
@
text
@d39 1
a39 1
 * $Id: startup.c,v 10.19.1.17 1998/05/14 20:10:16 alc Exp alc $
d743 2
a744 1
	Tmk_spinmask = ((1 << (Tmk_nprocs - 1)) << 1) - 1;
@


10.19.1.19
log
@Upgrade to BETA status.
@
text
@d39 1
a39 1
 * $Id: startup.c,v 10.19.1.18 1998/06/13 18:39:11 alc Exp alc $
d798 1
a798 1
	Tmk_err("TreadMarks Version 1.0.3-BETA of %s"
@


10.19.1.19.0.1
log
@Implemented a new scheme for providing time-limited demo versions.
(Identical to revision 10.19.1.21.)
@
text
@d39 1
a39 1
 * $Id: startup.c,v 10.19.1.19 1998/06/22 04:11:21 alc Exp alc $
d98 2
a99 39
#if   ! defined(DAYS_VALID)
#	define	DAYS_VALID	10*365	/* ~10 years */
#else
#	define	SCRAMBLE(value, byte)	 ((value >> 8) ^ table_[(value ^ byte) & 255])

static	const	unsigned int	table_[256] = {
	0x00000000, 0x77073096, 0xee0e612c, 0x990951ba, 0x076dc419, 0x706af48f, 0xe963a535, 0x9e6495a3,
	0x0edb8832, 0x79dcb8a4, 0xe0d5e91e, 0x97d2d988, 0x09b64c2b, 0x7eb17cbd, 0xe7b82d07, 0x90bf1d91,
	0x1db71064, 0x6ab020f2, 0xf3b97148, 0x84be41de, 0x1adad47d, 0x6ddde4eb, 0xf4d4b551, 0x83d385c7,
	0x136c9856, 0x646ba8c0, 0xfd62f97a, 0x8a65c9ec, 0x14015c4f, 0x63066cd9, 0xfa0f3d63, 0x8d080df5,
	0x3b6e20c8, 0x4c69105e, 0xd56041e4, 0xa2677172, 0x3c03e4d1, 0x4b04d447, 0xd20d85fd, 0xa50ab56b,
	0x35b5a8fa, 0x42b2986c, 0xdbbbc9d6, 0xacbcf940, 0x32d86ce3, 0x45df5c75, 0xdcd60dcf, 0xabd13d59,
	0x26d930ac, 0x51de003a, 0xc8d75180, 0xbfd06116, 0x21b4f4b5, 0x56b3c423, 0xcfba9599, 0xb8bda50f,
	0x2802b89e, 0x5f058808, 0xc60cd9b2, 0xb10be924, 0x2f6f7c87, 0x58684c11, 0xc1611dab, 0xb6662d3d,
	0x76dc4190, 0x01db7106, 0x98d220bc, 0xefd5102a, 0x71b18589, 0x06b6b51f, 0x9fbfe4a5, 0xe8b8d433,
	0x7807c9a2, 0x0f00f934, 0x9609a88e, 0xe10e9818, 0x7f6a0dbb, 0x086d3d2d, 0x91646c97, 0xe6635c01,
	0x6b6b51f4, 0x1c6c6162, 0x856530d8, 0xf262004e, 0x6c0695ed, 0x1b01a57b, 0x8208f4c1, 0xf50fc457,
	0x65b0d9c6, 0x12b7e950, 0x8bbeb8ea, 0xfcb9887c, 0x62dd1ddf, 0x15da2d49, 0x8cd37cf3, 0xfbd44c65,
	0x4db26158, 0x3ab551ce, 0xa3bc0074, 0xd4bb30e2, 0x4adfa541, 0x3dd895d7, 0xa4d1c46d, 0xd3d6f4fb,
	0x4369e96a, 0x346ed9fc, 0xad678846, 0xda60b8d0, 0x44042d73, 0x33031de5, 0xaa0a4c5f, 0xdd0d7cc9,
	0x5005713c, 0x270241aa, 0xbe0b1010, 0xc90c2086, 0x5768b525, 0x206f85b3, 0xb966d409, 0xce61e49f,
	0x5edef90e, 0x29d9c998, 0xb0d09822, 0xc7d7a8b4, 0x59b33d17, 0x2eb40d81, 0xb7bd5c3b, 0xc0ba6cad,
	0xedb88320, 0x9abfb3b6, 0x03b6e20c, 0x74b1d29a, 0xead54739, 0x9dd277af, 0x04db2615, 0x73dc1683,
	0xe3630b12, 0x94643b84, 0x0d6d6a3e, 0x7a6a5aa8, 0xe40ecf0b, 0x9309ff9d, 0x0a00ae27, 0x7d079eb1,
	0xf00f9344, 0x8708a3d2, 0x1e01f268, 0x6906c2fe, 0xf762575d, 0x806567cb, 0x196c3671, 0x6e6b06e7,
	0xfed41b76, 0x89d32be0, 0x10da7a5a, 0x67dd4acc, 0xf9b9df6f, 0x8ebeeff9, 0x17b7be43, 0x60b08ed5,
	0xd6d6a3e8, 0xa1d1937e, 0x38d8c2c4, 0x4fdff252, 0xd1bb67f1, 0xa6bc5767, 0x3fb506dd, 0x48b2364b,
	0xd80d2bda, 0xaf0a1b4c, 0x36034af6, 0x41047a60, 0xdf60efc3, 0xa867df55, 0x316e8eef, 0x4669be79,
	0xcb61b38c, 0xbc66831a, 0x256fd2a0, 0x5268e236, 0xcc0c7795, 0xbb0b4703, 0x220216b9, 0x5505262f,
	0xc5ba3bbe, 0xb2bd0b28, 0x2bb45a92, 0x5cb36a04, 0xc2d7ffa7, 0xb5d0cf31, 0x2cd99e8b, 0x5bdeae1d,
	0x9b64c2b0, 0xec63f226, 0x756aa39c, 0x026d930a, 0x9c0906a9, 0xeb0e363f, 0x72076785, 0x05005713,
	0x95bf4a82, 0xe2b87a14, 0x7bb12bae, 0x0cb61b38, 0x92d28e9b, 0xe5d5be0d, 0x7cdcefb7, 0x0bdbdf21,
	0x86d3d2d4, 0xf1d4e242, 0x68ddb3f8, 0x1fda836e, 0x81be16cd, 0xf6b9265b, 0x6fb077e1, 0x18b74777,
	0x88085ae6, 0xff0f6a70, 0x66063bca, 0x11010b5c, 0x8f659eff, 0xf862ae69, 0x616bffd3, 0x166ccf45,
	0xa00ae278, 0xd70dd2ee, 0x4e048354, 0x3903b3c2, 0xa7672661, 0xd06016f7, 0x4969474d, 0x3e6e77db,
	0xaed16a4a, 0xd9d65adc, 0x40df0b66, 0x37d83bf0, 0xa9bcae53, 0xdebb9ec5, 0x47b2cf7f, 0x30b5ffe9,
	0xbdbdf21c, 0xcabac28a, 0x53b39330, 0x24b4a3a6, 0xbad03605, 0xcdd70693, 0x54de5729, 0x23d967bf,
	0xb3667a2e, 0xc4614ab8, 0x5d681b02, 0x2a6f2b94,	0xb40bbe37, 0xc30c8ea1, 0x5a05df1b, 0x2d02ef8d
};
d551 1
a551 3
	time_t	past;
	time_t	future;
	struct	timeval	present;
d719 2
a720 2
	if (0 > gettimeofday(&present, NULL))
		Tmk_perrexit("Tmk_startup<gettimeofday>");
d737 1
a737 35
#if	defined(DAYS_VALID) && DAYS_VALID < 61
	if ((cp = getenv("TMK_DEMO_KEY")) != NULL) {

		unsigned int	key_0_[4],
				key_1_[4];

		unsigned int	value_0,
				value_1;

		sscanf(cp, "%d.%d.%d.%d.%d.%d.%d.%d",
		       &key_0_[0], &key_0_[1], &key_0_[2], &key_0_[3],
		       &key_1_[0], &key_1_[1], &key_1_[2], &key_1_[3]);

		value_0 =
		value_1 = ~0;

		for (j = 0; j < sizeof(key_0_)/sizeof(key_0_[0]); j++) {
			value_0 = SCRAMBLE(value_0, key_0_[j]);
			value_1 = SCRAMBLE(value_1, key_1_[j]);
		}

		past   = value_0;
		future = value_1;

		if ((past + DAYS_VALID*24*3600 != future) || (past > future))
			Tmk_errexit("Tmk_startup: TMK_DEMO_KEY=\"%s\" is invalid.\n", cp);
	}
	else
		Tmk_errexit("Tmk_startup: TMK_DEMO_KEY=(null)\n");
#else
	past   = TIMESTAMP;
	future = TIMESTAMP + DAYS_VALID*24*3600;
#endif
	if ((past > present.tv_sec) ||
	    (present.tv_sec >= future))
d799 1
a799 1
#if	defined(DAYS_VALID) && DAYS_VALID < 61
@


10.19.1.19.0.2
log
@Upgrade the status of version 1.0.3 to -RELEASE.
@
text
@d39 1
a39 1
 * $Id: startup.c,v 10.19.1.19.0.1 1998/08/06 21:45:53 alc Exp alc $
d871 1
a871 1
	Tmk_err("TreadMarks Version 1.0.3-RELEASE of %s"
@


10.19.1.19.0.3
log
@Bump the version number to 1.0.3.1-BETA.  Bump the date
on the copyright notice.
@
text
@d39 1
a39 1
 * $Id: startup.c,v 10.19.1.19.0.2 1998/08/06 21:53:54 alc Exp alc $
d871 1
a871 1
	Tmk_err("TreadMarks Version 1.0.3.1-BETA of %s"
d873 1
a873 1
		"Copyright (c) ParallelTools, L.L.C., 1991-1998\n"
d879 1
a879 1
		"Copyright (c) ParallelTools, L.L.C., 1991-1998\n",
@


10.19.1.19.0.4
log
@Upgrade the status of version 1.0.3.1 to -RELEASE.
@
text
@d39 1
a39 1
 * $Id: startup.c,v 10.19.1.19.0.3 1998/08/12 22:00:35 alc Exp alc $
d871 1
a871 1
	Tmk_err("TreadMarks Version 1.0.3.1-RELEASE of %s"
@


10.19.1.19.0.5
log
@Bump the version number to 1.0.3.2-RELEASE.  This release is
specifically for the IBM SP2.  It updates the MPL support
to compile under AIX 4.1.x.
@
text
@d39 1
a39 1
 * $Id: startup.c,v 10.19.1.19.0.4 1998/10/11 20:12:48 alc Exp alc $
d871 1
a871 1
	Tmk_err("TreadMarks Version 1.0.3.2-RELEASE of %s"
@


10.19.1.19.0.6
log
@Bump the version number to 1.0.3.3-BETA.
@
text
@d39 1
a39 1
 * $Id: startup.c,v 10.19.1.19.0.5 1998/11/02 23:51:00 alc Exp alc $
d871 1
a871 1
	Tmk_err("TreadMarks Version 1.0.3.3-BETA of %s"
@


10.19.1.20
log
@Updated the version number.
@
text
@d39 1
a39 1
 * $Id: startup.c,v 10.19.1.19 1998/06/22 04:11:21 alc Exp alc $
d798 1
a798 1
	Tmk_err("TreadMarks Version 1.2.0-ALPHA of %s"
@


10.19.1.21
log
@Implemented a new scheme for providing time-limited demo versions.
@
text
@d39 1
a39 1
 * $Id: startup.c,v 10.19.1.20 1998/07/16 17:54:39 alc Exp alc $
d98 2
a99 39
#if   ! defined(DAYS_VALID)
#	define	DAYS_VALID	10*365	/* ~10 years */
#else
#	define	SCRAMBLE(value, byte)	 ((value >> 8) ^ table_[(value ^ byte) & 255])

static	const	unsigned int	table_[256] = {
	0x00000000, 0x77073096, 0xee0e612c, 0x990951ba, 0x076dc419, 0x706af48f, 0xe963a535, 0x9e6495a3,
	0x0edb8832, 0x79dcb8a4, 0xe0d5e91e, 0x97d2d988, 0x09b64c2b, 0x7eb17cbd, 0xe7b82d07, 0x90bf1d91,
	0x1db71064, 0x6ab020f2, 0xf3b97148, 0x84be41de, 0x1adad47d, 0x6ddde4eb, 0xf4d4b551, 0x83d385c7,
	0x136c9856, 0x646ba8c0, 0xfd62f97a, 0x8a65c9ec, 0x14015c4f, 0x63066cd9, 0xfa0f3d63, 0x8d080df5,
	0x3b6e20c8, 0x4c69105e, 0xd56041e4, 0xa2677172, 0x3c03e4d1, 0x4b04d447, 0xd20d85fd, 0xa50ab56b,
	0x35b5a8fa, 0x42b2986c, 0xdbbbc9d6, 0xacbcf940, 0x32d86ce3, 0x45df5c75, 0xdcd60dcf, 0xabd13d59,
	0x26d930ac, 0x51de003a, 0xc8d75180, 0xbfd06116, 0x21b4f4b5, 0x56b3c423, 0xcfba9599, 0xb8bda50f,
	0x2802b89e, 0x5f058808, 0xc60cd9b2, 0xb10be924, 0x2f6f7c87, 0x58684c11, 0xc1611dab, 0xb6662d3d,
	0x76dc4190, 0x01db7106, 0x98d220bc, 0xefd5102a, 0x71b18589, 0x06b6b51f, 0x9fbfe4a5, 0xe8b8d433,
	0x7807c9a2, 0x0f00f934, 0x9609a88e, 0xe10e9818, 0x7f6a0dbb, 0x086d3d2d, 0x91646c97, 0xe6635c01,
	0x6b6b51f4, 0x1c6c6162, 0x856530d8, 0xf262004e, 0x6c0695ed, 0x1b01a57b, 0x8208f4c1, 0xf50fc457,
	0x65b0d9c6, 0x12b7e950, 0x8bbeb8ea, 0xfcb9887c, 0x62dd1ddf, 0x15da2d49, 0x8cd37cf3, 0xfbd44c65,
	0x4db26158, 0x3ab551ce, 0xa3bc0074, 0xd4bb30e2, 0x4adfa541, 0x3dd895d7, 0xa4d1c46d, 0xd3d6f4fb,
	0x4369e96a, 0x346ed9fc, 0xad678846, 0xda60b8d0, 0x44042d73, 0x33031de5, 0xaa0a4c5f, 0xdd0d7cc9,
	0x5005713c, 0x270241aa, 0xbe0b1010, 0xc90c2086, 0x5768b525, 0x206f85b3, 0xb966d409, 0xce61e49f,
	0x5edef90e, 0x29d9c998, 0xb0d09822, 0xc7d7a8b4, 0x59b33d17, 0x2eb40d81, 0xb7bd5c3b, 0xc0ba6cad,
	0xedb88320, 0x9abfb3b6, 0x03b6e20c, 0x74b1d29a, 0xead54739, 0x9dd277af, 0x04db2615, 0x73dc1683,
	0xe3630b12, 0x94643b84, 0x0d6d6a3e, 0x7a6a5aa8, 0xe40ecf0b, 0x9309ff9d, 0x0a00ae27, 0x7d079eb1,
	0xf00f9344, 0x8708a3d2, 0x1e01f268, 0x6906c2fe, 0xf762575d, 0x806567cb, 0x196c3671, 0x6e6b06e7,
	0xfed41b76, 0x89d32be0, 0x10da7a5a, 0x67dd4acc, 0xf9b9df6f, 0x8ebeeff9, 0x17b7be43, 0x60b08ed5,
	0xd6d6a3e8, 0xa1d1937e, 0x38d8c2c4, 0x4fdff252, 0xd1bb67f1, 0xa6bc5767, 0x3fb506dd, 0x48b2364b,
	0xd80d2bda, 0xaf0a1b4c, 0x36034af6, 0x41047a60, 0xdf60efc3, 0xa867df55, 0x316e8eef, 0x4669be79,
	0xcb61b38c, 0xbc66831a, 0x256fd2a0, 0x5268e236, 0xcc0c7795, 0xbb0b4703, 0x220216b9, 0x5505262f,
	0xc5ba3bbe, 0xb2bd0b28, 0x2bb45a92, 0x5cb36a04, 0xc2d7ffa7, 0xb5d0cf31, 0x2cd99e8b, 0x5bdeae1d,
	0x9b64c2b0, 0xec63f226, 0x756aa39c, 0x026d930a, 0x9c0906a9, 0xeb0e363f, 0x72076785, 0x05005713,
	0x95bf4a82, 0xe2b87a14, 0x7bb12bae, 0x0cb61b38, 0x92d28e9b, 0xe5d5be0d, 0x7cdcefb7, 0x0bdbdf21,
	0x86d3d2d4, 0xf1d4e242, 0x68ddb3f8, 0x1fda836e, 0x81be16cd, 0xf6b9265b, 0x6fb077e1, 0x18b74777,
	0x88085ae6, 0xff0f6a70, 0x66063bca, 0x11010b5c, 0x8f659eff, 0xf862ae69, 0x616bffd3, 0x166ccf45,
	0xa00ae278, 0xd70dd2ee, 0x4e048354, 0x3903b3c2, 0xa7672661, 0xd06016f7, 0x4969474d, 0x3e6e77db,
	0xaed16a4a, 0xd9d65adc, 0x40df0b66, 0x37d83bf0, 0xa9bcae53, 0xdebb9ec5, 0x47b2cf7f, 0x30b5ffe9,
	0xbdbdf21c, 0xcabac28a, 0x53b39330, 0x24b4a3a6, 0xbad03605, 0xcdd70693, 0x54de5729, 0x23d967bf,
	0xb3667a2e, 0xc4614ab8, 0x5d681b02, 0x2a6f2b94,	0xb40bbe37, 0xc30c8ea1, 0x5a05df1b, 0x2d02ef8d
};
d551 1
a551 3
	time_t	past;
	time_t	future;
	struct	timeval	present;
d719 2
a720 2
	if (0 > gettimeofday(&present, NULL))
		Tmk_perrexit("Tmk_startup<gettimeofday>");
d734 1
a734 1
#if   ! defined(MPL)
d737 1
a737 35
#if	defined(DAYS_VALID) && DAYS_VALID < 61
	if ((cp = getenv("TMK_DEMO_KEY")) != NULL) {

		unsigned int	key_0_[4],
				key_1_[4];

		unsigned int	value_0,
				value_1;

		sscanf(cp, "%d.%d.%d.%d.%d.%d.%d.%d",
		       &key_0_[0], &key_0_[1], &key_0_[2], &key_0_[3],
		       &key_1_[0], &key_1_[1], &key_1_[2], &key_1_[3]);

		value_0 =
		value_1 = ~0;

		for (j = 0; j < sizeof(key_0_)/sizeof(key_0_[0]); j++) {
			value_0 = SCRAMBLE(value_0, key_0_[j]);
			value_1 = SCRAMBLE(value_1, key_1_[j]);
		}

		past   = value_0;
		future = value_1;

		if ((past + DAYS_VALID*24*3600 != future) || (past > future))
			Tmk_errexit("Tmk_startup: TMK_DEMO_KEY=\"%s\" is invalid.\n", cp);
	}
	else
		Tmk_errexit("Tmk_startup: TMK_DEMO_KEY=(null)\n");
#else
	past   = TIMESTAMP;
	future = TIMESTAMP + DAYS_VALID*24*3600;
#endif
	if ((past > present.tv_sec) ||
	    (present.tv_sec >= future))
d766 1
a766 1
#if   ! defined(MPL)
d770 1
a770 1
#if   ! defined(MPL)
d799 1
a799 1
#if	defined(DAYS_VALID) && DAYS_VALID < 61
d828 1
a828 1
#if   ! defined(MPL)
d845 1
a845 1
#if	defined(PTHREADS)
@


10.19.1.22
log
@Added support for reduction barriers.
@
text
@d39 1
a39 1
 * $Id: startup.c,v 10.19.1.21 1998/08/06 21:44:04 alc Exp alc $
a836 2

	Tmk_reduction_initialize();
@


10.19.1.23
log
@1.  Tmk_barrier_reduce replaces Tmk_barrier.  Tmk_barrier is now
a stub that calls Tmk_barrier_reduce.  2.  The file barrier.c is
dropped.  3.  The file reduction.c is renamed barrier_reduce.c.
@
text
@d39 1
a39 1
 * $Id: startup.c,v 10.19.1.22 1998/08/10 19:49:41 alc Exp alc $
d837 2
@


10.18
log
@Updated the version number and copyright date.
@
text
@d39 1
a39 1
 * $Id: startup.c,v 10.17 1997/03/18 07:22:55 alc Exp alc $
a701 2

	Tmk_monitor_initialize();
@


10.17
log
@Added monitor (condition variable) initialization.
@
text
@d39 1
a39 1
 * $Id: startup.c,v 10.16 1997/03/07 03:56:33 alc Exp alc $
d741 1
a741 1
	Tmk_err("TreadMarks Version 0.10.2 of %s"
d743 1
a743 1
		"Copyright (c) ParallelTools, L.L.C., 1991-1996\n"
d749 1
a749 1
		"Copyright (c) ParallelTools, L.L.C., 1991-1996\n",
@


10.16
log
@Added signo argument to the dummy SIGINT handler.  This eliminates
some compilation warnings.
@
text
@d39 1
a39 1
 * $Id: startup.c,v 10.15 1997/02/21 18:01:52 alc Exp alc $
d702 2
@


10.15
log
@To improve the locality of reference, created the Tmk_ struct
containing nprocs and the proc_id.
@
text
@d39 1
a39 1
 * $Id: startup.c,v 10.14 1997/01/09 06:20:59 alc Exp alc $
d456 1
a456 1
static	void	int_handler( void )
@


10.14
log
@Added the "-v" option that initializes the shared pages
as valid but write protected on every node.  This option
generally reduces the number of messages and the
amount of data transferred early in the execution.
@
text
@d39 1
a39 1
 * $Id: startup.c,v 10.13 1996/10/04 23:29:10 alc Exp alc $
d110 1
a110 3
unsigned	Tmk_proc_id;

unsigned	Tmk_nprocs;
@


10.13
log
@Eliminated some differences between the MPL version and the UDP version.
@
text
@d39 1
a39 1
 * $Id: startup.c,v 10.12 1996/10/03 20:58:40 alc Exp alc $
d520 1
a520 1
	while ((c = getopt(argc, argv, "D:df:h:I:i:m:n:p:rstxX:")) != -1)
d564 3
a690 3
	if (page_array_[0].vadr >= (caddr_t)&end)
		Tmk_heap_initialize();

d711 3
@


10.12
log
@Coalesce three MPL #ifdef's.
@
text
@d39 1
a39 1
 * $Id: startup.c,v 10.11 1996/10/03 20:27:45 alc Exp alc $
d614 1
a614 4
#endif
	if (0 > gettimeofday(&now, NULL))
		Tmk_perrexit("Tmk_startup: gettimeofday");
#if defined(MPL)
d616 1
a616 1
		Tmk_errexit("-h option not allowed when using MPL\n");
d618 3
a620 5
	if (0 > mpc_environ((int *)&Tmk_nprocs, (int *)&Tmk_proc_id))
		Tmk_MPLerrexit("<mpc_environ>");

	i = Tmk_nprocs;
#else
d661 3
d676 1
d679 3
a685 3
	if (now.tv_sec > TIMESTAMP + DAYS_VALID*24*3600)
		Tmk_nprocs = 1;

d708 1
a708 1

d710 1
a710 1

a759 3
	Tmk_connect_initialize();

#if !defined(MPL)
d766 3
a783 2
#else
	Tmk_sigio_initialize();
@


10.11
log
@Eliminate mpc_stopall on normal termination.  Tmk_perrexit and
Tmk_errexit won't terminate with mpc_stopall.  They should.

Move Tmk_MPLerrexit to mpl.c.
@
text
@d39 1
a39 1
 * $Id: startup.c,v 10.10 1996/09/29 20:19:04 alc Exp alc $
d709 1
a709 2
#endif
#if !defined(MPL)
d711 1
a711 2
#endif
#if !defined(MPL)
@


10.10
log
@Changed "atoi" to "atol" and "%d" to "%ld" so that the "-m" option
works on the Alpha/DEC Unix.
@
text
@d39 1
a39 1
 * $Id: startup.c,v 10.9 1996/09/25 04:06:51 alc Exp alc $
a176 19
#if defined(MPL)
void	Tmk_MPLerrexit(char *format, ...)
{
	va_list args;

	va_start(args, format);
	vfprintf(stderr, format, args);
	va_end(args);

	fprintf(stderr,
		"\n"
		"Exiting with error number (mperrno) 0032-%d\n"
		"  (See IBM AIX Parallel Environment: Installation, Administration, and Diagnosis.)\n",
		mperrno);

	exit(-1);
}
#endif

a490 3
#if defined(MPL)
	mpc_stopall(0);
#endif
@


10.9
log
@Added MPL support.
@
text
@d39 1
a39 1
 * $Id: startup.c,v 10.8 1996/08/24 21:10:49 alc Exp alc $
d313 1
a313 1
		sprintf(sptr, "%s-i%d -m%d", sptr, i, page_array_[0].vadr);
d315 1
a315 1
		sprintf(sptr, "%s-- -i%d -m%d", sptr, i, page_array_[0].vadr);
d566 1
a566 1
			page_array_[0].vadr = (caddr_t) atoi(optarg);
@


10.8
log
@Replaced sigprocmask by sigio_mutex.  Sigio_mutex is defined
in Tmk.h.
@
text
@d39 1
a39 1
 * $Id: startup.c,v 10.7 1996/07/28 20:27:05 alc Exp alc $
d177 19
d253 1
d472 1
d510 3
d637 11
a687 3
	if (0 > gettimeofday(&now, NULL))
		Tmk_perrexit("Tmk_startup: gettimeofday");

d701 4
a708 4
	sigemptyset(&ALRM_and_IO_mask);
	sigaddset(&ALRM_and_IO_mask, SIGALRM);
	sigaddset(&ALRM_and_IO_mask, SIGIO);

d729 1
a729 1

d731 2
a732 1

d734 2
a735 1

d762 1
d785 3
a793 2
	Tmk_connect_initialize();

d809 3
@


10.7
log
@Changed the herror parameter definition for compatibility
with the Slowaris 2.5.1 "netdb.h".  (Oddly, Slowaris defines
herror in "netdb.h", but doesn't include it in the library.)
@
text
@d39 1
a39 1
 * $Id: startup.c,v 10.6 1996/07/26 20:02:39 alc Exp alc $
d267 1
a267 1
	sigprocmask(SIG_BLOCK, &ALRM_and_IO_mask, &mask);
d397 1
a397 1
	sigprocmask(SIG_SETMASK, &mask, NULL);
@


10.6
log
@Initial integration of the loop scheduling routines.
@
text
@d39 1
a39 1
 * $Id: startup.c,v 10.5 1996/07/26 03:57:51 alc Exp alc $
d152 1
a152 1
 * h_errno is thread safe under AIX 4.1, but not Solaris 2.5
d154 1
a154 1
void	herror(char *string)
@


10.5
log
@Added Tmk_herrexit.  It is used to report errors returned by gethostbyname.
@
text
@d39 1
a39 1
 * $Id: startup.c,v 10.4 1996/06/23 17:02:27 alc Exp alc $
d695 2
@


10.4
log
@Commented the "test_hostlist" procedure.
@
text
@d39 1
a39 1
 * $Id: startup.c,v 10.3 1996/06/23 06:46:01 alc Exp alc $
d140 37
d431 2
a432 1
	if ((hp = gethostbyname(Tmk_hostlist[Tmk_proc_id])) == NULL) {
a433 4
		herror(Tmk_hostlist[Tmk_proc_id]);

		exit(-1);
	}
@


10.3
log
@Added the test_hostlist procedure.
@
text
@d39 1
a39 1
 * $Id: startup.c,v 10.2 1996/06/22 01:11:04 alc Exp alc $
d366 4
a369 1
 *
@


10.2
log
@Update the version number.
@
text
@d37 4
a40 2
/*****************************************************************************
 * File:		startup.c
d91 1
a91 4
 *
 * $Id: startup.c,v 10.1 1996/05/27 04:43:49 alc Rel alc $
 *
 *****************************************************************************/
d94 4
d366 51
d473 1
d631 5
a638 3

	if (now.tv_sec > TIMESTAMP + DAYS_VALID*24*3600)
		Tmk_nprocs = 1;
@


10.1
log
@Tmk-0.10.1R
@
text
@d90 1
a90 1
 * $Id: startup.c,v 10.0.2.10 1996/05/27 04:20:26 alc Exp $
d632 1
a632 1
	Tmk_err("TreadMarks Version 0.10.1 of %s"
@


10.1.3.1
log
@Tmk-0.10.1.1R: IRIX 6.2 support.
@
text
@d37 2
a38 4

/*
 * $Id: startup.c,v 10.1 1996/05/27 04:43:49 alc Rel alc $
 *
d89 4
a92 1
 */
d632 1
a632 1
	Tmk_err("TreadMarks Version 0.10.1.1 of %s"
@


10.1.3.2
log
@Changed "-m" to use "atol" instead of "atoi".
@
text
@d39 1
a39 1
 * $Id: startup.c,v 10.1.3.1 1996/11/14 06:25:07 alc Rel alc $
d449 1
a449 1
			page_array_[0].vadr = (caddr_t) atol(optarg);
@


10.1.3.3
log
@Changed "-m" to use "%ld" instead of "%d".  (This change was included
in revision 10.10.)
@
text
@d39 1
a39 1
 * $Id: startup.c,v 10.1.3.2 1997/05/10 20:37:32 alc Exp alc $
d252 1
a252 1
		sprintf(sptr, "%s-i%d -m%ld", sptr, i, page_array_[0].vadr);
d254 1
a254 1
		sprintf(sptr, "%s-- -i%d -m%ld", sptr, i, page_array_[0].vadr);
@


10.1.3.4
log
@Updated the version number and copyright date.
@
text
@d3 1
a3 1
 *  Copyright (c) 1991-1997						     *
d39 1
a39 1
 * $Id: startup.c,v 10.1.3.3 1997/05/10 23:43:27 alc Exp alc $
d631 1
a631 1
	Tmk_err("TreadMarks Version 0.10.1.2 of %s"
d633 1
a633 1
		"Copyright (c) ParallelTools, L.L.C., 1991-1997\n"
d639 1
a639 1
		"Copyright (c) ParallelTools, L.L.C., 1991-1997\n",
@


10.1.4.1
log
@MPL Support
@
text
@d47 1
a47 2
 *			Tmk_startup,
 *			Tmk_MPLerrexit
d88 1
a88 2
 *	Version 0.10.1
 *	29-July-1996	Rob Fowler	IBM MPL support
d90 1
a90 1
 * $Id: startup.c,v 10.1.5.7 1996/07/03 23:20:36 alc Exp $
a102 2
sigset_t	IO_mask;

a114 4
#if defined(THREADS)
pthread_mutex_t monitor_lock = PTHREAD_MUTEX_INITIALIZER;
#endif

a136 16
#if defined(MPL)
void	Tmk_MPLerrexit(char *format, ...)
{
	va_list args;

	va_start(args,format);
	vfprintf(stderr, format, args);
	va_end(args);
	fprintf(stderr,"Exiting with error number (mperrno) 0032-%d\n",
		mperrno);
	fprintf(stderr,"  (See IBM AIX Parallel Environment: Installation, Administration, and Diagnosis.)\n");

	exit(-1);
}
#endif

a147 4
#if defined(MPL)
	if(0 == errno ) Tmk_MPLerrexit("MPL error"); 
#endif

a200 2
#if !defined(MPL)

d227 1
a227 1
	sigio_mutex(SIG_BLOCK, &IO_mask, &mask, LOCK);
d324 1
a324 1
		while ((flag = select(maxfdp1, (fd_set_t)&fds_tmp, NULL, (fd_set_t)&fds_exc, &timeout_tmp)) < 0)
d326 1
a326 1
		while ((flag = select(maxfdp1, (fd_set_t)&fds_tmp, NULL, (fd_set_t)&fds_exc, &timeout)) < 0)
d328 1
a328 2
			if (errno != EINTR)
				Tmk_perrexit("<select>Tmk_startup");
d357 1
a357 1
	sigio_mutex(SIG_SETMASK, &mask, NULL, UNLOCK);
a360 1
#endif /* !defined(MPL) */
a361 1

d365 1
a365 1
static	void	int_handler()
a396 1

a397 6
#if defined(MPL)
	Tmk_err("Node %d exit_handler, calling mpc_stopall.\n",
		Tmk_proc_id);
	mpc_stopall(-1);
#endif

a418 3
#if defined(THREADS)
	pthread_mutex_lock(&monitor_lock);
#endif
a458 1
#if !defined(MPL)
a459 1
#endif
d468 1
a468 1
			Tmk_debug += 1;
a520 22

	if (0 > gettimeofday(&now, NULL))
		Tmk_perrexit("Tmk_startup: gettimeofday");

#if defined(MPL)
	if (i>0)
	    Tmk_errexit("-h option not allowed when using MPL\n");
	if(0> mpc_environ((int *) &Tmk_nprocs, (int *) &Tmk_proc_id))
	   Tmk_MPLerrexit("<mpc_environ>");

	   i = Tmk_nprocs;
	   Tmk_err("Task %d of %d started under MPL.\n", Tmk_proc_id, Tmk_nprocs);

/*	if(Tmk_proc_id == 0){
 *	  int nbuf[2];
 *	  if( 0> mpc_task_query(nbuf,2, 2)) Tmk_errexit("task_query");
 *	  Tmk_err("Min and max message types = ( %d, %d)\n", nbuf[0],nbuf[1]);
 *	}
 */
#else  /* not MPL */


d561 2
a575 3

#endif  /* MPL / non-MPL split */

a578 3
	
	sigemptyset(&IO_mask);
	sigaddset(&IO_mask, SIGIO);
a601 1
#if !defined(MPL)
a602 1
#endif
d604 1
a604 2

#if !defined(MPL)
d632 1
a632 3
#endif

	Tmk_err("TreadMarks Version 0.10.1.Pthreads of %s"
a653 8

/* Note, the order of the following two calls is important for the MPL branch */

	Tmk_connect_initialize();

	Tmk_sigio_initialize();

#if !defined(MPL)
d660 1
a676 6
#endif

#if defined(THREADS)
	pthread_mutex_unlock(&monitor_lock);
#endif	

@


10.1.5.1
log
@Start of 0.10.1 THREADS branch. Incorporated alias code from SMP branch.
@
text
@d90 1
a90 1
 * $Id: startup.c,v 10.1 1996/05/27 04:43:49 alc Rel $
@


10.1.5.2
log
@Added sigio_lock and monitor_lock. Changed segv_handler to avoid race condition.
@
text
@d90 1
a90 1
 * $Id: startup.c,v 10.1.5.1 1996/06/27 16:38:16 tmiller Exp tmiller $
a114 4
#if defined(THREADS)
pthread_mutex_t monitor_lock;
#endif

d228 1
a228 3
#if defined(THREADS)
	pthread_mutex_lock(&sigio_lock);
#endif
a356 3
#if defined(THREADS)
	pthread_mutex_unlock(&sigio_lock);
#endif	
a579 4
#if defined(THREADS)
	pthread_mutex_init(&monitor_lock, NULL);
	pthread_mutex_lock(&monitor_lock);
#endif
a676 3
#if defined(THREADS)
	pthread_mutex_unlock(&monitor_lock);
#endif	
@


10.1.5.3
log
@Use static initializers for pthread mutexes
@
text
@d90 1
a90 1
 * $Id: startup.c,v 10.1.5.2 1996/06/27 23:05:15 tmiller Exp $
d116 1
a116 1
pthread_mutex_t monitor_lock = PTHREAD_MUTEX_INITIALIZER;
d589 4
@


10.1.5.4
log
@Cleaned up sigprocmask/pthread_sigmask/sigthreadmask and sigio
locking/unlocking with sigio_mutex macro
@
text
@d90 1
a90 1
 * $Id: startup.c,v 10.1.5.3 1996/07/02 00:09:02 tmiller Exp tmiller $
d231 4
a234 2
	sigio_mutex(SIG_BLOCK, &ALRM_and_IO_mask, &mask, LOCK);

d334 1
a334 1
			Tmk_perrexit("<select>Tmk_startup");
d363 4
a366 1
	sigio_mutex(SIG_SETMASK, &mask, NULL, UNLOCK);
a427 3
#if defined(THREADS)
	pthread_mutex_lock(&monitor_lock);
#endif
@


10.1.5.5
log
@Added retry on select
@
text
@d90 1
a90 1
 * $Id: startup.c,v 10.1.5.4 1996/07/02 22:34:57 tmiller Exp $
d328 1
a328 1
		while ((flag = select(maxfdp1, (fd_set_t)&fds_tmp, NULL, (fd_set_t)&fds_exc, &timeout_tmp)) < 0)
d330 1
a330 1
		while ((flag = select(maxfdp1, (fd_set_t)&fds_tmp, NULL, (fd_set_t)&fds_exc, &timeout)) < 0)
d332 1
a332 2
			if (errno != EINTR)
				Tmk_perrexit("<select>Tmk_startup");
@


10.1.5.6
log
@cleaned up signal masks
@
text
@d90 1
a90 1
 * $Id: startup.c,v 10.1.5.5 1996/07/02 22:47:18 tmiller Exp tmiller $
a102 2
sigset_t	IO_mask;

d231 1
a231 1
	sigio_mutex(SIG_BLOCK, &IO_mask, &mask, LOCK);
a586 3
	
	sigemptyset(&IO_mask);
	sigaddset(&IO_mask, SIGIO);
@


10.1.5.7
log
@Changed the version to 0.10.1.Pthreads.
@
text
@d90 1
a90 1
 * $Id: startup.c,v 10.1.5.6 1996/07/03 19:32:35 tmiller Exp alc $
d645 1
a645 1
	Tmk_err("TreadMarks Version 0.10.1.Pthreads of %s"
@


10.1.2.1
log
@changed page_dirty list and intervals to use ranges
@
text
@d90 1
a90 1
 * $Id: startup.c,v 10.1 1996/05/27 04:43:49 alc Rel $
@


10.0
log
@POSIX Version
@
text
@d90 2
a100 2
sigset_t	empty_mask;

a102 2
sigset_t	BUS_or_SEGV_mask;

d122 2
d253 1
a253 1
		sprintf(sptr, "%s-i%d", sptr, i);
d255 1
a255 1
		sprintf(sptr, "%s-- -i%d", sptr, i);
d295 1
a295 1
		sprintf(command, "rsh %s \"%s\"", hostname, string);
d297 1
a297 1
		sprintf(command, "remsh %s \"%s\"", hostname, string);
d311 2
d314 2
d323 3
a325 1

d327 1
d350 1
a350 1

d352 1
d363 1
a363 1
 * (Soon to be) Called by atexit (or on_exit)
d365 12
d378 1
d380 18
a397 3
	if (display && Tmk_proc_id)
		for (;;)
			sleep(1);
d419 8
a426 2

	while ((c = getopt(argc, argv, "D:df:h:I:i:n:p:rstxX:")) != -1)
d435 1
a435 1
				Tmk_errexit("Tmk_startup: DEBUGGER=%s\n", debugger);
d449 3
d473 1
a473 1
				Tmk_errexit("Tmk_startup: DISPLAY=%s\n", display);
d476 2
a477 2
			if ((Tmk_page_size = atoi(optarg)) > 2)
				Tmk_errexit("Tmk_startup: -X%d exceeds the maximum page size.\n", Tmk_page_size, getpagesize() << 2);
d513 1
a513 1
			if ((host = gethostbyaddr(&addr, sizeof(addr), AF_INET)) == 0)
a575 2
	sigemptyset(&empty_mask);

a579 3
	sigemptyset(&BUS_or_SEGV_mask);
	sigaddset(&BUS_or_SEGV_mask, SIGBUS_or_SEGV);

d632 1
a632 1
	Tmk_err("TreadMarks Version 0.10 of %s"
d634 1
a634 1
		"Copyright (c) ParallelTools, L.L.C., 1991-1995\n"
d640 1
a640 1
		"Copyright (c) ParallelTools, L.L.C., 1991-1995\n",
@


10.0.3.1
log
@Initial Linux port by Rob Fowler.
@
text
@a116 28
/*
 * Points to the string that is bound to the environment variable DEBUGGER.
 */
static  char   *debugger;

/*
 * Points to the string that is bound to the environment variable DISPLAY.
 */
static	char   *display;

static  void tmkterminate()
{
        if(
#if defined(LoadL)
	   !ll_job &&
#endif
	      display && Tmk_proc_id !=0 ) {
                Tmk_err("<<Ctrl-C to kill process (and window)>>\n");
                while(1) sleep(2);
                };
#if defined(MPL)
        mpc_stopall(-1);
#endif
        exit(-1);
}



d134 1
a134 1
	tmkterminate();
d148 1
a148 1
		tmkterminate();
d167 9
d198 1
a198 2
static	struct	timeval	thirty_secs = { 30, 0 };
static struct timeval timeout;
a235 3
#if defined(linux)
		sprintf(string, "%s/usr/X11/bin/xterm -display %s -name %s -title %s -e ", string, display, hostname, hostname);
#else
a236 1
#endif
a302 3

		/* if (Tmk_debug) Tmk_err("... after popen\n"); */

a319 4
#if defined(linux)
	timeout = thirty_secs;
#endif

a322 5
/*		if(Tmk_debug)
 *		    Tmk_err("... select flag=%d, fd2p=%08x fds_tmp=%08x\n",
 *			    flag, fd2p, fds_tmp);
 */

a326 1
#if defined(linux)
a329 1
#endif
a341 1
	   { if(Tmk_debug) Tmk_err("... about to close fd\n");
a342 1
	 }
a343 2
#if ! defined(linux)
	if(Tmk_debug) Tmk_err("... about to close fp2\n");
a344 3
	if(Tmk_debug) Tmk_err("... fp2 closed\n");
#endif

d384 1
a384 19
#if defined(linux)
	/* hack to get around the GNU getopt peculiarities */
	int  start_optind = optind;
	int  opt_count = 0;

	 printf("Starting...\n"); 
#endif
	while ((c = getopt(argc, argv, "+D:df:h:I:i:n:p:rstxX:")) != -1)
	    {

#if defined(DDDEBUG)
	    fprintf(stderr, "Option = %c\n", c);
	  fprintf( stderr, " optind= %d opterr= %d optopt= %c \n",
		  optind, opterr, optopt);
#endif

#if defined(linux)
	    opt_count++;
#endif
d423 1
a423 1
			Tmk_debug += 1;
d434 1
a434 3
		    }
	}

d436 2
a437 16
#if defined(linux)
	if (opt_count + start_optind < argc) {
#else
	if (optind < argc) {
#endif
#if defined(linux)
	   fprintf(stderr, "  At error. optind= %d argc= %d\n", optind, argc); 
	  fprintf( stderr, " optind= %d opterr= %d optopt= %c \n",
		  optind, opterr, optopt);

	{ int i;
	  for (i = 0; i < argc; i++) fprintf(stderr, "  %s\n", argv[i]);
      }
#endif
	   Tmk_errexit("Tmk_startup: \"%s\" is an invalid argument.\n", argv[optind]);
	}
@


10.0.2.1
log
@Start of the 0.10.1 development branch
@
text
@@


10.0.2.2
log
@Eliminated empty_mask and BUS_or_SEGV_mask.  Use SIG_UNBLOCK instead.
@
text
@d99 2
d103 2
d531 2
d537 3
d592 1
a592 1
	Tmk_err("TreadMarks Version 0.10.1 of %s"
@


10.0.2.3
log
@Fixed the following problem under Solaris: If the -d or -x option was
specified and the corresponding environment variable wasn't defined,
Solaris dumped core.
@
text
@d389 1
a389 1
				Tmk_errexit("Tmk_startup: DEBUGGER=(null)\n");
d424 1
a424 1
				Tmk_errexit("Tmk_startup: DISPLAY=(null)\n");
@


10.0.2.4
log
@This change was brought over from revision 9.7.2.2.  Added a cast
to the first argument to gethostbyaddr.  This eliminates a warning
under AIX 4.1.
@
text
@d464 1
a464 1
			if ((host = gethostbyaddr((char *)&addr, sizeof(addr), AF_INET)) == 0)
@


10.0.2.5
log
@Use atexit or on_exit (SunOS) to delay closing slave windows
until the user types a control-C.
@
text
@a89 2
 * $Id$
 *
a352 5
#if defined(__sun) && ! defined(__SVR4)
static	void	exit_handler(status, arg)
	int	status;
	caddr_t	arg;
#else
a353 1
#endif
d379 1
a379 7
#if defined(__sun) && ! defined(__SVR4)
	if (on_exit(exit_handler, NULL))
		Tmk_err("Unable to register handler with \"on_exit\"\n");
#else
	if (0 > atexit(exit_handler))
		perror("Unable to register handler with \"atexit\"");
#endif
@


10.0.2.6
log
@Passed a scratch timeout to the select call.  Linux changes the timeout
to reflect the difference between the elapsed time and the original
timeout.
@
text
@d90 1
a90 1
 * $Id: startup.c,v 10.0.2.5 1996/04/22 01:46:15 alc Exp alc $
a308 2
# if defined(__linux)
		struct	timeval	timeout_tmp;
a309 2
		timeout_tmp = timeout;
# endif
d317 1
a317 3
# if defined(__linux)
		if ((flag = select(maxfdp1, (fd_set_t)&fds_tmp, NULL, (fd_set_t)&fds_exc, &timeout_tmp)) < 0)
# else
a318 1
# endif
d341 1
a341 1
# if ! defined(__linux)
a342 1
# endif
@


10.0.2.7
log
@These changes were brought over from revisions 9.7.2.4 and 9.7.2.5.
@
text
@d90 1
a90 1
 * $Id: startup.c,v 10.0.2.6 1996/04/27 21:15:23 alc Exp alc $
d293 1
a293 1
		sprintf(command, "rsh %s -n \"%s\"", hostname, string);
d295 1
a295 1
		sprintf(command, "remsh %s -n \"%s\"", hostname, string);
d607 1
a607 1
		"Copyright (c) ParallelTools, L.L.C., 1991-1996\n"
d613 1
a613 1
		"Copyright (c) ParallelTools, L.L.C., 1991-1996\n",
@


10.0.2.8
log
@This change was brought over from revision 9.7.2.6.  Added the "-m" option
to specify the starting address of the shared heap.  Tmk_startup recognizes
this option and start_process generates it.
@
text
@d90 1
a90 1
 * $Id: startup.c,v 10.0.2.7 1996/05/04 06:34:14 alc Exp alc $
d251 1
a251 1
		sprintf(sptr, "%s-i%d -m%d", sptr, i, page_array_[0].vadr);
d253 1
a253 1
		sprintf(sptr, "%s-- -i%d -m%d", sptr, i, page_array_[0].vadr);
d402 1
a402 1
	while ((c = getopt(argc, argv, "D:df:h:I:i:m:n:p:rstxX:")) != -1)
a423 3
			continue;
		case 'm':
			page_array_[0].vadr = (caddr_t) atoi(optarg);
@


10.0.2.9
log
@Changed the Tmk_page_size computation method.  Before Tmk_page_initialize,
page_shift is the number of bits that the operating system page size is
left shifted to compute Tmk_page_size.  page_shift is set to a default
value in page.c and modified in Tmk_startup under the "-X" option.
@
text
@d90 1
a90 1
 * $Id: startup.c,v 10.0.2.8 1996/05/17 04:30:33 alc Exp alc $
d452 2
a453 2
			if ((page_shift = atoi(optarg)) > 3)
				Tmk_errexit("Tmk_startup: -X%d exceeds the maximum page size.\n", page_shift);
@


10.0.2.10
log
@Changed exit_handler to block using sigsuspend.
@
text
@d90 1
a90 1
 * $Id: startup.c,v 10.0.2.9 1996/05/25 17:57:43 alc Exp alc $
a121 2

	fflush(stderr);
d361 1
a361 8
 * Used by the exit handler
 */
static	void	int_handler( void )
{
}

/*
 * Called by atexit (or on_exit)
d371 3
a373 18
	if (display && Tmk_proc_id) {

		struct	sigaction sa;
		struct	sigaction sa_old;

		Tmk_err("[ Tmk: to exit type ^C (SIGINT) ]\n");

		sa.sa_flags = 0;
		sa.sa_handler = int_handler;

		sigemptyset(&sa.sa_mask);

		sigaction(SIGINT, &sa, &sa_old);

		sigsuspend(&ALRM_and_IO_mask);

		sigaction(SIGINT, &sa_old, NULL);
	}
@


10.0.2.3.2.1
log
@Start of the 0.10.1 multiprocessor development branch
@
text
@@


10.0.2.3.2.2
log
@Added sigio locking inside existing critical sections (sigprocmask). <SMP>
@
text
@d224 1
a224 3
#if	defined(__sgi)
	spin_lock(&sigio_lock);	/* SMP */
#endif
a343 3
#endif
#if  defined(__sgi)
	release_lock(&sigio_lock);	/* SMP */
@


10.0.1.1
log
@Tmk-0.10R: FASTLINK Version
@
text
@a110 2
unsigned	Tmk_proc_mask = 1;

a112 2
unsigned	Tmk_mask;

a405 1
			Tmk_proc_mask = 1 << Tmk_proc_id;
a541 2

	Tmk_mask = (1 << Tmk_nprocs) - 1;
@


9.7
log
@Tmk-0.9.7R
@
text
@d3 1
a3 1
 *  Copyright (c) 1991-1995						     *
d85 5
a96 1
#include <netdb.h>
d99 6
a210 1
	char   *getwd(char *pathname);
d224 2
a225 1
	int	mask = sigblock(sigmask(SIGALRM)|sigmask(SIGIO));
d227 2
d230 1
a230 1
		if ((ptr = getwd(pathname)) == 0)
d349 1
a349 1
	sigsetmask(mask);
d531 9
d592 1
a592 1
	Tmk_err("TreadMarks Version 0.9.7 of %s"
@


9.7.6.1
log
@with newbarrier
@
text
@a521 2
	bzero(&Tmk_stat,sizeof(struct Tmk_stat));

a537 2

	Tmk_barrier_initialize_new();
@


9.7.2.1
log
@Start of the 0.9.8 development branch
@
text
@d571 1
a571 1
	Tmk_err("TreadMarks Version 0.9.8 of %s"
@


9.7.2.2
log
@Added a cast to the first argument to gethostbyaddr.  This eliminates
a warning under AIX 4.1.
@
text
@d456 1
a456 1
			if ((host = gethostbyaddr((char *)&addr, sizeof(addr), AF_INET)) == 0)
@


9.7.2.3
log
@Added "-n" to the rsh argument list in start_process.
@
text
@a84 2
 * $Id$
 *
d283 1
a283 1
		sprintf(command, "rsh -n %s \"%s\"", hostname, string);
d285 1
a285 1
		sprintf(command, "remsh -n %s \"%s\"", hostname, string);
@


9.7.2.4
log
@Updated the copyright.
@
text
@d3 1
a3 1
 *  Copyright (c) 1991-1996						     *
d85 1
a85 1
 * $Id: startup.c,v 9.7.2.3 1996/05/03 03:59:37 alc Exp alc $
d575 1
a575 1
		"Copyright (c) ParallelTools, L.L.C., 1991-1996\n"
d581 1
a581 1
		"Copyright (c) ParallelTools, L.L.C., 1991-1996\n",
@


9.7.2.5
log
@Moved the "-n" option to "rsh" in start_process.  AIX requires
the hostname to come before the "-n".
@
text
@d85 1
a85 1
 * $Id: startup.c,v 9.7.2.4 1996/05/03 04:16:53 alc Exp alc $
d285 1
a285 1
		sprintf(command, "rsh %s -n \"%s\"", hostname, string);
d287 1
a287 1
		sprintf(command, "remsh %s -n \"%s\"", hostname, string);
@


9.7.2.6
log
@Added the "-m" option to specify the starting address of the shared heap.
Tmk_startup recognizes this option and start_process generates it.
@
text
@d85 1
a85 1
 * $Id: startup.c,v 9.7.2.5 1996/05/03 16:13:41 alc Exp alc $
d243 1
a243 1
		sprintf(sptr, "%s-i%d -m%d", sptr, i, page_array_[0].vadr);
d245 1
a245 1
		sprintf(sptr, "%s-- -i%d -m%d", sptr, i, page_array_[0].vadr);
d374 1
a374 1
	while ((c = getopt(argc, argv, "D:df:h:I:i:m:n:p:rstxX:")) != -1)
a395 3
			continue;
		case 'm':
			page_array_[0].vadr = (caddr_t) atoi(optarg);
@


9.6
log
@Tmk-0.9.6R
@
text
@d571 1
a571 1
	Tmk_err("TreadMarks Version 0.9.6 of %s"
@


9.6.1.1
log
@Tmk-0.9.6R: FASTLINK Version
@
text
@a100 2
unsigned	Tmk_proc_mask = 1;

a102 2
unsigned	Tmk_mask;

a393 1
			Tmk_proc_mask = 1 << Tmk_proc_id;
a520 2

	Tmk_mask = (1 << Tmk_nprocs) - 1;
@


9.5
log
@Tmk-0.9.5R
@
text
@d3 2
a4 2
 *  Copyright (c) 1991-1994                                                  *
 *  by TreadMarks, L.L.C. (TREADMARKS), Houston, Texas	  		     *
d6 5
a10 5
 *  This software is furnished under a license and may be used and  copied   *
 *  only  in  accordance  with  the  terms  of  such  license and with the   *
 *  inclusion of the above copyright notice.  This software or  any  other   *
 *  copies  thereof may not be provided or otherwise made available to any   *
 *  other person.  No title to or ownership of  the  software  is  hereby    *
d15 2
a16 2
 *  confidential and proprietary to TREADMARKS.  RECIPIENT agrees to take    *
 *  all reasonable steps to safeguard the software, and to prevent its       *
d19 2
a20 2
 *  The information in this software is subject to change  without  notice   *
 *  and should  not  be  construed  as  a commitment by TREADMARKS.	     *
d24 6
a29 7
 *  of merchantability or fitness), with regard to the software.  	     *
 *  TREADMARKS assumes no responsibility for the use or reliability of its   *
 *  software.  TREADMARKS shall not be liable for any special, incidental,   *
 *  or consequential damages, or any damages whatsoever due to causes beyond *
 *  the reasonable control of TREADMARKS, loss of use, data or profits, or   *
 *  from loss or destruction of materials provided to TREADMARKS by	     *
 *  RECIPIENT.								     *
d31 4
a34 4
 *  TREADMARKS's liability for damages arising out of or in connection with  *
 *  the use or performance of this software, whether in an action of	     *
 *  contract or tort including negligence, shall be limited to the purchase  *
 *  price, or the total amount paid by RECIPIENT, whichever is less.	     *
a61 1
 *
a73 2
 *	Version 0.9.3
 *
d81 4
d486 1
a486 1
				break;
d490 1
a490 1

d571 1
a571 1
	Tmk_err("TreadMarks Version 0.9.5 of %s"
d573 1
a573 1
		"Copyright (c) TreadMarks, L.L.C., 1991-1995\n"
d579 1
a579 1
		"Copyright (c) TreadMarks, L.L.C., 1991-1995\n",
d588 1
a588 1
			"\tPlease contact TreadMarks, L.L.C.\n"
@


9.5.1.1
log
@Tmk-0.9.5R: FASTLINK Version
@
text
@d80 2
a81 1
 *	xx-Jun-1995	Rob Fowler	Added IBM Load Leveler support
a100 2
unsigned	Tmk_proc_mask = 1;

a102 2
unsigned	Tmk_mask;

d372 1
a372 1
	while ((c = getopt(argc, argv, "D:df:h:I:i:n:p:rstx")) != -1)
a393 1
			Tmk_proc_mask = 1 << Tmk_proc_id;
d418 4
d486 1
a486 1
				goto escape;
d490 1
a490 3
		if (i > NPROCS)
			Tmk_errexit("Tmk_startup: %s exceeds the %d-process limit.\n", cp, NPROCS);
	escape:
d507 3
a509 1
	if (i < Tmk_nprocs)
a520 2

	Tmk_mask = (1 << Tmk_nprocs) - 1;
@


9.4
log
@Tmk-0.9.4R
@
text
@d78 7
d167 1
d169 11
d244 5
a248 1

d257 16
a272 1
#if !defined(ultrix)
d325 3
d329 1
d342 13
d367 3
d372 1
a372 1
	while ((c = getopt(argc, argv, "D:df:h:I:i:n:p:rstx")) != -1)
d412 1
d418 4
d426 14
d441 23
d466 4
d486 1
a486 1
				goto escape;
d490 1
a490 3
		if (i > NPROCS)
			Tmk_errexit("Tmk_startup: %s exceeds the %d-process limit.\n", cp, NPROCS);
	escape:
d495 6
a500 1
			Tmk_errexit("Tmk_startup: -f and -h are incompatible\n");
d507 3
a509 1
	if (i < Tmk_nprocs)
d571 1
a571 1
	Tmk_err("TreadMarks Version 0.9.4 of %s"
@
