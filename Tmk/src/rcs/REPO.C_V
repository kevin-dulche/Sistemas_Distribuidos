head	11.15;
access;
symbols
	Tmk-1_0_3_2R:10.10.1.13.0.2
	Tmk-1_0_3_1R:10.10.1.13.0.2
	Tmk-2_0:10.10.1
	Tmk-1_2_TO-2_0_BRANCH_POINT:10.10.1.20
	Tmk-1_0_3R:10.10.1.13.0.1
	Tmk-1_2:10.10.1
	Tmk-1_0_TO-1_2_BRANCH_POINT:10.10.1.13
	Tmk-1_0_1R:10.10.1.5
	Tmk-1_1:11
	Tmk-1_0:10.10.1.13.0
	Tmk-1_0_TO-1_1_BRANCH_POINT:10.10
	Tmk-0_10_1_2R:10.1.3.2
	Tmk-0_10_1_1R:10.1.3.1
	Tmk-0_10_1R:10.1;
locks; strict;
comment	@ * @;


11.15
date	98.06.25.17.50.14;	author alc;	state Exp;
branches;
next	11.14;

11.14
date	97.08.20.04.13.43;	author alc;	state Exp;
branches;
next	11.13;

11.13
date	97.08.19.06.11.25;	author alc;	state Exp;
branches;
next	11.12;

11.12
date	97.08.19.04.58.45;	author alc;	state Exp;
branches;
next	11.11;

11.11
date	97.08.18.22.30.52;	author alc;	state Exp;
branches;
next	11.10;

11.10
date	97.07.24.19.49.03;	author alc;	state Exp;
branches;
next	11.9;

11.9
date	97.07.15.07.34.29;	author alc;	state Exp;
branches;
next	11.8;

11.8
date	97.07.15.07.01.13;	author alc;	state Exp;
branches;
next	11.7;

11.7
date	97.07.14.18.45.11;	author alc;	state Exp;
branches;
next	11.6;

11.6
date	97.07.11.18.43.05;	author alc;	state Exp;
branches;
next	11.5;

11.5
date	97.07.10.06.35.10;	author alc;	state Exp;
branches;
next	11.4;

11.4
date	97.06.26.22.54.02;	author alc;	state Exp;
branches;
next	11.3;

11.3
date	97.06.26.04.07.31;	author alc;	state Exp;
branches;
next	11.2;

11.2
date	97.06.25.18.31.35;	author alc;	state Exp;
branches;
next	11.1;

11.1
date	97.05.27.02.25.29;	author alc;	state Exp;
branches;
next	10.10;

10.10
date	97.05.10.17.04.55;	author alc;	state Exp;
branches
	10.10.1.1;
next	10.9;

10.9
date	97.05.10.06.58.28;	author alc;	state Exp;
branches;
next	10.8;

10.8
date	97.05.09.21.33.51;	author alc;	state Exp;
branches;
next	10.7;

10.7
date	97.05.09.07.15.20;	author alc;	state Exp;
branches;
next	10.6;

10.6
date	96.08.24.21.10.49;	author alc;	state Exp;
branches;
next	10.5;

10.5
date	96.08.24.20.01.11;	author alc;	state Exp;
branches;
next	10.4;

10.4
date	96.08.09.21.06.14;	author alc;	state Exp;
branches;
next	10.3;

10.3
date	96.08.08.04.50.50;	author alc;	state Exp;
branches;
next	10.2;

10.2
date	96.08.03.21.11.19;	author alc;	state Exp;
branches;
next	10.1;

10.1
date	96.05.27.04.45.30;	author alc;	state Rel;
branches
	10.1.2.1
	10.1.3.1
	10.1.4.1
	10.1.5.1;
next	10.0;

10.0
date	96.03.15.09.47.40;	author alc;	state Rel;
branches
	10.0.1.1
	10.0.2.1
	10.0.3.1;
next	9.7;

9.7
date	96.03.15.09.39.04;	author alc;	state Rel;
branches
	9.7.2.1
	9.7.6.1;
next	9.6;

9.6
date	96.03.15.09.30.03;	author alc;	state Rel;
branches
	9.6.1.1;
next	9.5;

9.5
date	96.03.15.09.24.56;	author alc;	state Rel;
branches
	9.5.1.1;
next	9.4;

9.4
date	96.03.15.09.20.45;	author alc;	state Rel;
branches;
next	;

9.5.1.1
date	96.03.15.09.27.09;	author alc;	state Rel;
branches;
next	;

9.6.1.1
date	96.03.15.09.32.19;	author alc;	state Rel;
branches;
next	;

9.7.2.1
date	96.03.17.18.00.32;	author alc;	state Exp;
branches;
next	;

9.7.6.1
date	96.07.23.18.42.25;	author zhenghua;	state Exp;
branches;
next	;

10.0.1.1
date	96.03.15.09.51.03;	author alc;	state Rel;
branches;
next	;

10.0.2.1
date	96.03.17.18.12.04;	author alc;	state Exp;
branches;
next	10.0.2.2;

10.0.2.2
date	96.03.18.01.25.13;	author alc;	state Exp;
branches
	10.0.2.2.2.1;
next	;

10.0.2.2.2.1
date	96.03.25.21.00.30;	author alc;	state Exp;
branches;
next	10.0.2.2.2.2;

10.0.2.2.2.2
date	96.03.27.06.35.39;	author alc;	state Exp;
branches;
next	10.0.2.2.2.3;

10.0.2.2.2.3
date	96.03.30.21.34.52;	author alc;	state Exp;
branches;
next	;

10.0.3.1
date	96.04.22.16.59.08;	author alc;	state Exp;
branches;
next	;

10.1.2.1
date	96.06.25.19.28.51;	author tmiller;	state Exp;
branches;
next	;

10.1.3.1
date	96.11.14.06.25.07;	author alc;	state Rel;
branches;
next	10.1.3.2;

10.1.3.2
date	97.05.10.20.54.50;	author alc;	state Rel;
branches;
next	;

10.1.4.1
date	96.07.29.21.09.00;	author rjf;	state Exp;
branches;
next	10.1.4.2;

10.1.4.2
date	96.07.30.20.52.50;	author rjf;	state Exp;
branches;
next	;

10.1.5.1
date	96.06.27.16.38.16;	author tmiller;	state Exp;
branches;
next	10.1.5.2;

10.1.5.2
date	96.06.27.23.05.15;	author tmiller;	state Exp;
branches;
next	10.1.5.3;

10.1.5.3
date	96.06.28.18.27.47;	author tmiller;	state Exp;
branches;
next	10.1.5.4;

10.1.5.4
date	96.07.02.22.34.57;	author tmiller;	state Exp;
branches;
next	10.1.5.5;

10.1.5.5
date	96.07.03.19.32.35;	author tmiller;	state Exp;
branches;
next	10.1.5.6;

10.1.5.6
date	96.08.07.17.38.29;	author tmiller;	state Exp;
branches;
next	;

10.10.1.1
date	97.07.03.19.25.48;	author alc;	state Exp;
branches;
next	10.10.1.2;

10.10.1.2
date	97.07.03.20.55.41;	author alc;	state Exp;
branches;
next	10.10.1.3;

10.10.1.3
date	97.07.22.18.12.09;	author alc;	state Exp;
branches;
next	10.10.1.4;

10.10.1.4
date	97.07.22.19.17.49;	author alc;	state Exp;
branches;
next	10.10.1.5;

10.10.1.5
date	98.01.07.07.27.29;	author alc;	state Exp;
branches;
next	10.10.1.6;

10.10.1.6
date	98.03.22.05.24.55;	author alc;	state Exp;
branches;
next	10.10.1.7;

10.10.1.7
date	98.05.09.19.24.29;	author alc;	state Exp;
branches;
next	10.10.1.8;

10.10.1.8
date	98.05.10.05.06.23;	author alc;	state Exp;
branches;
next	10.10.1.9;

10.10.1.9
date	98.05.14.20.10.16;	author alc;	state Exp;
branches;
next	10.10.1.10;

10.10.1.10
date	98.06.13.18.39.11;	author alc;	state Exp;
branches;
next	10.10.1.11;

10.10.1.11
date	98.06.20.05.39.13;	author alc;	state Exp;
branches;
next	10.10.1.12;

10.10.1.12
date	98.06.24.06.53.35;	author alc;	state Exp;
branches;
next	10.10.1.13;

10.10.1.13
date	98.07.07.06.25.32;	author alc;	state Exp;
branches
	10.10.1.13.0.1;
next	10.10.1.14;

10.10.1.14
date	98.07.17.04.47.02;	author alc;	state Exp;
branches;
next	10.10.1.15;

10.10.1.15
date	98.07.26.05.25.28;	author alc;	state Exp;
branches;
next	10.10.1.16;

10.10.1.16
date	98.07.26.06.26.40;	author alc;	state Exp;
branches;
next	10.10.1.17;

10.10.1.17
date	98.07.27.18.42.55;	author alc;	state Exp;
branches;
next	10.10.1.18;

10.10.1.18
date	98.07.31.18.55.59;	author alc;	state Exp;
branches;
next	10.10.1.19;

10.10.1.19
date	98.07.31.20.17.33;	author alc;	state Exp;
branches;
next	10.10.1.20;

10.10.1.20
date	98.09.02.04.22.12;	author alc;	state Exp;
branches;
next	;

10.10.1.13.0.1
date	98.07.17.03.40.52;	author alc;	state Exp;
branches;
next	10.10.1.13.0.2;

10.10.1.13.0.2
date	98.09.02.04.18.54;	author alc;	state Exp;
branches;
next	;


desc
@@


11.15
log
@Merge -1_0 revisions 10.10.1.11 and 10.10.1.12.
@
text
@/*****************************************************************************
 *                                                                           *
 *  Copyright (c) 1991-1996						     *
 *  by ParallelTools, L.L.C. (PTOOLS), Houston, Texas			     *
 *                                                                           *
 *  This software is furnished under a license and may be used and copied    *
 *  only in accordance with the terms of such license and with the	     *
 *  inclusion of the above copyright notice.  This software or any other     *
 *  copies thereof may not be provided or otherwise made available to any    *
 *  other person.  No title to or ownership of the software is hereby	     *
 *  transferred.                                                             *
 *									     *
 *  The recipient of this software (RECIPIENT) acknowledges and agrees that  *
 *  the software contains information and trade secrets that are	     *
 *  confidential and proprietary to PTOOLS.  RECIPIENT agrees to take all    *
 *  reasonable steps to safeguard the software, and to prevent its	     *
 *  disclosure.								     * 
 *                                                                           *
 *  The information in this software is subject to change without notice     *
 *  and should not be construed as a commitment by PTOOLS.		     *
 *                                                                           *
 *  This software is furnished AS IS, without warranty of any kind, either   *
 *  express or implied (including, but not limited to, any implied warranty  *
 *  of merchantability or fitness), with regard to the software.  PTOOLS     *
 *  assumes no responsibility for the use or reliability of its software.    *
 *  PTOOLS shall not be liable for any special,	incidental, or		     *
 *  consequential damages, or any damages whatsoever due to causes beyond    *
 *  the reasonable control of PTOOLS, loss of use, data or profits, or from  *
 *  loss or destruction of materials provided to PTOOLS by RECIPIENT.	     *
 *									     *
 *  PTOOLS's liability for damages arising out of or in connection with the  *
 *  use or performance of this software, whether in an action of contract    *
 *  or tort including negligence, shall be limited to the purchase price,    *
 *  or the total amount paid by RECIPIENT, whichever is less.		     *
 *                                                                           *
 *****************************************************************************/

/*
 * $Id: repo.c,v 11.14 1997/08/20 04:13:43 alc Exp alc $
 *
 * Description:    
 *	storage reclamation routines
 *
 * External Functions:
 *			Tmk_repo
 *			Tmk_repo_sigio_handler
 *			Tmk_repo_initialize
 *
 * Facility:	TreadMarks Distributed Shared Memory System
 * History:
 *	17-Jun-1993	Alan L. Cox	Created
 *	26-Oct-1993	Alan L. Cox	Updated the manager for empty pages
 *	18-Jul-1994	Alan L. Cox	Reduced the number of page replicas
 *
 *	Version 0.9.0
 *
 *	Version 0.9.1
 *
 *	Version 0.9.2
 *
 *	29-Apr-1995	Alan L. Cox	Adapted for STREAMS
 *	15-Jun-1995	Cristiana Amza	Adapted for HPPA/HPUX
 *
 *	Version 0.9.3
 *
 *	27-Jan-1996	Alan L. Cox	Replaced sigblock and sigsetmask
 *					 with sigprocmask
 *	Version 0.10
 */
#include "Tmk.h"

static	struct	req	{
	unsigned	seqno;
	unsigned char	from;
	unsigned char	type;
}			req_typ = { /*seqno=*/0, /*from=*/0, /*type=*/REQ_REPO };

static volatile
	unsigned	repo_mask;
static	unsigned	repo_seqno_[NPROCS];

/*
 *
 */
void	Tmk_repo_sigio_handler(req)
	struct	req    *req;
{
	repo_seqno_[req->from] = req->seqno;

	repo_mask |= 1 << req->from;
}

/*
 *
 */
void	Tmk_repo_sigio_duplicate_handler(req)
	struct	req    *req;
{
	if ((repo_mask & (1 << req->from)) == 0)
		if (0 > send(rep_fd_[req->from], (char *)&req->seqno, sizeof(req->seqno), 0))
			Tmk_perrexit("<send>Tmk_repo_sigio_duplicate_handler");
}

/*
 * Update the last writer for the page (used by Tmk_page_request)
 * if a diff is newer.  The diff creator assumes ownership
 * of the page.
 */
static
void	repo_update_writer( page_t page )
{
	unsigned short *vector_time_ = page->vector_time_;

	int	j, k;

	for (j = 0; j < Tmk_nprocs; j++) {

		write_notice_t	write_notice = page->write_notice_[j];

		if (write_notice) {

			interval_t	interval = write_notice->interval;

			for (k = 0; k < Tmk_nprocs; k++)
				if (vector_time_[k] > interval->vector_time_[k])
					goto gtr;

			page->writer = page->owner = interval->id;

			vector_time_ = interval->vector_time_;
		gtr:
			continue;
		}
	}
}

/*
 *
 */
static
void	repo_barrier( void )
{
	if (Tmk_proc_id == 0) {

		int	j;

		while (repo_mask ^ Tmk_spinmask)
			sigio_handler();

		repo_mask = 0;

		for (j = 1; j < Tmk_nprocs; j++)
			if (0 > send(rep_fd_[j], (char *)&repo_seqno_[j], sizeof(rep_seqno_[j]), 0))
				Tmk_perrexit("<send>repo_barrier");
	}
	else {
		sigset_t	mask;

		unsigned	rep_seqno;

		req_typ.seqno = req_seqno += SEQNO_INCR;
	rexmit:
		if (0 > send(req_fd_[0], (char *)&req_typ, sizeof(req_typ), 0))
			Tmk_perrexit("<send>repo_barrier");

		Tmk_tout_flag = 0;

		setitimer(ITIMER_REAL, &Tmk_tout, NULL);

		sigio_mutex(SIG_UNBLOCK, &ALRM_and_IO_mask, &mask);
	retry:
		if (0 > recv(req_fd_[0], (char *)&rep_seqno, sizeof(rep_seqno), 0))
			if (Tmk_tout_flag) {

				if (Tmk_debug)
					Tmk_err("<timeout: 0>repo_barrier: seqno == %d\n", req_typ.seqno);

				sigio_mutex(SIG_SETMASK, &mask, NULL);

				goto rexmit;
			}
			else if (errno == EINTR)
				goto retry;
			else
				Tmk_perrexit("<recv>repo_barrier");

		if (rep_seqno != req_typ.seqno) {

			if (Tmk_debug)
				Tmk_err("<bad seqno: 0>repo_barrier: seqno == %d (received: %d)\n", req_typ.seqno, rep_seqno);

			goto retry;
		}
		sigio_mutex(SIG_SETMASK, &mask, NULL);

		Tmk_stat.messages++;
		Tmk_stat.bytes += sizeof(rep_seqno);
	}
}

/*
 * The caller must block sigio
 */
void	Tmk_repo( void )
{
	int	first_page_id, i, j, k, last_page_id;

	if (Tmk_debug)
		Tmk_err("repo: begin\n");

	Tmk_stat.repos++;

	last_page_id  = -1;
	first_page_id = Tmk_npages;

	for (i = 0; i < Tmk_nprocs; i++) {

		interval_t	interval = &proc_array_[i];

		while ((interval = interval->prev) != &proc_array_[i]) {

			write_notice_range_t	write_notice_range = &interval->head;

			do {
				if (write_notice_range->first < first_page_id)
					first_page_id = write_notice_range->first;

				if (write_notice_range->last > last_page_id)
					last_page_id = write_notice_range->last;

			} while ((write_notice_range = write_notice_range->next) != NULL);
		}
	}
	for (i = first_page_id; i < last_page_id; i++) {

		page_t	page = &page_array_[i];

		if (page->state == shared) {

			if (page->twin) {

				Tmk_free_twin(page);

				/*
				 * If the page's state is shared, and it has a twin, then
				 * it is invalid on the other processors.  This processor
				 * assumes ownership.
				 */
				page->state = exclusive;
				page->writer = page->owner = Tmk_proc_id;
			}
		}
		else if (page->state == invalid) {

			if (Tmk_debug)
				Tmk_err("page: %d ", i);

			if (page->proto == single_writer) {

				if (page->writer == Tmk_proc_id) {

					assert(page->owner == Tmk_proc_id);

					if (0 > mprotect(page->vadr, Tmk_page_size, PROT_READ|PROT_WRITE))
						Tmk_perrexit("Tmk_repo<mprotect>");

					page->state = shared;

					Tmk_diff_request(page);

					page->state = exclusive;
				}
				else
					assert(page->empty);
			}
			else {
				if (page->empty) {
			empty:
					repo_update_writer(page);

					if (Tmk_debug)
						Tmk_err("discarded\n");
				}
				else {
					write_notice_t	write_notice = page->write_notice_[Tmk_proc_id];

					if (write_notice) {

						unsigned short	time = write_notice->interval->vector_time_[Tmk_proc_id];

						for (j = 0; j < Tmk_nprocs; j++) {
							if (j == Tmk_proc_id)
								continue;

							write_notice = page->write_notice_[j];

							if (write_notice &&
							    write_notice->interval->vector_time_[Tmk_proc_id] >= time) {

								page->empty = 1;

								goto empty;
							}
						}
					}
					else if (page->writer == Tmk_proc_id) {

						unsigned short *vector_time_ = page->vector_time_;

						for (j = 0; j < Tmk_nprocs; j++) {
							if (j == Tmk_proc_id)
								continue;

							write_notice = page->write_notice_[j];

							if (write_notice) {

								interval_t	interval = write_notice->interval;

								for (k = 0; k < Tmk_nprocs; k++)
									if (vector_time_[k] > interval->vector_time_[k])
										goto gtr;

								page->empty = 1;

								goto empty;
							}
						gtr:
							;
						}
					}
					else {
						page->empty = 1;

						goto empty;
					}
					if (0 > mprotect(page->vadr, Tmk_page_size, PROT_READ|PROT_WRITE))
						Tmk_perrexit("<mprotect>Tmk_repo");

					page->state = shared;

					Tmk_diff_request(page);
					
					if (0 > mprotect(page->vadr, Tmk_page_size, PROT_READ))
						Tmk_perrexit("<mprotect>Tmk_repo");
				}
			}
		}
		else
			assert((page->state == exclusive) &&
			       (page->writer == Tmk_proc_id) &&
			       (page->owner == Tmk_proc_id));
	}
	repo_barrier();

	for (i = 0; i < Tmk_nprocs; i++) {

		proc_array_[i].prev = proc_array_[i].next = &proc_array_[i];

		proc_vector_time_[i] = inverse_time_[i] = 0;
	}
	for (i = first_page_id; i < last_page_id; i++) {

		page_t	page = &page_array_[i];

		page->vector_time_ = proc_array_[0].vector_time_;

		memset(page->write_notice_, 0, sizeof(page->write_notice_));
	}
	Tmk_diff_repo();

	Tmk_interval_repo();

	/*
	 * Prevent a post repo lock request from receiving out-of-date
	 * consistency information.  Without the following repo
	 * barrier, a post repo lock request might be handled within
	 * the earlier repo barrier (before the consistency
	 * information is flushed). 
	 */
	repo_barrier();

	if (Tmk_debug)
		Tmk_err("repo: end\n");
}

/*
 *
 */
void	Tmk_repo_initialize( void )
{
	req_typ.from = Tmk_proc_id;
}
@


11.14
log
@Added a stricter assertion check to Tmk_repo.
@
text
@d39 1
a39 1
 * $Id: repo.c,v 11.13 1997/08/19 06:11:25 alc Exp alc $
d206 1
a206 1
	int	i, j, k;
d213 22
a234 1
	for (i = 0; i < Tmk_npages; i++) {
d362 1
a362 1
	for (i = 0; i < Tmk_npages; i++) {
a366 2

		assert(page->twin == 0);
@


11.13
log
@Modified the "Tmk_repo" procedure: if the page is shared and has a twin,
assume ownership of the page.
@
text
@d39 1
a39 1
 * $Id: repo.c,v 11.12 1997/08/19 04:58:45 alc Exp alc $
d329 3
a331 1
			assert(page->state == exclusive);
@


11.12
log
@Modified the "repo_update_writer" procedure so that the diff creator
assumes ownership of the page.
@
text
@d39 1
a39 1
 * $Id: repo.c,v 11.11 1997/08/18 22:30:52 alc Exp alc $
d229 1
a229 1
				page->writer = Tmk_proc_id;
@


11.11
log
@Eliminated the unused "writer" variable from the "repo_update_writer"
procedure.

Commented the "repo_update_writer" procedure.
@
text
@d39 1
a39 1
 * $Id: repo.c,v 11.10 1997/07/24 19:49:03 alc Exp alc $
d106 2
a107 1
 * if a diff is newer.
d128 1
a128 1
			page->writer = interval->id;
@


11.10
log
@Don't bother checking tmk_stat_flag for cheap to collect statistics.
(Identical to revision 10.10.1.4.)
@
text
@d39 1
a39 1
 * $Id: repo.c,v 11.9 1997/07/15 07:34:29 alc Exp alc $
d105 2
a106 1
 *
a110 1
	int		writer	     = page->writer;
@


11.9
log
@Added repo count to the statistics.
@
text
@d39 1
a39 1
 * $Id: repo.c,v 11.8 1997/07/15 07:01:13 alc Exp alc $
d210 1
a210 2
	if (tmk_stat_flag)
		Tmk_stat.repos++;
@


11.8
log
@Modified Tmk_repo to handle pages with both single-writer and
multiple-writer notices.
@
text
@d39 1
a39 1
 * $Id: repo.c,v 11.7 1997/07/14 18:45:11 alc Exp alc $
d209 3
@


11.7
log
@Modified to support the adaptive protocol.  Further modifications
are still required.
@
text
@d39 1
a39 1
 * $Id: repo.c,v 11.6 1997/07/11 18:43:05 alc Exp alc $
d108 1
a108 2
int	repo_update_writer(
	page_t	page)
d110 3
d117 1
a117 1
		write_notice_t	write_notice;
d119 1
a119 1
		if (write_notice = page->write_notice_[j]) {
d123 3
a125 2
			for (j++; j < Tmk_nprocs; j++)
				if (write_notice = page->write_notice_[j]) {
a126 8
					for (k = 0; k < NPROCS; k++)
						if (interval->vector_time_[k] > write_notice->interval->vector_time_[k])
							goto gtr;

					interval = write_notice->interval;
				gtr:
					continue;
				}
d129 3
a131 1
			return 1;
a133 1
	return 0;
d205 1
a205 1
	int	i, j;
d236 3
a238 1
				if (page->owner == Tmk_proc_id) {
a251 2
			else if (page->empty) {
			}
d253 24
a276 1
				write_notice_t	write_notice = page->write_notice_[Tmk_proc_id];
d278 11
a288 1
				if (write_notice) {
d290 1
a290 1
					unsigned short	time = write_notice->interval->vector_time_[Tmk_proc_id];
d292 1
a292 3
					for (j = 0; j < Tmk_nprocs; j++) {
						if (j == Tmk_proc_id)
							continue;
d294 1
a294 1
						if (write_notice = page->write_notice_[j]) {
d296 10
a305 2
							if (write_notice->interval->vector_time_[Tmk_proc_id] >= time)
								goto discard;
d308 5
d319 1
a319 1

a322 10
				else {
			discard:
					page->empty = 1;

					if (0 == repo_update_writer(page))
						Tmk_errexit("Tmk_repo<repo_update_writer>\n");

					if (Tmk_debug)
						Tmk_err("discarded\n");
				}
d330 1
a330 1
	for (i = 0; i < NPROCS; i++) {
@


11.6
log
@Eliminated the Ultrix-specific code.
@
text
@d39 1
a39 1
 * $Id: repo.c,v 11.5 1997/07/10 06:35:10 alc Exp alc $
a132 1
			page->vector_time_ = proc_array_[0].vector_time_;
a219 2
			page->proto = single_writer;	/* XXX */

d224 5
d230 1
a234 2
			write_notice_t	write_notice;

d238 22
a259 1
			if (write_notice = page->write_notice_[Tmk_proc_id]) {
d261 1
a261 1
				unsigned short	time = write_notice->interval->vector_time_[Tmk_proc_id];
d263 3
a265 3
				for (j = 0; j < Tmk_nprocs; j++) {
					if (j == Tmk_proc_id)
						continue;
d267 1
a267 1
					if (write_notice = page->write_notice_[j]) {
d269 3
a271 2
						if (write_notice->interval->vector_time_[Tmk_proc_id] >= time)
							goto discard;
d273 2
a274 2
				}
				page->state = shared;
d276 1
a276 2
				if (0 > mprotect(page->vadr, Tmk_page_size, PROT_READ|PROT_WRITE))
					Tmk_perrexit("<mprotect>Tmk_repo");
d278 1
a278 1
				Tmk_diff_request(page);
d280 6
a285 6
				if (0 > mprotect(page->vadr, Tmk_page_size, PROT_READ))
					Tmk_perrexit("<mprotect>Tmk_repo");
			}
			else {
		discard:
				page->empty = 1;
d287 2
a288 2
				if (0 == repo_update_writer(page))
					Tmk_errexit("Tmk_repo\n");
d290 3
a292 2
				if (Tmk_debug)
					Tmk_err("discarded\n");
@


11.5
log
@Use the new page states.  Rename "page->mode" to "page->proto".
@
text
@d39 1
a39 1
 * $Id: repo.c,v 11.4 1997/06/26 22:54:02 alc Exp alc $
a99 4
#if defined(ultrix)
		if (0 > write(rep_fd_[req->from], &req->seqno, sizeof(req->seqno)))
			Tmk_perrexit("<write>Tmk_repo_sigio_duplicate_handler");
#else
a101 1
#endif
a156 4
#if defined(ultrix)
			if (0 > write(rep_fd_[j], &repo_seqno_[j], sizeof(rep_seqno_[j])))
				Tmk_perrexit("<write>repo_barrier");
#else
a158 1
#endif
a166 4
#if defined(ultrix)
		if (0 > write(req_fd_[0], &req_typ, sizeof(req_typ)))
			Tmk_perrexit("<write>repo_barrier");
#else
d169 1
a169 1
#endif
a175 3
#if defined(ultrix)
		if (0 > read(req_fd_[0], &rep_seqno, sizeof(rep_seqno)))
#else
a176 1
#endif
a188 3
#if defined(ultrix)
				Tmk_perrexit("<read>repo_barrier");
#else
d190 1
a190 1
#endif
@


11.4
log
@Renamed "page->SW_WN_vector_time_" to "page->vector_time_".  Deleted
"page->time".
@
text
@d39 1
a39 1
 * $Id: repo.c,v 11.3 1997/06/26 04:07:31 alc Exp alc $
d240 1
a240 1
		if (page->state == valid) {
d242 1
a242 1
			page->mode = single_writer;
d248 1
a248 1
				page->state = private;
d272 2
d284 1
a284 1
				page->state = empty;
d293 2
a294 2
		else if (page->state == empty)
			repo_update_writer(page);
@


11.3
log
@Added "page->SW_WN_vector_time_" alongside "page->time".  Changed
"page->mode" to single writer in one case.
@
text
@d39 1
a39 1
 * $Id: repo.c,v 11.2 1997/06/25 18:31:35 alc Exp alc $
d138 1
a138 3

			page->SW_WN_vector_time_ = proc_array_[0].vector_time_;
			page->time = 0;
d306 1
a306 2
		page->time = 0;
		page->SW_WN_vector_time_ = proc_array_[0].vector_time_;
@


11.2
log
@Replaced "page->manager" by "page->writer".
@
text
@d39 1
a39 1
 * $Id: repo.c,v 11.1 1997/05/27 02:25:29 alc Exp alc $
d139 3
d244 2
d307 3
@


11.1
log
@Replaced static spinmask by extern Tmk_spinmask.  (Required
by Tmk_spawn.)
@
text
@d39 1
a39 1
 * $Id: repo.c,v 10.10 1997/05/10 17:04:55 alc Exp alc $
d113 1
a113 1
int	repo_update_manager(
d137 1
a137 1
			page->manager = interval->id;
d281 1
a281 1
				if (0 == repo_update_manager(page))
d289 1
a289 1
			repo_update_manager(page);
@


10.10
log
@Modified repo barrier to always unmask SIGALRM and SIGIO, rather
than accept a sigset to unmask as its argument.  Eliminated the
ALRM_mask in Tmk_repo.  It's okay to unblock SIGIO in the second
repo barrier.
@
text
@d39 1
a39 1
 * $Id: repo.c,v 10.9 1997/05/10 06:58:28 alc Exp alc $
a81 2
static	unsigned	spinmask;

d155 1
a155 1
		while (spinmask ^ repo_mask)
a328 2
	spinmask = ((1 << Tmk_nprocs) - 1) &~ (1 << Tmk_proc_id);

@


10.10.1.1
log
@Eliminated the Ultrix-specific code.
@
text
@d39 1
a39 1
 * $Id: repo.c,v 10.10 1997/05/10 17:04:55 alc Exp alc $
d102 4
d108 1
d163 4
d169 1
d178 4
d184 1
a184 1

d191 3
d195 1
d208 3
d212 1
a212 1

@


10.10.1.2
log
@Added basic Pthreads support.
@
text
@a249 1
#if ! defined(PTHREADS)
d252 1
a252 1
#endif
@


10.10.1.3
log
@Added repo count to the statistics.  (This change is
identical to revision 11.9.)
@
text
@d39 1
a39 1
 * $Id: repo.c,v 10.10.1.2 1997/07/03 20:55:41 alc Exp alc $
a214 3

	if (tmk_stat_flag)
		Tmk_stat.repos++;
@


10.10.1.4
log
@Don't bother checking tmk_stat_flag for cheap to collect statistics.
@
text
@d39 1
a39 1
 * $Id: repo.c,v 10.10.1.3 1997/07/22 18:12:09 alc Exp alc $
d216 2
a217 1
	Tmk_stat.repos++;
@


10.10.1.5
log
@Use a single GLOBAL spinmask instead of multiple static spinmasks.
@
text
@d39 1
a39 1
 * $Id: repo.c,v 10.10.1.4 1997/07/22 19:17:49 alc Exp alc $
d82 2
d152 1
a152 1
		while (repo_mask ^ Tmk_spinmask)
d313 2
@


10.10.1.6
log
@Change NPROCS to Tmk_nprocs.
@
text
@d39 1
a39 1
 * $Id: repo.c,v 10.10.1.5 1998/01/07 07:27:29 alc Exp alc $
d111 1
a111 1
	int	j;
d124 1
a124 3
					int	k = 0;

					do {
a126 1
					} while (++k < Tmk_nprocs);
d275 1
a275 1
	memset(proc_vector_time_, 0, sizeof(proc_vector_time_));
d277 1
a277 1
	memset(inverse_time_, 0, sizeof(inverse_time_));
d279 2
@


10.10.1.7
log
@Tmk_diff_request doesn't set the page state anymore.  Do it here.
@
text
@d39 1
a39 1
 * $Id: repo.c,v 10.10.1.6 1998/03/22 05:24:55 alc Exp alc $
a256 2
				page->state = valid;

@


10.10.1.8
log
@Rename "Tmk_free_twin" to "Tmk_twin_free" for consistency
with the rest of the interface.
@
text
@d39 1
a39 1
 * $Id: repo.c,v 10.10.1.7 1998/05/09 19:24:29 alc Exp alc $
d227 1
a227 1
				Tmk_twin_free(page);
@


10.10.1.9
log
@Add Tmk_errno_check, replacing Tmk_perrexit after send and sendmsg.  It
handles the ENOBUF returned by BSD/OS and FreeBSD.
@
text
@d39 1
a39 1
 * $Id: repo.c,v 10.10.1.8 1998/05/10 05:06:23 alc Exp alc $
d100 2
a101 2
		while (0 > send(rep_fd_[req->from], (char *)&req->seqno, sizeof(req->seqno), 0))
			Tmk_errno_check("Tmk_repo_sigio_duplicate_handler<send>");
d159 2
a160 2
			while (0 > send(rep_fd_[j], (char *)&repo_seqno_[j], sizeof(rep_seqno_[j]), 0))
				Tmk_errno_check("repo_barrier<send>");
d169 2
a170 2
		while (0 > send(req_fd_[0], (char *)&req_typ, sizeof(req_typ), 0))
			Tmk_errno_check("repo_barrier<send>");
@


10.10.1.10
log
@Made changes to barrier and sched to facilitate integration
of the FASTLINK barriers:

1. Use a single sigio handler for barriers and scheds (regardless
of whether the manager has arrived or not).

2. Use barrier->mask and sched->mask to determine whether or not
the manager has arrived/joined.

3. Redefine Tmk_spinmask to include the "host" processor.
@
text
@d39 1
a39 1
 * $Id: repo.c,v 10.10.1.9 1998/05/14 20:10:16 alc Exp alc $
d79 1
a79 1
	unsigned	repo_mask = 1;
d156 1
a156 1
		repo_mask = 1;
@


10.10.1.11
log
@Removed a pointless assertion.
@
text
@d39 1
a39 1
 * $Id: repo.c,v 10.10.1.10 1998/06/13 18:39:11 alc Exp alc $
d287 2
@


10.10.1.12
log
@This change represents a significant performance improvement
to the repo code.  The new code scans the consistency data
to compute an upper and lower bound on the pages that repo
must touch.
@
text
@d39 1
a39 1
 * $Id: repo.c,v 10.10.1.11 1998/06/20 05:39:13 alc Exp alc $
d212 1
a212 1
	int	first_page_id, i, j, last_page_id;
d219 1
a219 22
	last_page_id  = -1;
	first_page_id = Tmk_npages;

	for (i = 0; i < Tmk_nprocs; i++) {

		interval_t	interval = &proc_array_[i];

		while ((interval = interval->prev) != &proc_array_[i]) {

			write_notice_range_t	write_notice_range = &interval->head;

			do {
				if (write_notice_range->first_page_id < first_page_id)
					first_page_id = write_notice_range->first_page_id;

				if (write_notice_range->last_page_id > last_page_id)
					last_page_id = write_notice_range->last_page_id;

			} while ((write_notice_range = write_notice_range->next) != NULL);
		}
	}
	for (i = first_page_id; i <= last_page_id; i++) {
d284 1
a284 1
	for (i = first_page_id; i <= last_page_id; i++) {
@


10.10.1.13
log
@Eliminated repo_seqno_.  Use rep_seqno_ instead.
@
text
@d39 1
a39 1
 * $Id: repo.c,v 10.10.1.12 1998/06/24 06:53:35 alc Exp alc $
d80 1
d88 2
d159 1
a159 1
			while (0 > send(rep_fd_[j], (char *)&rep_seqno_[j], sizeof(rep_seqno_[j]), 0))
@


10.10.1.14
log
@Added the "const" attribute to the sigio handler "req" arguments.
(Identical to revision 10.10.1.13.0.1.)
@
text
@d39 1
a39 1
 * $Id: repo.c,v 10.10.1.13.0.1 1998/07/17 03:40:52 alc Exp $
d84 2
a85 3
void
Tmk_repo_sigio_handler(
	const struct req *req)
d93 2
a94 3
void
Tmk_repo_sigio_duplicate_handler(
	const struct req *req)
@


10.10.1.15
log
@Changed the definition of "page_t".  The new definition enables
the use of "const" page pointers.
@
text
@d39 1
a39 1
 * $Id: repo.c,v 10.10.1.14 1998/07/17 04:47:02 alc Exp alc $
d108 1
a108 1
	page_t *page)
d241 1
a241 1
		page_t *page = &page_array_[i];
d306 1
a306 1
		page_t *page = &page_array_[i];
@


10.10.1.16
log
@Changed the definition of "interval_t".
@
text
@d39 1
a39 1
 * $Id: repo.c,v 10.10.1.15 1998/07/26 05:25:28 alc Exp alc $
d118 1
a118 1
			interval_t     *interval = write_notice->interval;
d223 1
a223 1
		interval_t     *interval = &proc_array_[i];
@


10.10.1.17
log
@Renamed "proc_array_" to "proc_interval_".
@
text
@d39 1
a39 1
 * $Id: repo.c,v 10.10.1.16 1998/07/26 06:26:40 alc Exp alc $
d223 1
a223 1
		interval_t     *interval = &proc_interval_[i];
d225 1
a225 1
		while ((interval = interval->prev) != &proc_interval_[i]) {
@


10.10.1.18
log
@Changed the definition of "write_notice_range_t".
@
text
@d39 1
a39 1
 * $Id: repo.c,v 10.10.1.17 1998/07/27 18:42:55 alc Exp alc $
d227 1
a227 2
			write_notice_range_t
				       *write_notice_range = &interval->head;
@


10.10.1.19
log
@Changed the definition of "write_notice_t".
@
text
@d39 1
a39 1
 * $Id: repo.c,v 10.10.1.18 1998/07/31 18:55:59 alc Exp alc $
d114 1
a114 1
		write_notice_t *write_notice;
d255 1
a255 1
			write_notice_t *write_notice;
@


10.10.1.20
log
@Bug Fix!  Added a cast from unsigned short to int so that
a comparison to an int worked properly.  This is a problem
on the Alpha and the RS6k with the AIX 4.2 compilers.
(Identical to revision 10.10.1.13.0.2.)
@
text
@d39 1
a39 1
 * $Id: repo.c,v 10.10.1.19 1998/07/31 20:17:33 alc Exp alc $
d231 1
a231 1
				if ((int) write_notice_range->first_page_id < first_page_id)
d234 1
a234 1
				if ((int) write_notice_range->last_page_id > last_page_id)
@


10.10.1.13.0.1
log
@Added the "const" attribute to the sigio handler "req" arguments.
@
text
@d39 1
a39 1
 * $Id: repo.c,v 10.10.1.13 1998/07/07 06:25:32 alc Exp alc $
d84 2
a85 3
void
Tmk_repo_sigio_handler(
	const struct req *req)
d93 2
a94 3
void
Tmk_repo_sigio_duplicate_handler(
	const struct req *req)
@


10.10.1.13.0.2
log
@Bug Fix!  Added a cast from unsigned short to int so that
a comparison to an int worked properly.  This is a problem
on the Alpha and the RS6k with the AIX 4.2 compilers.
@
text
@d39 1
a39 1
 * $Id: repo.c,v 10.10.1.13.0.1 1998/07/17 03:40:52 alc Exp alc $
d230 1
a230 1
				if ((int) write_notice_range->first_page_id < first_page_id)
d233 1
a233 1
				if ((int) write_notice_range->last_page_id > last_page_id)
@


10.9
log
@Extracted the repo barrier code from Tmk_repo, eliminating the duplication
of code.
@
text
@d39 1
a39 1
 * $Id: repo.c,v 10.8 1997/05/09 21:33:51 alc Exp alc $
a83 2
static	sigset_t	ALRM_mask;

d148 1
a148 3
 * mask_ptr specifies the signals to unblock when a slave processor
 * performs a receive.  If SIGIO remains blocked, incoming requests
 * are held.
d151 1
a151 2
void	repo_barrier(
	sigset_t       *mask_ptr)
d165 1
a165 1
				Tmk_perrexit("<write>Tmk_repo");
d168 1
a168 1
				Tmk_perrexit("<send>Tmk_repo");
d180 1
a180 1
			Tmk_perrexit("<write>Tmk_repo");
d183 1
a183 1
			Tmk_perrexit("<send>Tmk_repo");
d189 1
a189 1
		sigio_mutex(SIG_UNBLOCK, mask_ptr, &mask);
d199 1
a199 1
					Tmk_err("<timeout: 0>Tmk_repo: seqno == %d\n", req_typ.seqno);
d209 1
a209 1
				Tmk_perrexit("<read>Tmk_repo");
d211 1
a211 1
				Tmk_perrexit("<recv>Tmk_repo");
d216 1
a216 1
				Tmk_err("<bad seqno: 0>Tmk_repo: seqno == %d (received: %d)\n", req_typ.seqno, rep_seqno);
d293 1
a293 6

	/*
	 * Unblock SIGALRM and SIGIO, allowing the slave processors
	 * to handle incoming requests (particularly for diffs).
	 */
	repo_barrier(&ALRM_and_IO_mask);
d314 5
a318 4
	 * Unblock SIGALRM only, preventing the slave processors
	 * from handling incoming requests.  In case the repo barrier
	 * departure message is lost, this prevents a post-repo lock request
	 * from ... (I'm paranoid.)
d320 1
a320 1
	repo_barrier(&ALRM_mask);
a331 3

	sigemptyset(&ALRM_mask);
	sigaddset(&ALRM_mask, SIGALRM);
@


10.8
log
@The previous revision (10.7) created a problem
in Tmk_repo_sigio_duplicate_handler.  It was failing
to respond to a retransmitted arrival message because
it thought that the repo "barrier" wasn't complete.  In fact,
the arrival message was for the previous repo "barrier" that
had been completed.  Now, check each processor's arrival bit
individually.
@
text
@d39 1
a39 1
 * $Id: repo.c,v 10.7 1997/05/09 07:15:20 alc Exp alc $
d84 2
d116 3
a118 2
static	int	repo_update_manager(page)
	page_t	page;
d150 3
a152 1
 * The caller must block sigio
d154 3
a156 1
void	Tmk_repo()
d158 1
a158 12
	int		i, j;
	sigset_t	mask;
	unsigned	rep_seqno;

	if (Tmk_debug)
		Tmk_err("repo: begin\n");

	for (i = 0; i < Tmk_npages; i++) {

		page_t	page = &page_array_[i];

		if (page->state == valid) {
d160 1
a160 51
			if (page->twin) {

				Tmk_free_twin(page);

				page->state = private;
			}
		}
		else if (page->state == invalid) {

			write_notice_t	write_notice;

			if (Tmk_debug)
				Tmk_err("page: %d ", i);

			if (write_notice = page->write_notice_[Tmk_proc_id]) {

				unsigned short	time = write_notice->interval->vector_time_[Tmk_proc_id];

				for (j = 0; j < Tmk_nprocs; j++) {
					if (j == Tmk_proc_id)
						continue;

					if (write_notice = page->write_notice_[j]) {

						if (write_notice->interval->vector_time_[Tmk_proc_id] >= time)
							goto discard;
					}
				}
				if (0 > mprotect(page->vadr, Tmk_page_size, PROT_READ|PROT_WRITE))
					Tmk_perrexit("<mprotect>Tmk_repo");

				Tmk_diff_request(page);

				if (0 > mprotect(page->vadr, Tmk_page_size, PROT_READ))
					Tmk_perrexit("<mprotect>Tmk_repo");
			}
			else {
		discard:
				page->state = empty;

				if (0 == repo_update_manager(page))
					Tmk_errexit("Tmk_repo\n");

				if (Tmk_debug)
					Tmk_err("discarded\n");
			}
		}
		else if (page->state == empty)
			repo_update_manager(page);
	}
	if (Tmk_proc_id == 0) {
d169 1
a169 1
			if (0 > write(rep_fd_[j], &repo_seqno_[j], sizeof(rep_seqno)))
d172 1
a172 1
			if (0 > send(rep_fd_[j], (char *)&repo_seqno_[j], sizeof(rep_seqno), 0))
d177 4
d194 1
a194 1
		sigio_mutex(SIG_UNBLOCK, &ALRM_and_IO_mask, &mask);
d230 8
a237 1
	for (i = 0; i < NPROCS; i++) {
d239 2
a240 1
		proc_array_[i].prev = proc_array_[i].next = &proc_array_[i];
a241 2
		proc_vector_time_[i] = inverse_time_[i] = 0;
	}
d246 10
a255 1
		assert(page->twin == 0);
d257 1
a257 3
		memset(page->write_notice_, 0, sizeof(page->write_notice_));
	}
	Tmk_diff_repo();
d259 2
a260 1
	Tmk_interval_repo();
d262 1
a262 1
	if (Tmk_proc_id == 0) {
d264 1
a264 2
		while (spinmask ^ repo_mask)
			sigio_handler();
d266 3
a268 1
		repo_mask = 0;
d270 1
a270 11
		for (j = 1; j < Tmk_nprocs; j++)
#if defined(ultrix)
			if (0 > write(rep_fd_[j], &repo_seqno_[j], sizeof(rep_seqno)))
				Tmk_perrexit("<write>Tmk_repo");
#else
			if (0 > send(rep_fd_[j], (char *)&repo_seqno_[j], sizeof(rep_seqno), 0))
				Tmk_perrexit("<send>Tmk_repo");
#endif
	}
	else {
		sigset_t	ALRM_mask;
d272 6
a277 2
		sigemptyset(&ALRM_mask);
		sigaddset(&ALRM_mask, SIGALRM);
d279 1
a279 10
		req_typ.seqno = req_seqno += SEQNO_INCR;
	rexmit2:
#if defined(ultrix)
		if (0 > write(req_fd_[0], &req_typ, sizeof(req_typ)))
			Tmk_perrexit("<write>Tmk_repo");
#else
		if (0 > send(req_fd_[0], (char *)&req_typ, sizeof(req_typ), 0))
			Tmk_perrexit("<send>Tmk_repo");
#endif
		Tmk_tout_flag = 0;
d281 6
a286 1
		setitimer(ITIMER_REAL, &Tmk_tout, NULL);
d288 2
a289 8
		sigio_mutex(SIG_UNBLOCK, &ALRM_mask, &mask);
	retry2:
#if defined(ultrix)
		if (0 > read(req_fd_[0], &rep_seqno, sizeof(rep_seqno)))
#else
		if (0 > recv(req_fd_[0], (char *)&rep_seqno, sizeof(rep_seqno), 0))
#endif
			if (Tmk_tout_flag) {
d292 14
a305 1
					Tmk_err("<timeout: 0>Tmk_repo: seqno == %d\n", req_typ.seqno);
d307 1
a307 1
				sigio_mutex(SIG_SETMASK, &mask, NULL);
d309 3
a311 11
				goto rexmit2;
			}
			else if (errno == EINTR)
				goto retry2;
			else
#if defined(ultrix)
				Tmk_perrexit("<read>Tmk_repo");
#else
				Tmk_perrexit("<recv>Tmk_repo");
#endif
		if (rep_seqno != req_typ.seqno) {
d313 1
a313 2
			if (Tmk_debug)
				Tmk_err("<bad seqno: 0>Tmk_repo: seqno == %d (received: %d)\n", req_typ.seqno, rep_seqno);
d315 1
a315 3
			goto retry2;
		}
		sigio_mutex(SIG_SETMASK, &mask, NULL);
d317 1
a317 2
		Tmk_stat.messages++;
		Tmk_stat.bytes += sizeof(rep_seqno);
d319 12
d335 4
a338 1
void	Tmk_repo_initialize()
d341 3
@


10.7
log
@Added a preliminary fix for the following problem: Consider what
happens if the repo completion message from the master processor,
i.e., id 0, gets lost, AND the master processor requests a lock
from that same processor whose repo completion message didn't arrive.
The master processor will receive non-sensical consistency data
from before the repo.  Later, it may try to fetch one of the corresponding
diffs and the program will fail.

A duplicated message could still wreak havoc.  We may need to add
an "epoch" number, corresponding to the number of performed repo's
to each message.  Yuck!  More overhead.
@
text
@d39 1
a39 1
 * $Id: repo.c,v 10.6 1996/08/24 21:10:49 alc Exp alc $
d101 1
a101 1
	if (repo_mask == 0)
@


10.6
log
@Replaced sigprocmask by sigio_mutex.  Sigio_mutex is defined
in Tmk.h.
@
text
@d39 1
a39 1
 * $Id: repo.c,v 10.5 1996/08/24 20:01:11 alc Exp alc $
d298 71
@


10.5
log
@Replaced "seqno += NPROCS" by "+= SEQNO_INCR".
@
text
@d39 1
a39 1
 * $Id: repo.c,v 10.4 1996/08/09 21:06:14 alc Exp alc $
d244 1
a244 1
		sigprocmask(SIG_UNBLOCK, &ALRM_and_IO_mask, &mask);
d256 1
a256 1
				sigprocmask(SIG_SETMASK, &mask, NULL);
d275 1
a275 1
		sigprocmask(SIG_SETMASK, &mask, NULL);
@


10.4
log
@Replace "page->private" with "page->state".  As a side effect,
this reduces the repo overhead on private pages.
@
text
@d39 1
a39 1
 * $Id: repo.c,v 10.3 1996/08/08 04:50:50 alc Exp alc $
d231 1
a231 1
		req_typ.seqno = req_seqno += NPROCS;
@


10.3
log
@Replace "page->valid" and "page->empty" with "page->state".
@
text
@d39 1
a39 1
 * $Id: repo.c,v 10.2 1996/08/03 21:11:19 alc Exp alc $
d168 1
a168 1
				page->private = 1;
d186 1
a186 1
					write_notice = page->write_notice_[j];
d188 3
a190 2
					if (write_notice && write_notice->interval->vector_time_[Tmk_proc_id] >= time)
						goto discard;
d211 1
a211 1
		else
@


10.2
log
@Replaced "copyset" bit mask by "private" Boolean.
@
text
@d39 1
a39 1
 * $Id$
d162 1
a162 1
		if (page->valid) {
d171 1
a171 1
		else if (page->empty == 0) {
d201 1
a201 1
				page->empty = 1;
@


10.1
log
@Tmk-0.10.1R
@
text
@d37 4
a40 2
/*****************************************************************************
 * File:		repo.c
d69 1
a69 2
 *
 *****************************************************************************/
d168 1
a168 1
				page->copyset = 1 << Tmk_proc_id;
@


10.1.3.1
log
@Tmk-0.10.1.1R: IRIX 6.2 support.
@
text
@@


10.1.3.2
log
@Adapted the changes from revisions 10.7-10.10.
@
text
@d37 2
a38 4

/*
 * $Id$
 *
d67 2
a68 1
 */
d100 1
a100 1
	if ((repo_mask & (1 << req->from)) == 0)
a145 80
 *
 */
static
void	repo_barrier( void )
{
	if (Tmk_proc_id == 0) {

		int	j;

		while (spinmask ^ repo_mask)
			sigio_handler();

		repo_mask = 0;

		for (j = 1; j < Tmk_nprocs; j++)
#if defined(ultrix)
			if (0 > write(rep_fd_[j], &repo_seqno_[j], sizeof(rep_seqno_[j])))
				Tmk_perrexit("<write>repo_barrier");
#else
			if (0 > send(rep_fd_[j], (char *)&repo_seqno_[j], sizeof(rep_seqno_[j]), 0))
				Tmk_perrexit("<send>repo_barrier");
#endif
	}
	else {
		sigset_t	mask;

		unsigned	rep_seqno;

		req_typ.seqno = req_seqno += NPROCS;
	rexmit:
#if defined(ultrix)
		if (0 > write(req_fd_[0], &req_typ, sizeof(req_typ)))
			Tmk_perrexit("<write>repo_barrier");
#else
		if (0 > send(req_fd_[0], (char *)&req_typ, sizeof(req_typ), 0))
			Tmk_perrexit("<send>repo_barrier");
#endif
		Tmk_tout_flag = 0;

		setitimer(ITIMER_REAL, &Tmk_tout, NULL);

		sigprocmask(SIG_UNBLOCK, &ALRM_and_IO_mask, &mask);
	retry:
#if defined(ultrix)
		if (0 > read(req_fd_[0], &rep_seqno, sizeof(rep_seqno)))
#else
		if (0 > recv(req_fd_[0], (char *)&rep_seqno, sizeof(rep_seqno), 0))
#endif
			if (Tmk_tout_flag) {

				if (Tmk_debug)
					Tmk_err("<timeout: 0>repo_barrier: seqno == %d\n", req_typ.seqno);

				sigprocmask(SIG_SETMASK, &mask, NULL);

				goto rexmit;
			}
			else if (errno == EINTR)
				goto retry;
			else
#if defined(ultrix)
				Tmk_perrexit("<read>repo_barrier");
#else
				Tmk_perrexit("<recv>repo_barrier");
#endif
		if (rep_seqno != req_typ.seqno) {

			if (Tmk_debug)
				Tmk_err("<bad seqno: 0>repo_barrier: seqno == %d (received: %d)\n", req_typ.seqno, rep_seqno);

			goto retry;
		}
		sigprocmask(SIG_SETMASK, &mask, NULL);

		Tmk_stat.messages++;
		Tmk_stat.bytes += sizeof(rep_seqno);
	}
}

/*
d151 2
d212 27
a238 1
	repo_barrier();
d240 38
a294 9

	/*
	 * Prevent a post repo lock request from receiving out-of-date
	 * consistency information.  Without the following repo
	 * barrier, a post repo lock request might be handled within
	 * the earlier repo barrier (before the consistency
	 * information is flushed). 
	 */
	repo_barrier();
@


10.1.4.1
log
@MPL Support
@
text
@a189 1
#if ! defined(THREADS)
d192 1
a192 1
#endif
a213 2
		sigio_mutex(SIG_UNBLOCK, &IO_mask, &mask, UNLOCK);

d215 1
a215 1
			;
a218 2
		sigio_mutex(SIG_SETMASK, &mask, NULL, LOCK);

d242 1
a242 1
		sigio_mutex(SIG_UNBLOCK, &ALRM_and_IO_mask, &mask, UNLOCK);
d254 1
a254 1
				sigio_mutex(SIG_BLOCK, &ALRM_and_IO_mask, NULL, LOCK);
d273 1
a273 1
		sigio_mutex(SIG_SETMASK, &mask, NULL, LOCK);
@


10.1.4.2
log
@Eliminated seqno and extra copying from MPL messages.
@
text
@d234 1
a234 1
		req_typ.seqno = req_seqno += SEQNO_INCR;
@


10.1.5.1
log
@Start of 0.10.1 THREADS branch. Incorporated alias code from SMP branch.
@
text
@a189 1
#if ! defined(THREADS)
d192 1
a192 1
#endif
@


10.1.5.2
log
@Added sigio_lock and monitor_lock. Changed segv_handler to avoid race condition.
@
text
@d214 2
a215 10
#if defined(THREADS)
		pthread_mutex_unlock(&sigio_lock);
#endif
		while (spinmask ^ repo_mask) {
#if defined(THREADS)
			const struct timespec timeout = {1,0};
			if (0 > sigtimedwait(&mask, NULL, &timeout));
				if ((errno != EINTR) && (errno != EAGAIN))
					Tmk_perrexit("<sigtimedwait>Tmk_barrier");			
#else
a216 2
#endif
		}
d219 1
a219 3
#if defined(THREADS)
		pthread_mutex_lock(&sigio_lock);
#endif
d242 1
a242 3
#if defined(THREADS)
		pthread_mutex_unlock(&sigio_lock);
#endif
d256 1
a256 3
#if defined(THREADS)
				pthread_mutex_lock(&sigio_lock);
#endif
d275 1
a275 3
#if defined(THREADS)
		pthread_mutex_lock(&sigio_lock);
#endif
@


10.1.5.3
log
@eliminated sigtimedwait (explicitly unblock signals instead)
@
text
@a215 2

		sigprocmask(SIG_SETMASK, &mask, NULL);
d219 4
a222 1
			/* NOTHING */
a229 2
		sigprocmask(SIG_BLOCK, &ALRM_and_IO_mask, NULL);

@


10.1.5.4
log
@Cleaned up sigprocmask/pthread_sigmask/sigthreadmask and sigio
locking/unlocking with sigio_mutex macro
@
text
@d214 2
a215 3
		sigset_t	IO_mask;
		sigemptyset(&IO_mask);
		sigaddset(&IO_mask, SIGIO);
d217 9
a225 1
		sigio_mutex(SIG_UNBLOCK, &IO_mask, &mask, UNLOCK);
a226 3
		while (spinmask ^ repo_mask)
			;

d228 2
d231 2
a232 2
		sigio_mutex(SIG_SETMASK, &mask, NULL, LOCK);

d255 4
a258 2

		sigio_mutex(SIG_UNBLOCK, &ALRM_and_IO_mask, &mask, UNLOCK);
d270 4
a273 2
				sigio_mutex(SIG_SETMASK, &mask, NULL, LOCK);

d291 4
a294 2
		sigio_mutex(SIG_SETMASK, &mask, NULL, LOCK);

@


10.1.5.5
log
@cleaned up signal masks
@
text
@d214 3
d262 1
a262 1
				sigio_mutex(SIG_BLOCK, &ALRM_and_IO_mask, NULL, LOCK);
@


10.1.5.6
log
@Added $Id$
@
text
@a67 2
 * $Id$
 *
@


10.1.2.1
log
@changed page_dirty list and intervals to use ranges
@
text
@@


10.0
log
@POSIX Version
@
text
@d242 1
a242 1
		sigprocmask(SIG_SETMASK, &empty_mask, &mask);
@


10.0.3.1
log
@Initial Linux port by Rob Fowler.
@
text
@@


10.0.2.1
log
@Start of the 0.10.1 development branch
@
text
@@


10.0.2.2
log
@Eliminated empty_mask and BUS_or_SEGV_mask.  Use SIG_UNBLOCK instead.
@
text
@d242 1
a242 1
		sigprocmask(SIG_UNBLOCK, &ALRM_and_IO_mask, &mask);
@


10.0.2.2.2.1
log
@Start of the 0.10.1 multiprocessor development branch
@
text
@@


10.0.2.2.2.2
log
@Eliminated the mprotect operation in Tmk_repo before the call
to Tmk_diff_request, which uses the v_alias mapping.
@
text
@a189 1
#if ! defined(__sgi)
d192 1
a192 1
#endif
@


10.0.2.2.2.3
log
@Added sigio locking inside existing critical sections (sigprocmask). <SMP>
@
text
@d242 1
a242 3
#if defined(__sgi)
		release_lock(&sigio_lock);	/* SMP */
#endif
d256 1
a256 3
#if defined(__sgi)
				spin_lock(&sigio_lock);	/* SMP */
#endif
d275 1
a275 3
#if   defined(__sgi)
		spin_lock(&sigio_lock);	/* SMP */
#endif
@


10.0.1.1
log
@FASTLINK Version
@
text
@@


9.7
log
@Tmk-0.9.7R
@
text
@d3 2
a4 2
 *  Copyright (c) 1991-1994                                                  *
 *  by TreadMarks, L.L.C. (TREADMARKS), Houston, Texas	  		     *
d6 5
a10 5
 *  This software is furnished under a license and may be used and  copied   *
 *  only  in  accordance  with  the  terms  of  such  license and with the   *
 *  inclusion of the above copyright notice.  This software or  any  other   *
 *  copies  thereof may not be provided or otherwise made available to any   *
 *  other person.  No title to or ownership of  the  software  is  hereby    *
d15 2
a16 2
 *  confidential and proprietary to TREADMARKS.  RECIPIENT agrees to take    *
 *  all reasonable steps to safeguard the software, and to prevent its       *
d19 2
a20 2
 *  The information in this software is subject to change  without  notice   *
 *  and should  not  be  construed  as  a commitment by TREADMARKS.	     *
d24 6
a29 7
 *  of merchantability or fitness), with regard to the software.  	     *
 *  TREADMARKS assumes no responsibility for the use or reliability of its   *
 *  software.  TREADMARKS shall not be liable for any special, incidental,   *
 *  or consequential damages, or any damages whatsoever due to causes beyond *
 *  the reasonable control of TREADMARKS, loss of use, data or profits, or   *
 *  from loss or destruction of materials provided to TREADMARKS by	     *
 *  RECIPIENT.								     *
d31 4
a34 4
 *  TREADMARKS's liability for damages arising out of or in connection with  *
 *  the use or performance of this software, whether in an action of	     *
 *  contract or tort including negligence, shall be limited to the purchase  *
 *  price, or the total amount paid by RECIPIENT, whichever is less.	     *
d64 4
d105 1
a105 1
		if (0 > send(rep_fd_[req->from], &req->seqno, sizeof(req->seqno), 0))
d151 1
a151 1
	int		mask;
d224 1
a224 1
			if (0 > send(rep_fd_[j], &repo_seqno_[j], sizeof(rep_seqno), 0))
d235 1
a235 1
		if (0 > send(req_fd_[0], &req_typ, sizeof(req_typ), 0))
d242 1
a242 1
		mask = sigsetmask(0);
d247 1
a247 1
		if (0 > recv(req_fd_[0], &rep_seqno, sizeof(rep_seqno), 0))
d254 1
a254 1
				sigsetmask(mask);
d273 1
a273 1
		sigsetmask(mask);
@


9.7.6.1
log
@with newbarrier
@
text
@a273 5

		Tmk_stat.repo_reply++;
		Tmk_stat.repo_reply_bytes += sizeof(rep_seqno);


@


9.7.2.1
log
@Start of the 0.9.8 development branch
@
text
@a150 2
	Tmk_stat.repos++;

@


9.6
log
@*** empty log message ***
@
text
@d287 1
a287 1
		bzero((char *) page->write_notice_, sizeof(page->write_notice_));
@


9.6.1.1
log
@FASTLINK Version
@
text
@@


9.5
log
@*** empty log message ***
@
text
@@


9.5.1.1
log
@FASTLINK Version
@
text
@@


9.4
log
@*** empty log message ***
@
text
@@
